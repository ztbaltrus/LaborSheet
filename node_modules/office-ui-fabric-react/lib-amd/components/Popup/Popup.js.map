{"version":3,"file":"Popup.js","sourceRoot":"../src/","sources":["components/Popup/Popup.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\r\nimport {\r\n  BaseComponent,\r\n  KeyCodes,\r\n  divProperties,\r\n  doesElementContainFocus,\r\n  getDocument,\r\n  getNativeProps,\r\n  createRef\r\n} from '../../Utilities';\r\nimport { IPopupProps } from './Popup.types';\r\n\r\nexport interface IPopupState {\r\n  needsVerticalScrollBar?: boolean;\r\n}\r\n\r\n/**\r\n * This adds accessibility to Dialog and Panel controls\r\n */\r\nexport class Popup extends BaseComponent<IPopupProps, IPopupState> {\r\n\r\n  public static defaultProps: IPopupProps = {\r\n    shouldRestoreFocus: true\r\n  };\r\n\r\n  public _root = createRef<HTMLDivElement>();\r\n\r\n  private _originalFocusedElement: HTMLElement;\r\n  private _containsFocus: boolean;\r\n\r\n  public constructor(props: IPopupProps) {\r\n    super(props);\r\n    this.state = { needsVerticalScrollBar: false };\r\n  }\r\n\r\n  public componentWillMount(): void {\r\n    this._originalFocusedElement = getDocument()!.activeElement as HTMLElement;\r\n  }\r\n\r\n  public componentDidMount(): void {\r\n    if (!this._root.current) {\r\n      return;\r\n    }\r\n\r\n    this._events.on(this._root.current, 'focus', this._onFocus, true);\r\n    this._events.on(this._root.current, 'blur', this._onBlur, true);\r\n\r\n    if (doesElementContainFocus(this._root.current)) {\r\n      this._containsFocus = true;\r\n    }\r\n\r\n    this._updateScrollBarAsync();\r\n  }\r\n\r\n  public componentDidUpdate() {\r\n    this._updateScrollBarAsync();\r\n  }\r\n\r\n  public componentWillUnmount(): void {\r\n    if (\r\n      this.props.shouldRestoreFocus &&\r\n      this._originalFocusedElement &&\r\n      this._containsFocus &&\r\n      this._originalFocusedElement as any !== window) {\r\n      // This slight delay is required so that we can unwind the stack, let react try to mess with focus, and then\r\n      // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants\r\n      // to reset the focus back to the thing it thinks should have been focused.\r\n      if (this._originalFocusedElement) {\r\n        this._originalFocusedElement.focus();\r\n      }\r\n    }\r\n  }\r\n\r\n  public render(): JSX.Element {\r\n    const { role, className, ariaLabel, ariaLabelledBy, ariaDescribedBy, style } = this.props;\r\n\r\n    return (\r\n      <div\r\n        ref={ this._root }\r\n        { ...getNativeProps(this.props, divProperties) }\r\n        className={ className }\r\n        role={ role }\r\n        aria-label={ ariaLabel }\r\n        aria-labelledby={ ariaLabelledBy }\r\n        aria-describedby={ ariaDescribedBy }\r\n        onKeyDown={ this._onKeyDown }\r\n        style={ { overflowY: this.state.needsVerticalScrollBar ? 'scroll' : undefined, ...style } }\r\n      >\r\n        { this.props.children }\r\n      </div>\r\n    );\r\n  }\r\n\r\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\r\n    switch (ev.which) {\r\n      case KeyCodes.escape:\r\n\r\n        if (this.props.onDismiss) {\r\n          this.props.onDismiss(ev);\r\n\r\n          ev.preventDefault();\r\n          ev.stopPropagation();\r\n        }\r\n\r\n        break;\r\n    }\r\n  }\r\n\r\n  private _updateScrollBarAsync(): void {\r\n    this._async.requestAnimationFrame(() => {\r\n      this._getScrollBar();\r\n    });\r\n  }\r\n\r\n  private _getScrollBar(): void {\r\n    // If overflowY is overriden, don't waste time calculating whether the scrollbar is necessary.\r\n    if (this.props.style && this.props.style.overflowY) {\r\n      return;\r\n    }\r\n\r\n    let needsVerticalScrollBar = false;\r\n    if (this._root && this._root.current && this._root.current.firstElementChild) {\r\n      // ClientHeight returns the client height of an element rounded to an\r\n      // integer. On some browsers at different zoom levels this rounding\r\n      // can generate different results for the root container and child even\r\n      // though they are the same height. This causes us to show a scroll bar\r\n      // when not needed. Ideally we would use BoundingClientRect().height\r\n      // instead however seems that the API is 90% slower than using ClientHeight.\r\n      // Therefore instead we will calculate the difference between heights and\r\n      // allow for a 1px difference to still be considered ok and not show the\r\n      // scroll bar.\r\n      const rootHeight = this._root.current.clientHeight;\r\n      const firstChildHeight = this._root.current.firstElementChild.clientHeight;\r\n      if (rootHeight > 0 && firstChildHeight > rootHeight) {\r\n        needsVerticalScrollBar = (firstChildHeight - rootHeight) > 1;\r\n      }\r\n    }\r\n    if (this.state.needsVerticalScrollBar !== needsVerticalScrollBar) {\r\n      this.setState({\r\n        needsVerticalScrollBar: needsVerticalScrollBar\r\n      });\r\n    }\r\n  }\r\n\r\n  private _onFocus(): void {\r\n    this._containsFocus = true;\r\n  }\r\n\r\n  private _onBlur(ev: React.FocusEvent<HTMLElement>): void {\r\n    if (this._root.value && this._root.value.contains(ev.relatedTarget as HTMLElement)) {\r\n      this._containsFocus = false;\r\n    }\r\n  }\r\n}\r\n"]}