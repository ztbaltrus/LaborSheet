{"version":3,"file":"ComboBox.js","sourceRoot":"../src/","sources":["components/ComboBox/ComboBox.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\r\n\r\nimport {\r\n  CommandButton,\r\n  IButtonStyles,\r\n  IconButton\r\n} from '../../Button';\r\nimport { Callout } from '../../Callout';\r\nimport { Checkbox } from '../../Checkbox';\r\nimport { KeytipData } from '../../KeytipData';\r\nimport { Label } from '../../Label';\r\nimport {\r\n  BaseComponent,\r\n  KeyCodes,\r\n  createRef,\r\n  css,\r\n  customizable,\r\n  divProperties,\r\n  findIndex,\r\n  getId,\r\n  getNativeProps,\r\n  shallowCompare\r\n} from '../../Utilities';\r\nimport { DirectionalHint } from '../../common/DirectionalHint';\r\nimport { SelectableOptionMenuItemType } from '../../utilities/selectableOption/SelectableOption.types';\r\nimport { Autofill, IAutofill } from '../Autofill/index';\r\nimport {\r\n  IComboBoxClassNames,\r\n  getClassNames,\r\n  getComboBoxOptionClassNames\r\n} from './ComboBox.classNames';\r\nimport {\r\n  getCaretDownButtonStyles,\r\n  getOptionStyles,\r\n  getStyles\r\n} from './ComboBox.styles';\r\nimport { IComboBoxOption, IComboBoxOptionStyles, IComboBoxProps } from './ComboBox.types';\r\n\r\nexport interface IComboBoxState {\r\n\r\n  // The open state\r\n  isOpen?: boolean;\r\n\r\n  // The currently selected indices\r\n  selectedIndices?: number[];\r\n\r\n  // The focused state of the comboBox\r\n  focused?: boolean;\r\n\r\n  // This value is used for the autocomplete hint value\r\n  suggestedDisplayValue?: string;\r\n\r\n  // The options currently available for the callout\r\n  currentOptions: IComboBoxOption[];\r\n\r\n  // when taking input, this will store the index the\r\n  // that the options input matches (-1 if no input or match)\r\n  currentPendingValueValidIndex: number;\r\n\r\n  // This will store the hovered over value in the dropdown\r\n  // it is used for styling the options without updating the input\r\n  currentPendingValueValidIndexOnHover: number;\r\n\r\n  // when taking input, this will store\r\n  // the actual text that is being entered\r\n  currentPendingValue: string;\r\n}\r\n\r\nenum SearchDirection {\r\n  backward = -1,\r\n  none = 0,\r\n  forward = 1\r\n}\r\n\r\nenum HoverStatus {\r\n  // This is used when the user was hovering\r\n  // and has since moused out of the menu items\r\n  clearAll = -2,\r\n  // This is the default \"normal\" state\r\n  // when no hover has happened or a hover is in progress\r\n  default = -1\r\n}\r\n\r\nconst ScrollIdleDelay = 250 /* ms */;\r\nconst TouchIdleDelay = 500; /* ms */\r\n\r\n// This is used to clear any pending autocomplete\r\n// text (used when autocomplete is true and allowFreeform is false)\r\nconst ReadOnlyPendingAutoCompleteTimeout = 1000 /* ms */;\r\ninterface IComboBoxOptionWrapperProps extends IComboBoxOption {\r\n  // True if the option is currently selected\r\n  isSelected: boolean;\r\n\r\n  // A function that returns the children of the OptionWrapper. We pass this in as a function to ensure that\r\n  // children methods don't get called unnecessarily if the component doesn't need to be updated. This leads\r\n  // to a significant performance increase in ComboBoxes with many options and/or complex onRenderOption functions\r\n  render: () => JSX.Element;\r\n}\r\n\r\n// Internal class that is used to wrap all ComboBox options\r\n// This is used to customize when we want to rerender components,\r\n// so we don't rerender every option every time render is executed\r\nclass ComboBoxOptionWrapper extends React.Component<IComboBoxOptionWrapperProps, {}> {\r\n  public render(): React.ReactNode {\r\n    return this.props.render();\r\n  }\r\n\r\n  public shouldComponentUpdate(newProps: IComboBoxOptionWrapperProps): boolean {\r\n    // The render function will always be different, so we ignore that prop\r\n    return !shallowCompare({ ...this.props, render: undefined }, { ...newProps, render: undefined });\r\n  }\r\n}\r\n\r\n@customizable('ComboBox', ['theme'])\r\nexport class ComboBox extends BaseComponent<IComboBoxProps, IComboBoxState> {\r\n\r\n  public static defaultProps: IComboBoxProps = {\r\n    options: [],\r\n    allowFreeform: false,\r\n    autoComplete: 'on',\r\n    buttonIconProps: { iconName: 'ChevronDown' }\r\n  };\r\n\r\n  private _root = createRef<HTMLDivElement>();\r\n\r\n  // The input aspect of the comboBox\r\n  private _autofill = createRef<IAutofill>();\r\n\r\n  // The wrapping div of the input and button\r\n  private _comboBoxWrapper = createRef<HTMLDivElement>();\r\n\r\n  // The callout element\r\n  private _comboBoxMenu = createRef<HTMLDivElement>();\r\n\r\n  // The menu item element that is currently selected\r\n  private _selectedElement = createRef<HTMLSpanElement>();\r\n\r\n  // The base id for the comboBox\r\n  private _id: string;\r\n\r\n  // After a character is inserted when autocomplete is true and\r\n  // allowFreeform is false, remember the task that will clear\r\n  // the pending string of characters\r\n  private _lastReadOnlyAutoCompleteChangeTimeoutId: number | undefined;\r\n\r\n  // Promise used when resolving the comboBox options\r\n  private _currentPromise: PromiseLike<IComboBoxOption[]>;\r\n\r\n  // The current visible value sent to the auto fill on render\r\n  private _currentVisibleValue: string | undefined;\r\n\r\n  private _classNames: IComboBoxClassNames;\r\n\r\n  private _isScrollIdle: boolean;\r\n\r\n  private _hasPendingValue: boolean;\r\n\r\n  private _scrollIdleTimeoutId: number | undefined;\r\n\r\n  private _processingTouch: boolean;\r\n\r\n  private _lastTouchTimeoutId: number | undefined;\r\n\r\n  // Determines if we should be setting\r\n  // focus back to the input when the menu closes.\r\n  // The general rule of thumb is if the menu was launched\r\n  // vai the keyboard focus should go back to the input,\r\n  // if it was dropped via the mouse focus should not be\r\n  // forced back to the input\r\n  private _focusInputAfterClose: boolean;\r\n\r\n  constructor(props: IComboBoxProps) {\r\n    super(props);\r\n\r\n    this._warnMutuallyExclusive({\r\n      'defaultSelectedKey': 'selectedKey',\r\n      'text': 'defaultSelectedKey',\r\n      'value': 'defaultSelectedKey',\r\n      'selectedKey': 'value',\r\n      'dropdownWidth': 'useComboBoxAsMenuWidth',\r\n    });\r\n\r\n    this._warnDeprecations({ 'value': 'text' });\r\n\r\n    this._id = props.id || getId('ComboBox');\r\n\r\n    const selectedKeys: (string | number)[] = this._getSelectedKeys(props.defaultSelectedKey, props.selectedKey);\r\n\r\n    this._isScrollIdle = true;\r\n    this._processingTouch = false;\r\n\r\n    const initialSelectedIndices: number[] = this._getSelectedIndices(props.options, selectedKeys);\r\n\r\n    this.state = {\r\n      isOpen: false,\r\n      selectedIndices: initialSelectedIndices,\r\n      focused: false,\r\n      suggestedDisplayValue: '',\r\n      currentOptions: this.props.options,\r\n      currentPendingValueValidIndex: -1,\r\n      currentPendingValue: '',\r\n      currentPendingValueValidIndexOnHover: HoverStatus.default\r\n    };\r\n  }\r\n\r\n  public componentDidMount(): void {\r\n    if (this._comboBoxWrapper.current) {\r\n      // hook up resolving the options if needed on focus\r\n      this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\r\n      if ('onpointerdown' in this._comboBoxWrapper.current) {\r\n        // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\r\n        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\r\n        // does not support Pointer events yet.\r\n        this._events.on(this._comboBoxWrapper.value, 'pointerdown', this._onPointerDown, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  public componentWillReceiveProps(newProps: IComboBoxProps): void {\r\n    // Update the selectedIndex and currentOptions state if\r\n    // the selectedKey, value, or options have changed\r\n    if (newProps.selectedKey !== this.props.selectedKey ||\r\n      newProps.text !== this.props.text ||\r\n      newProps.value !== this.props.value ||\r\n      newProps.options !== this.props.options) {\r\n      const selectedKeys: string[] | number[] = this._getSelectedKeys(undefined, newProps.selectedKey);\r\n      const indices: number[] = this._getSelectedIndices(newProps.options, selectedKeys);\r\n\r\n      this.setState({\r\n        selectedIndices: indices,\r\n        currentOptions: newProps.options\r\n      });\r\n    }\r\n  }\r\n\r\n  public componentDidUpdate(prevProps: IComboBoxProps, prevState: IComboBoxState) {\r\n    const {\r\n      allowFreeform,\r\n      text,\r\n      value,\r\n      onMenuOpen,\r\n      onMenuDismissed\r\n    } = this.props;\r\n    const {\r\n      isOpen,\r\n      focused,\r\n      selectedIndices,\r\n      currentPendingValueValidIndex\r\n    } = this.state;\r\n\r\n    // If we are newly open or are open and the pending valid index changed,\r\n    // make sure the currently selected/pending option is scrolled into view\r\n    if (isOpen &&\r\n      (!prevState.isOpen ||\r\n        prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\r\n      // Need this timeout so that the selectedElement ref is correctly updated\r\n      this._async.setTimeout(() => this._scrollIntoView(), 0);\r\n    }\r\n\r\n    // If we are open or we are just closed, shouldFocusAfterClose is set,\r\n    // are focused but we are not the activeElement set focus on the input\r\n    if (isOpen ||\r\n      (prevState.isOpen &&\r\n        !isOpen &&\r\n        this._focusInputAfterClose &&\r\n        focused &&\r\n        this._autofill.current &&\r\n        document.activeElement !== this._autofill.current.inputElement)) {\r\n      this.focus();\r\n    }\r\n\r\n    // If we should focusAfterClose AND\r\n    //   just opened/closed the menu OR\r\n    //   are focused AND\r\n    //     updated the selectedIndex with the menu closed OR\r\n    //     are not allowing freeform OR\r\n    //     the value changed\r\n    // we need to set selection\r\n    if (this._focusInputAfterClose && (prevState.isOpen && !isOpen ||\r\n      (focused &&\r\n        ((!isOpen && !this.props.multiSelect && prevState.selectedIndices && selectedIndices && prevState.selectedIndices[0] !== selectedIndices[0]) ||\r\n          !allowFreeform || text !== prevProps.text || value !== prevProps.value)\r\n      ))) {\r\n      this._select();\r\n    }\r\n\r\n    this._notifyPendingValueChanged(prevState);\r\n\r\n    if (isOpen && !prevState.isOpen && onMenuOpen) {\r\n      onMenuOpen();\r\n    }\r\n\r\n    if (!isOpen && prevState.isOpen && onMenuDismissed) {\r\n      onMenuDismissed();\r\n    }\r\n  }\r\n\r\n  public componentWillUnmount(): void {\r\n    super.componentWillUnmount();\r\n\r\n    // remove the eventHanlder that was added in componentDidMount\r\n    this._events.off(this._comboBoxWrapper.current);\r\n  }\r\n\r\n  // Primary Render\r\n  public render(): JSX.Element {\r\n    const id = this._id;\r\n    const {\r\n      className,\r\n      label,\r\n      disabled,\r\n      ariaLabel,\r\n      required,\r\n      errorMessage,\r\n      onRenderContainer = this._onRenderContainer,\r\n      onRenderList = this._onRenderList,\r\n      onRenderItem = this._onRenderItem,\r\n      onRenderOption = this._onRenderOptionContent,\r\n      allowFreeform,\r\n      buttonIconProps,\r\n      isButtonAriaHidden = true,\r\n      styles: customStyles,\r\n      theme,\r\n      title,\r\n      keytipProps\r\n    } = this.props;\r\n    const { isOpen, focused, suggestedDisplayValue } = this.state;\r\n    this._currentVisibleValue = this._getVisibleValue();\r\n\r\n    const divProps = getNativeProps(this.props, divProperties);\r\n\r\n    const hasErrorMessage = (errorMessage && errorMessage.length > 0) ? true : false;\r\n\r\n    this._classNames = this.props.getClassNames ?\r\n      this.props.getClassNames(\r\n        theme!,\r\n        !!isOpen,\r\n        !!disabled,\r\n        !!required,\r\n        !!focused,\r\n        !!allowFreeform,\r\n        !!hasErrorMessage,\r\n        className) :\r\n      getClassNames(\r\n        getStyles(theme!, customStyles),\r\n        className!,\r\n        !!isOpen,\r\n        !!disabled,\r\n        !!required,\r\n        !!focused,\r\n        !!allowFreeform,\r\n        !!hasErrorMessage\r\n      );\r\n\r\n    const describedBy = id + '-option';\r\n\r\n    return (\r\n      <div { ...divProps } ref={ this._root } className={ this._classNames.container }>\r\n        { label && (\r\n          <Label id={ id + '-label' } disabled={ disabled } required={ required } htmlFor={ id + '-input' } className={ this._classNames.label }>{ label }</Label>\r\n        ) }\r\n        <KeytipData keytipProps={ keytipProps } disabled={ disabled }>\r\n          { (keytipAttributes: any): JSX.Element => (\r\n            <div\r\n              data-ktp-target={ keytipAttributes['data-ktp-target'] }\r\n              ref={ this._comboBoxWrapper }\r\n              id={ id + 'wrapper' }\r\n              className={ this._classNames.root }\r\n            >\r\n              <Autofill\r\n                data-ktp-execute-target={ keytipAttributes['data-ktp-execute-target'] }\r\n                data-is-interactable={ !disabled }\r\n                componentRef={ this._autofill }\r\n                id={ id + '-input' }\r\n                className={ this._classNames.input }\r\n                type='text'\r\n                onFocus={ this._select }\r\n                onBlur={ this._onBlur }\r\n                onKeyDown={ this._onInputKeyDown }\r\n                onKeyUp={ this._onInputKeyUp }\r\n                onClick={ this._onAutofillClick }\r\n                onTouchStart={ this._onTouchStart }\r\n                onInputValueChange={ this._onInputChange }\r\n                aria-expanded={ isOpen }\r\n                aria-autocomplete={ this._getAriaAutoCompleteValue() }\r\n                role='combobox'\r\n                aria-readonly={ ((allowFreeform || disabled) ? undefined : 'true') }\r\n                readOnly={ disabled || !allowFreeform }\r\n                aria-labelledby={ (label && (id + '-label')) }\r\n                aria-label={ ((ariaLabel && !label) ? ariaLabel : undefined) }\r\n                aria-describedby={ describedBy + (keytipAttributes['aria-describedby'] || '') }\r\n                aria-activedescendant={ this._getAriaActiveDescentValue() }\r\n                aria-disabled={ disabled }\r\n                aria-owns={ (id + '-list') }\r\n                spellCheck={ false }\r\n                defaultVisibleValue={ this._currentVisibleValue }\r\n                suggestedDisplayValue={ suggestedDisplayValue }\r\n                updateValueInWillReceiveProps={ this._onUpdateValueInAutofillWillReceiveProps }\r\n                shouldSelectFullInputValueInComponentDidUpdate={ this._onShouldSelectFullInputValueInAutofillComponentDidUpdate }\r\n                title={ title }\r\n              />\r\n              <IconButton\r\n                className={ 'ms-ComboBox-CaretDown-button' }\r\n                styles={ this._getCaretButtonStyles() }\r\n                role='presentation'\r\n                aria-hidden={ isButtonAriaHidden }\r\n                data-is-focusable={ false }\r\n                tabIndex={ -1 }\r\n                onClick={ this._onComboBoxClick }\r\n                iconProps={ buttonIconProps }\r\n                disabled={ disabled }\r\n                checked={ isOpen }\r\n              />\r\n            </div>\r\n          ) }\r\n        </KeytipData>\r\n        { isOpen && (\r\n          (onRenderContainer as any)({\r\n            ...this.props,\r\n            onRenderList,\r\n            onRenderItem,\r\n            onRenderOption,\r\n            options: this.state.currentOptions.map((item, index) => ({ ...item, index: index }))\r\n          },\r\n            this._onRenderContainer)\r\n        ) }\r\n        {\r\n          errorMessage &&\r\n          <div\r\n            className={ this._classNames.errorMessage }\r\n          >\r\n            { errorMessage }\r\n          </div>\r\n        }\r\n      </div>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set focus on the input\r\n   */\r\n  public focus = (shouldOpenOnFocus?: boolean): void => {\r\n    if (this._autofill.current) {\r\n      this._autofill.current.focus();\r\n      if (shouldOpenOnFocus) {\r\n        this.setState({\r\n          isOpen: true\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Close menu callout if it is open\r\n   */\r\n  public dismissMenu = (): void => {\r\n    const { isOpen } = this.state;\r\n    isOpen && this.setState({ isOpen: false });\r\n  }\r\n\r\n  /**\r\n   * componentWillReceiveProps handler for the auto fill component\r\n   * Checks/updates the iput value to set, if needed\r\n   * @param { IAutofillProps } defaultVisibleValue - the defaultVisibleValue that got passed\r\n   *  in to the auto fill's componentWillReceiveProps\r\n   * @returns { string } - the updated value to set, if needed\r\n   */\r\n  private _onUpdateValueInAutofillWillReceiveProps = (): string | null => {\r\n    const comboBox = this._autofill.current;\r\n\r\n    if (!comboBox) {\r\n      return null;\r\n    }\r\n\r\n    if (comboBox.value === null || comboBox.value === undefined) {\r\n      return null;\r\n    }\r\n\r\n    if (this._currentVisibleValue && this._currentVisibleValue !== '' && comboBox.value !== this._currentVisibleValue) {\r\n      return this._currentVisibleValue;\r\n    }\r\n\r\n    return comboBox.value;\r\n  }\r\n\r\n  /**\r\n   * componentDidUpdate handler for the auto fill component\r\n   *\r\n   * @param { string } defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\r\n   * @param { string } suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\r\n   * @returns { boolean } - should the full value of the input be selected?\r\n   * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\r\n   */\r\n  private _onShouldSelectFullInputValueInAutofillComponentDidUpdate = (): boolean => {\r\n    return this._currentVisibleValue === this.state.suggestedDisplayValue;\r\n  }\r\n\r\n  /**\r\n   * Get the correct value to pass to the input\r\n   * to show to the user based off of the current props and state\r\n   * @returns { string } the value to pass to the input\r\n   */\r\n  private _getVisibleValue = (): string | undefined => {\r\n    const {\r\n      text,\r\n      value,\r\n      allowFreeform,\r\n      autoComplete\r\n    } = this.props;\r\n    const {\r\n      selectedIndices,\r\n      currentPendingValueValidIndex,\r\n      currentOptions,\r\n      currentPendingValue,\r\n      suggestedDisplayValue,\r\n      isOpen,\r\n      focused\r\n    } = this.state;\r\n\r\n    const currentPendingIndexValid = this._indexWithinBounds(currentOptions, currentPendingValueValidIndex);\r\n\r\n    // If the user passed is a value prop, use that\r\n    // unless we are open and have a valid current pending index\r\n    if (!(isOpen && currentPendingIndexValid) && (text && !currentPendingValue)) {\r\n      return text;\r\n    }\r\n\r\n    if (!(isOpen && currentPendingIndexValid) && (value && !currentPendingValue)) {\r\n      return value;\r\n    }\r\n\r\n    // Values to display in the BaseAutoFill area\r\n    const displayValues = [];\r\n\r\n    if (this.props.multiSelect) {\r\n      // MUlti-select\r\n      if (focused) {\r\n        let index = -1;\r\n        if (autoComplete === 'on' && currentPendingIndexValid) {\r\n          index = currentPendingValueValidIndex;\r\n        }\r\n        displayValues.push(currentPendingValue !== '' ? currentPendingValue : (this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : ''));\r\n      } else {\r\n        for (let idx = 0; selectedIndices && (idx < selectedIndices.length); idx++) {\r\n          const index: number = selectedIndices[idx];\r\n          displayValues.push(this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : suggestedDisplayValue);\r\n        }\r\n      }\r\n    } else {\r\n      // Single-select\r\n      let index: number = this._getFirstSelectedIndex();\r\n      if (allowFreeform) {\r\n        // If we are allowing freeform and autocomplete is also true\r\n        // and we've got a pending value that matches an option, remember\r\n        // the matched option's index\r\n        if (autoComplete === 'on' && currentPendingIndexValid) {\r\n          index = currentPendingValueValidIndex;\r\n        }\r\n\r\n        // Since we are allowing freeform, if there is currently a nonempty pending value, use that\r\n        // otherwise use the index determined above (falling back to '' if we did not get a valid index)\r\n        displayValues.push(currentPendingValue !== '' ? currentPendingValue : (this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : ''));\r\n      } else {\r\n        // If we are not allowing freeform and have a\r\n        // valid index that matches the pending value,\r\n        // we know we will need some version of the pending value\r\n        if (currentPendingIndexValid && autoComplete === 'on') {\r\n          // If autoComplete is on, return the\r\n          // raw pending value, otherwise remember\r\n          // the matched option's index\r\n          index = currentPendingValueValidIndex;\r\n          displayValues.push(currentPendingValue);\r\n        } else {\r\n          displayValues.push(this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : suggestedDisplayValue);\r\n        }\r\n      }\r\n    }\r\n\r\n    // If we have a valid index then return the text value of that option,\r\n    // otherwise return the suggestedDisplayValue\r\n    let displayString = '';\r\n    for (let idx = 0; idx < displayValues.length; idx++) {\r\n      if (idx > 0) {\r\n        displayString += ', ';\r\n      }\r\n      displayString += displayValues[idx];\r\n    }\r\n    return displayString;\r\n  }\r\n\r\n  /**\r\n   * Is the index within the bounds of the array?\r\n   * @param options - options to check if the index is valid for\r\n   * @param index - the index to check\r\n     * @returns { boolean } - true if the index is valid for the given options, false otherwise\r\n          */\r\n  private _indexWithinBounds(options: IComboBoxOption[] | undefined, index: number): boolean {\r\n    if (!options) {\r\n      return false;\r\n    }\r\n    return index >= 0 && index < options.length;\r\n  }\r\n\r\n  /**\r\n   * Handler for typing changes on the input\r\n   * @param updatedValue - the newly changed value\r\n   */\r\n  private _onInputChange = (updatedValue: string): void => {\r\n    if (this.props.disabled) {\r\n      this._handleInputWhenDisabled(null /* event */);\r\n      return;\r\n    }\r\n\r\n    this.props.allowFreeform ?\r\n      this._processInputChangeWithFreeform(updatedValue) :\r\n      this._processInputChangeWithoutFreeform(updatedValue);\r\n  }\r\n\r\n  /**\r\n   * Process the new input's new value when the comboBox\r\n   * allows freeform entry\r\n   * @param updatedValue - the input's newly changed value\r\n   */\r\n  private _processInputChangeWithFreeform(updatedValue: string): void {\r\n    const {\r\n      currentOptions\r\n    } = this.state;\r\n\r\n    // if the new value is empty, nothing needs to be done\r\n    if (updatedValue === '') {\r\n      return;\r\n    }\r\n\r\n    // Remember the original value and then,\r\n    // make the value lowercase for comparison\r\n    const originalUpdatedValue: string = updatedValue;\r\n    updatedValue = updatedValue.toLocaleLowerCase();\r\n\r\n    let newSuggestedDisplayValue = '';\r\n    let newCurrentPendingValueValidIndex = -1;\r\n\r\n    // If autoComplete is on, attempt to find a match from the available options\r\n    if (this.props.autoComplete === 'on') {\r\n\r\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\r\n      const items = currentOptions.map((item, index) => { return { ...item, index }; })\r\n        .filter((option) => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider)\r\n        .filter((option) => this._getPreviewText(option).toLocaleLowerCase().indexOf(updatedValue) === 0);\r\n      if (items.length > 0) {\r\n        // use ariaLabel as the value when the option is set\r\n        const text: string = this._getPreviewText(items[0]);\r\n\r\n        // If the user typed out the complete option text, we don't need any suggested display text anymore\r\n        newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : '';\r\n\r\n        // remember the index of the match we found\r\n        newCurrentPendingValueValidIndex = items[0].index;\r\n      }\r\n    } else {\r\n\r\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\r\n      const items = currentOptions.map((item, index) => { return { ...item, index }; })\r\n        .filter((option) => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider)\r\n        .filter((option) => this._getPreviewText(option).toLocaleLowerCase() === updatedValue);\r\n\r\n      // if we fould a match remember the index\r\n      if (items.length === 1) {\r\n        newCurrentPendingValueValidIndex = items[0].index;\r\n      }\r\n    }\r\n\r\n    // Set the updated state\r\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\r\n  }\r\n\r\n  /**\r\n   * Process the new input's new value when the comboBox\r\n   * does not allow freeform entry\r\n   * @param updatedValue - the input's newly changed value\r\n   */\r\n  private _processInputChangeWithoutFreeform(updatedValue: string): void {\r\n    const {\r\n      currentPendingValue,\r\n      currentPendingValueValidIndex,\r\n      currentOptions,\r\n    } = this.state;\r\n\r\n    if (this.props.autoComplete === 'on') {\r\n\r\n      // If autoComplete is on while allow freeform is off,\r\n      // we will remember the keypresses and build up a string to attempt to match\r\n      // as long as characters are typed within a the timeout span of each other,\r\n      // otherwise we will clear the string and start building a new one on the next keypress.\r\n      // Also, only do this processing if we have a non-empty value\r\n      if (updatedValue !== '') {\r\n\r\n        // If we have a pending autocomplete clearing task,\r\n        // we know that the user is typing with keypresses happening\r\n        // within the timeout of each other so remove the clearing task\r\n        // and continue building the pending value with the udpated value\r\n        if (this._lastReadOnlyAutoCompleteChangeTimeoutId !== undefined) {\r\n          this._async.clearTimeout(this._lastReadOnlyAutoCompleteChangeTimeoutId);\r\n          this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\r\n          updatedValue = currentPendingValue + updatedValue;\r\n        }\r\n\r\n        const originalUpdatedValue: string = updatedValue;\r\n        updatedValue = updatedValue.toLocaleLowerCase();\r\n\r\n        // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\r\n        const items = currentOptions.map((item, i) => { return { ...item, index: i }; })\r\n          .filter((option) => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider)\r\n          .filter((option) => option.text.toLocaleLowerCase().indexOf(updatedValue) === 0);\r\n\r\n        // If we found a match, udpdate the state\r\n        if (items.length > 0) {\r\n          this._setPendingInfo(originalUpdatedValue, items[0].index, this._getPreviewText(items[0]));\r\n        }\r\n\r\n        // Schedule a timeout to clear the pending value after the timeout span\r\n        this._lastReadOnlyAutoCompleteChangeTimeoutId =\r\n          this._async.setTimeout(\r\n            () => { this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined; },\r\n            ReadOnlyPendingAutoCompleteTimeout\r\n          );\r\n        return;\r\n      }\r\n    }\r\n\r\n    // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\r\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\r\n    // use that; otherwise use the selectedIndex\r\n    const index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();\r\n\r\n    // Since we are not allowing freeform, we need to\r\n    // set both the pending and suggested values/index\r\n    // to allow us to select all content in the input to\r\n    // give the illusion that we are readonly (e.g. freeform off)\r\n    this._setPendingInfoFromIndex(index);\r\n  }\r\n\r\n  private _getFirstSelectedIndex(): number {\r\n    return (this.state.selectedIndices && this.state.selectedIndices.length > 0) ? this.state.selectedIndices[0] : -1;\r\n  }\r\n\r\n  /**\r\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\r\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\r\n   * @param index - the index to get the next selectable index from\r\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\r\n   * @returns { number } - the next valid selectable index. If the new index is outside of the bounds,\r\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\r\n   */\r\n  private _getNextSelectableIndex(index: number, searchDirection: SearchDirection): number {\r\n    const { currentOptions } = this.state;\r\n\r\n    let newIndex = index + searchDirection;\r\n\r\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\r\n\r\n    if (!this._indexWithinBounds(currentOptions, newIndex)) {\r\n      return -1;\r\n    }\r\n\r\n    const option: IComboBoxOption = currentOptions[newIndex];\r\n\r\n    // attempt to skip headers and dividers\r\n    if ((option.itemType === SelectableOptionMenuItemType.Header ||\r\n      option.itemType === SelectableOptionMenuItemType.Divider)) {\r\n\r\n      // Should we continue looking for an index to select?\r\n      if (searchDirection !== SearchDirection.none &&\r\n        ((newIndex > 0 && searchDirection < SearchDirection.none) ||\r\n          (newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none))) {\r\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\r\n      } else {\r\n        // If we cannot perform a useful search just return the index we were given\r\n        return index;\r\n      }\r\n    }\r\n\r\n    // We have the next valid selectable index, return it\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Set the selected index. Note, this is\r\n   * the \"real\" selected index, not the pending selected index\r\n   * @param index - the index to set (or the index to set from if a search direction is provided)\r\n   * @param searchDirection - the direction to search along the options from the given index\r\n   */\r\n  private _setSelectedIndex(index: number, submitPendingValueEvent: any, searchDirection: SearchDirection = SearchDirection.none): void {\r\n    const { onChanged, onPendingValueChanged } = this.props;\r\n    const { currentOptions } = this.state;\r\n    let { selectedIndices } = this.state;\r\n\r\n    if (!selectedIndices) {\r\n      selectedIndices = [];\r\n    }\r\n\r\n    // Find the next selectable index, if searchDirection is none\r\n    // we will get our starting index back\r\n    index = this._getNextSelectableIndex(index, searchDirection);\r\n\r\n    if (!this._indexWithinBounds(currentOptions, index)) {\r\n      return;\r\n    }\r\n\r\n    // Are we at a new index? If so, update the state, otherwise\r\n    // there is nothing to do\r\n    if (this.props.multiSelect || selectedIndices.length < 1 || (selectedIndices.length === 1 && selectedIndices[0] !== index)) {\r\n      const option: IComboBoxOption = currentOptions[index];\r\n      if (!option) {\r\n        return;\r\n      }\r\n      if (this.props.multiSelect) {\r\n        // Setting the initial state of option.selected in Multi-select combobox by checking the selectedIndices array and overriding the undefined issue\r\n        option.selected = option.selected !== undefined ? !option.selected : (selectedIndices.indexOf(index) < 0);\r\n        if (option.selected && selectedIndices.indexOf(index) < 0) {\r\n          selectedIndices.push(index);\r\n        } else if (!option.selected && selectedIndices.indexOf(index) >= 0) {\r\n          selectedIndices = selectedIndices.filter((value: number) => value !== index);\r\n        }\r\n      } else {\r\n        selectedIndices[0] = index;\r\n      }\r\n\r\n      // Set the selected option\r\n      this.setState({\r\n        selectedIndices: selectedIndices\r\n      });\r\n\r\n      // If ComboBox value is changed, revert preview first\r\n      if (this._hasPendingValue && onPendingValueChanged) {\r\n        onPendingValueChanged();\r\n        this._hasPendingValue = false;\r\n      }\r\n\r\n      // Did the creator give us an onChanged callback?\r\n      if (onChanged) {\r\n        onChanged(option, index, undefined, submitPendingValueEvent);\r\n      }\r\n\r\n      // if we have a new selected index,\r\n      // clear all of the pending info\r\n      this._clearPendingInfo();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Focus (and select) the content of the input\r\n   * and set the focused state\r\n   */\r\n  private _select = (): void => {\r\n    if (this._autofill.current && this._autofill.current.inputElement) {\r\n      this._autofill.current.inputElement.select();\r\n    }\r\n\r\n    if (!this.state.focused) {\r\n      this.setState({ focused: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback issued when the options should be resolved, if they have been updated or\r\n   * if they need to be passed in the first time. This only does work if an onResolveOptions\r\n   * callback was passed in\r\n   */\r\n  private _onResolveOptions = (): void => {\r\n    if (this.props.onResolveOptions) {\r\n\r\n      // get the options\r\n      const newOptions = this.props.onResolveOptions({ ...this.state.currentOptions });\r\n\r\n      // Check to see if the returned value is an array, if it is update the state\r\n      // If the returned value is not an array then check to see if it's a promise or PromiseLike. If it is then resolve it asynchronously.\r\n      if (Array.isArray(newOptions)) {\r\n        this.setState({\r\n          currentOptions: newOptions\r\n        });\r\n      } else if (newOptions && newOptions.then) {\r\n\r\n        // Ensure that the promise will only use the callback if it was the most recent one\r\n        // and update the state when the promise returns\r\n        const promise: PromiseLike<IComboBoxOption[]> = this._currentPromise = newOptions;\r\n        promise.then((newOptionsFromPromise: IComboBoxOption[]) => {\r\n          if (promise === this._currentPromise) {\r\n            this.setState({\r\n              currentOptions: newOptionsFromPromise\r\n            });\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * OnBlur handler. Set the focused state to false\r\n   * and submit any pending value\r\n   */\r\n  private _onBlur = (event: React.FocusEvent<HTMLInputElement>): void => {\r\n\r\n    // Do nothing if the blur is coming from something\r\n    // inside the comboBox root or the comboBox menu since\r\n    // it we are not really bluring from the whole comboBox\r\n    if (event.relatedTarget &&\r\n      (this._root.current && this._root.current.contains(event.relatedTarget as HTMLElement) ||\r\n        this._comboBoxMenu.current && this._comboBoxMenu.current.contains(event.relatedTarget as HTMLElement))) {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n      return;\r\n    }\r\n\r\n    if (this.state.focused) {\r\n      this.setState({ focused: false });\r\n      if (!this.props.multiSelect) {\r\n        this._submitPendingValue(event);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Submit a pending value if there is one\r\n   */\r\n  private _submitPendingValue(submitPendingValueEvent: any): void {\r\n    const {\r\n      onChanged,\r\n      allowFreeform,\r\n      autoComplete\r\n    } = this.props;\r\n    const {\r\n      currentPendingValue,\r\n      currentPendingValueValidIndex,\r\n      currentOptions,\r\n      currentPendingValueValidIndexOnHover\r\n    } = this.state;\r\n    let { selectedIndices } = this.state;\r\n\r\n    // If we allow freeform and we have a pending value, we\r\n    // need to handle that\r\n    if (allowFreeform && currentPendingValue !== '') {\r\n\r\n      // Check to see if the user typed an exact match\r\n      if (this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\r\n        const pendingOptionText: string = currentOptions[currentPendingValueValidIndex].text.toLocaleLowerCase();\r\n\r\n        // By exact match, that means: our pending value is the same as the the pending option text OR\r\n        // the pending option starts with the pending value and we have an \"autoComplete\" selection\r\n        // where the total length is equal to pending option length OR\r\n        // the live value in the underlying input matches the pending option; update the state\r\n        if (currentPendingValue.toLocaleLowerCase() === pendingOptionText ||\r\n          (autoComplete && pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 &&\r\n            (this._autofill.current && this._autofill.current.isValueSelected &&\r\n              currentPendingValue.length + (this._autofill.current.selectionEnd! - this._autofill.current.selectionStart!) === pendingOptionText.length) ||\r\n            (this._autofill.current && this._autofill.current.inputElement && this._autofill.current.inputElement.value.toLocaleLowerCase() === pendingOptionText)\r\n          )) {\r\n          this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\r\n          this._clearPendingInfo();\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (onChanged) {\r\n        onChanged(undefined, undefined, currentPendingValue, submitPendingValueEvent);\r\n      } else {\r\n        // If we are not controlled, create a new option\r\n        const newOption: IComboBoxOption = { key: currentPendingValue, text: currentPendingValue };\r\n        const newOptions: IComboBoxOption[] = [...currentOptions, newOption];\r\n        if (selectedIndices) {\r\n          if (!this.props.multiSelect) {\r\n            selectedIndices = [];\r\n          }\r\n          selectedIndices.push(newOptions.length - 1);\r\n        }\r\n        this.setState({\r\n          currentOptions: newOptions,\r\n          selectedIndices: selectedIndices\r\n        });\r\n      }\r\n    } else if (currentPendingValueValidIndex >= 0) {\r\n      // Since we are not allowing freeform, we must have a matching\r\n      // to be able to update state\r\n      this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\r\n    } else if (currentPendingValueValidIndexOnHover >= 0) {\r\n      // If all else failed and we were hovering over an item, select it\r\n      this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent, );\r\n    }\r\n\r\n    // Finally, clear the pending info\r\n    this._clearPendingInfo();\r\n  }\r\n\r\n  // Render Callout container and pass in list\r\n  private _onRenderContainer = (props: IComboBoxProps): JSX.Element => {\r\n    const {\r\n      onRenderList,\r\n      calloutProps,\r\n      dropdownWidth,\r\n      onRenderLowerContent = this._onRenderLowerContent,\r\n      useComboBoxAsMenuWidth\r\n    } = props;\r\n\r\n    return (\r\n      <Callout\r\n        isBeakVisible={ false }\r\n        gapSpace={ 0 }\r\n        doNotLayer={ false }\r\n        directionalHint={ DirectionalHint.bottomLeftEdge }\r\n        directionalHintFixed={ true }\r\n        { ...calloutProps }\r\n        className={ css(this._classNames.callout, calloutProps ? calloutProps.className : undefined) }\r\n        target={ this._comboBoxWrapper.current }\r\n        onDismiss={ this._onDismiss }\r\n        onScroll={ this._onScroll }\r\n        setInitialFocus={ false }\r\n        calloutWidth={\r\n          useComboBoxAsMenuWidth && this._comboBoxWrapper.current ?\r\n            this._comboBoxWrapper.current.clientWidth + 2\r\n            : dropdownWidth }\r\n      >\r\n        <div className={ this._classNames.optionsContainerWrapper } ref={ this._comboBoxMenu }>\r\n          { (onRenderList as any)({ ...props }, this._onRenderList) }\r\n        </div>\r\n        { onRenderLowerContent(this.props, this._onRenderLowerContent) }\r\n      </Callout>\r\n    );\r\n  }\r\n\r\n  // Render List of items\r\n  private _onRenderList = (props: IComboBoxProps): JSX.Element => {\r\n    const {\r\n      onRenderItem,\r\n      options\r\n    } = props;\r\n\r\n    const id = this._id;\r\n    return (\r\n      <div\r\n        id={ id + '-list' }\r\n        className={ this._classNames.optionsContainer }\r\n        aria-labelledby={ id + '-label' }\r\n        role='listbox'\r\n      >\r\n        { options.map((item) => (onRenderItem as any)(item, this._onRenderItem)) }\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Render items\r\n  private _onRenderItem = (item: IComboBoxOption): JSX.Element | null => {\r\n    switch (item.itemType) {\r\n      case SelectableOptionMenuItemType.Divider:\r\n        return this._renderSeparator(item);\r\n      case SelectableOptionMenuItemType.Header:\r\n        return this._renderHeader(item);\r\n      default:\r\n        return this._renderOption(item);\r\n    }\r\n  }\r\n\r\n  // Default _onRenderLowerContent function returns nothing\r\n  private _onRenderLowerContent = (): null => {\r\n    return null;\r\n  }\r\n\r\n  // Render separator\r\n  private _renderSeparator(item: IComboBoxOption): JSX.Element | null {\r\n    const { index, key } = item;\r\n\r\n    if (index && index > 0) {\r\n      return (\r\n        <div\r\n          role='separator'\r\n          key={ key }\r\n          className={ this._classNames.divider }\r\n        />\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private _renderHeader(item: IComboBoxOption): JSX.Element {\r\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\r\n\r\n    return (\r\n      <div key={ item.key } className={ this._classNames.header } role='heading'>\r\n        { onRenderOption(item, this._onRenderOptionContent) }\r\n      </div>);\r\n  }\r\n\r\n  private _renderOption = (item: IComboBoxOption): JSX.Element => {\r\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\r\n    const id = this._id;\r\n    const isSelected: boolean = this._isOptionSelected(item.index);\r\n    const getOptionComponent = () => {\r\n      return (\r\n        !this.props.multiSelect ? (\r\n          <CommandButton\r\n            id={ id + '-list' + item.index }\r\n            key={ item.key }\r\n            data-index={ item.index }\r\n            styles={ this._getCurrentOptionStyles(item) }\r\n            checked={ isSelected }\r\n            className={ 'ms-ComboBox-option' }\r\n            onClick={ this._onItemClick(item.index) }\r\n            onMouseEnter={ this._onOptionMouseEnter.bind(this, item.index) }\r\n            onMouseMove={ this._onOptionMouseMove.bind(this, item.index) }\r\n            onMouseLeave={ this._onOptionMouseLeave }\r\n            role='option'\r\n            aria-selected={ isSelected ? 'true' : 'false' }\r\n            ariaLabel={ this._getPreviewText(item) }\r\n            disabled={ item.disabled }\r\n          > { <span ref={ isSelected ? this._selectedElement : undefined }>\r\n            { onRenderOption(item, this._onRenderOptionContent) }\r\n          </span>\r\n            }\r\n          </CommandButton>\r\n        ) : (\r\n            <Checkbox\r\n              id={ id + '-list' + item.index }\r\n              ref={ 'option' + item.index }\r\n              ariaLabel={ this._getPreviewText(item) }\r\n              key={ item.key }\r\n              data-index={ item.index }\r\n              styles={ this._getCurrentOptionStyles(item) }\r\n              className={ 'ms-ComboBox-option' }\r\n              data-is-focusable={ true }\r\n              onChange={ this._onItemClick(item.index!) }\r\n              label={ item.text }\r\n              role='option'\r\n              aria-selected={ isSelected ? 'true' : 'false' }\r\n              checked={ isSelected }\r\n            >\r\n              { onRenderOption(item, this._onRenderOptionContent) }\r\n            </Checkbox>\r\n          )\r\n      );\r\n    };\r\n\r\n    return (\r\n      <ComboBoxOptionWrapper\r\n        key={ item.key }\r\n        index={ item.index }\r\n        disabled={ item.disabled }\r\n        isSelected={ isSelected }\r\n        text={ item.text }\r\n        render={ getOptionComponent }\r\n      />\r\n    );\r\n  }\r\n\r\n  /**\r\n   * If we are coming from a mouseOut:\r\n   * there is no visible selected option.\r\n   *\r\n   * Else if We are hovering over an item:\r\n   * that gets the selected look.\r\n   *\r\n   * Else:\r\n   * Use the current valid pending index if it exists OR\r\n   * we do not have a valid index and we currently have a pending input value,\r\n   * otherwise use the selected index\r\n   * */\r\n  private _isOptionSelected(index: number | undefined): boolean {\r\n    const {\r\n      currentPendingValueValidIndexOnHover\r\n    } = this.state;\r\n\r\n    // If the hover state is set to clearAll, don't show a selected index.\r\n    // Note, this happens when the user moused out of the menu items\r\n    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.props.multiSelect && this._getPendingSelectedIndex(true /* includePendingValue */) === index) {\r\n      return true;\r\n    }\r\n\r\n    let idxOfSelectedIndex = -1;\r\n    if (this.props.multiSelect && (index !== undefined) && this.state.selectedIndices) {\r\n      idxOfSelectedIndex = this.state.selectedIndices.indexOf(index);\r\n    }\r\n    return (idxOfSelectedIndex >= 0);\r\n  }\r\n\r\n  /**\r\n   * Gets the pending selected index taking into account hover, valueValidIndex, and selectedIndex\r\n   * @param includeCurrentPendingValue - Should we include the currentPendingValue when\r\n   * finding the index\r\n   */\r\n  private _getPendingSelectedIndex(includeCurrentPendingValue: boolean): number {\r\n    const {\r\n      currentPendingValueValidIndexOnHover,\r\n      currentPendingValueValidIndex,\r\n      currentPendingValue,\r\n    } = this.state;\r\n\r\n    return (\r\n      currentPendingValueValidIndexOnHover >= 0 ?\r\n        currentPendingValueValidIndexOnHover :\r\n        (currentPendingValueValidIndex >= 0 || (includeCurrentPendingValue && currentPendingValue !== '')) ?\r\n          currentPendingValueValidIndex :\r\n          this.props.multiSelect ? 0 : this._getFirstSelectedIndex()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Scroll handler for the callout to make sure the mouse events\r\n   * for updating focus are not interacting during scroll\r\n   */\r\n  private _onScroll = () => {\r\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\r\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\r\n      this._scrollIdleTimeoutId = undefined;\r\n    } else {\r\n      this._isScrollIdle = false;\r\n    }\r\n\r\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => { this._isScrollIdle = true; }, ScrollIdleDelay);\r\n  }\r\n\r\n  /**\r\n   * Scroll the selected element into view\r\n   */\r\n  private _scrollIntoView(): void {\r\n    const {\r\n      onScrollToItem,\r\n      scrollSelectedToTop\r\n    } = this.props;\r\n\r\n    const {\r\n      currentPendingValueValidIndex,\r\n      currentPendingValue,\r\n    } = this.state;\r\n\r\n    if (onScrollToItem) {\r\n      // Use the custom scroll handler\r\n      onScrollToItem((currentPendingValueValidIndex >= 0 || currentPendingValue !== '') ? currentPendingValueValidIndex : this._getFirstSelectedIndex());\r\n    } else if (this._selectedElement.current && this._selectedElement.current.offsetParent) {\r\n      // We are using refs, scroll the ref into view\r\n      if (scrollSelectedToTop) {\r\n        this._selectedElement.current.offsetParent.scrollIntoView(true);\r\n      } else {\r\n        let alignToTop = true;\r\n\r\n        if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\r\n          const scrollableParentRect = this._comboBoxMenu.current.offsetParent.getBoundingClientRect();\r\n          const selectedElementRect = this._selectedElement.current.offsetParent.getBoundingClientRect();\r\n\r\n          // If we are completely in view then we do not need to scroll\r\n          if (scrollableParentRect.top <= selectedElementRect.top &&\r\n            scrollableParentRect.top + scrollableParentRect.height >= selectedElementRect.top + selectedElementRect.height) {\r\n            return;\r\n          }\r\n\r\n          // If we are lower than the scrollable parent viewport then we should align to the bottom\r\n          if (scrollableParentRect.top + scrollableParentRect.height <= selectedElementRect.top + selectedElementRect.height) {\r\n            alignToTop = false;\r\n          }\r\n        }\r\n\r\n        this._selectedElement.current.offsetParent.scrollIntoView(alignToTop);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _onRenderOptionContent = (item: IComboBoxOption): JSX.Element => {\r\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\r\n    return <span className={ optionClassNames.optionText }>{ item.text }</span>;\r\n  }\r\n\r\n  /**\r\n   * Click handler for the menu items\r\n   * to select the item and also close the menu\r\n   * @param index - the index of the item that was clicked\r\n   */\r\n  private _onItemClick(index: number | undefined): (ev: any) => void {\r\n    return (ev: any): void => {\r\n      this._setSelectedIndex(index as number, ev);\r\n      if (!this.props.multiSelect) {\r\n        // only close the callout when it's in single-select mode\r\n        this.setState({\r\n          isOpen: false\r\n        });\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handles dismissing (cancelling) the menu\r\n   */\r\n  private _onDismiss = (): void => {\r\n\r\n    // reset the selected index\r\n    // to the last valud state\r\n    this._resetSelectedIndex();\r\n\r\n    // close the menu and focus the input\r\n    this.setState({ isOpen: false });\r\n\r\n    if (this._autofill.current && this._focusInputAfterClose) {\r\n      this._autofill.current.focus();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the index of the option that is marked as selected\r\n   * @param options - the comboBox options\r\n   * @param selectedKeys - the known selected key to find\r\n   * @returns { number } - the index of the selected option, -1 if not found\r\n   */\r\n  private _getSelectedIndices(options: IComboBoxOption[] | undefined, selectedKeys: (string | number | undefined)[]): number[] {\r\n    const selectedIndices: any[] = [];\r\n    if (options === undefined || selectedKeys === undefined) {\r\n      return selectedIndices;\r\n    }\r\n\r\n    for (const selectedKey of selectedKeys) {\r\n      const index = findIndex(options, (option => (option.selected || option.key === selectedKey)));\r\n      if (index > -1) {\r\n        selectedIndices.push(index);\r\n      }\r\n    }\r\n    return selectedIndices;\r\n  }\r\n\r\n  /**\r\n   * Reset the selected index by clearing the\r\n   * input (of any pending text), clearing the pending state,\r\n   * and setting the suggested display value to the last\r\n   * selected state text\r\n   */\r\n  private _resetSelectedIndex(): void {\r\n    const {\r\n      currentOptions\r\n    } = this.state;\r\n    if (this._autofill.current) {\r\n      this._autofill.current.clear();\r\n    }\r\n    this._clearPendingInfo();\r\n\r\n    const selectedIndex: number = this._getFirstSelectedIndex();\r\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\r\n      this.setState({\r\n        suggestedDisplayValue: currentOptions[selectedIndex].text\r\n      });\r\n    } else if (this.props.text || this.props.value) {\r\n      // If we had a value initially, restore it\r\n      this.setState({\r\n        suggestedDisplayValue: this.props.text || this.props.value\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the pending info state\r\n   */\r\n  private _clearPendingInfo(): void {\r\n    this._setPendingInfo('' /* suggestedDisplayValue */, -1 /* currentPendingValueValidIndex */, '' /* currentPendingValue */);\r\n  }\r\n\r\n  /**\r\n   * Set the pending info\r\n   * @param currentPendingValue - new pending value to set\r\n   * @param currentPendingValueValidIndex - new pending value index to set\r\n   * @param suggestedDisplayValue - new suggest display value to set\r\n   */\r\n  private _setPendingInfo(currentPendingValue: string, currentPendingValueValidIndex: number, suggestedDisplayValue: string): void {\r\n    this.setState({\r\n      currentPendingValue: currentPendingValue,\r\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\r\n      suggestedDisplayValue: suggestedDisplayValue,\r\n      currentPendingValueValidIndexOnHover: HoverStatus.default\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set the pending info from the given index\r\n   * @param index - the index to set the pending info from\r\n   */\r\n  private _setPendingInfoFromIndex(index: number): void {\r\n    const {\r\n      currentOptions\r\n    } = this.state;\r\n\r\n    if (index >= 0 && index < currentOptions.length) {\r\n      const option = currentOptions[index];\r\n      this._setPendingInfo(this._getPreviewText(option), index, this._getPreviewText(option));\r\n    } else {\r\n      this._clearPendingInfo();\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Sets the pending info for the comboBox\r\n   * @param index - the index to search from\r\n   * @param searchDirection - the direction to search\r\n   */\r\n  private _setPendingInfoFromIndexAndDirection(index: number, searchDirection: SearchDirection): void {\r\n    const {\r\n      currentOptions\r\n    } = this.state;\r\n\r\n    // update index to allow content to wrap\r\n    if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\r\n      index = -1;\r\n    } else if (searchDirection === SearchDirection.backward && index <= 0) {\r\n      index = currentOptions.length;\r\n    }\r\n\r\n    // get the next \"valid\" index\r\n    const indexUpdate = this._getNextSelectableIndex(index, searchDirection);\r\n\r\n    // if the two indicies are equal we didn't move and\r\n    // we should attempt to get  get the first/last \"valid\" index to use\r\n    // (Note, this takes care of the potential cases where the first/last\r\n    // item is not focusable), otherwise use the updated index\r\n    if (index === indexUpdate) {\r\n      if (searchDirection === SearchDirection.forward) {\r\n        index = this._getNextSelectableIndex(-1, searchDirection);\r\n      } else if (searchDirection === SearchDirection.backward) {\r\n        index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\r\n      }\r\n    } else {\r\n      index = indexUpdate;\r\n    }\r\n\r\n    if (this._indexWithinBounds(currentOptions, index)) {\r\n      this._setPendingInfoFromIndex(index);\r\n    }\r\n  }\r\n\r\n  private _notifyPendingValueChanged(prevState: IComboBoxState): void {\r\n    const { onPendingValueChanged } = this.props;\r\n\r\n    if (!onPendingValueChanged) {\r\n      return;\r\n    }\r\n\r\n    const {\r\n      currentPendingValue,\r\n      currentOptions,\r\n      currentPendingValueValidIndex,\r\n      currentPendingValueValidIndexOnHover\r\n    } = this.state;\r\n\r\n    let newPendingIndex: number | undefined = undefined;\r\n    let newPendingValue: string | undefined = undefined;\r\n\r\n    if (currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover && this._indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)) {\r\n      // Set new pending index if hover index was changed\r\n      newPendingIndex = currentPendingValueValidIndexOnHover;\r\n    } else if (currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex && this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\r\n      // Set new pending index if currentPendingValueValidIndex was changed\r\n      newPendingIndex = currentPendingValueValidIndex;\r\n    } else if (currentPendingValue !== prevState.currentPendingValue && currentPendingValue !== '') {\r\n      // Set pendingValue in the case it was changed and no index was changed\r\n      newPendingValue = currentPendingValue;\r\n    }\r\n\r\n    // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\r\n    if (newPendingIndex !== undefined || newPendingValue || this._hasPendingValue) {\r\n      onPendingValueChanged(newPendingIndex ? currentOptions[newPendingIndex] : undefined, newPendingIndex, newPendingValue);\r\n      this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the isOpen state and updates focusInputAfterClose\r\n   */\r\n  private _setOpenStateAndFocusOnClose(isOpen: boolean, focusInputAfterClose: boolean): void {\r\n    this._focusInputAfterClose = focusInputAfterClose;\r\n    this.setState({\r\n      isOpen: isOpen\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle keydown on the input\r\n   * @param ev - The keyboard event that was fired\r\n   */\r\n  private _onInputKeyDown = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\r\n    const {\r\n      disabled,\r\n      allowFreeform,\r\n      autoComplete\r\n    } = this.props;\r\n    const {\r\n      isOpen,\r\n      currentOptions,\r\n      currentPendingValueValidIndexOnHover\r\n    } = this.state;\r\n\r\n    if (disabled) {\r\n      this._handleInputWhenDisabled(ev);\r\n      return;\r\n    }\r\n\r\n    let index = this._getPendingSelectedIndex(false /* includeCurrentPendingValue */);\r\n\r\n    switch (ev.which) {\r\n      case KeyCodes.enter:\r\n        this._submitPendingValue(ev);\r\n        if (this.props.multiSelect && isOpen) {\r\n          this.setState({\r\n            currentPendingValueValidIndex: index\r\n          });\r\n        } else {\r\n          // On enter submit the pending value\r\n          if ((isOpen ||\r\n            ((!allowFreeform ||\r\n              this.state.currentPendingValue === undefined ||\r\n              this.state.currentPendingValue === null ||\r\n              this.state.currentPendingValue.length <= 0) &&\r\n              this.state.currentPendingValueValidIndex < 0))) {\r\n            // if we are open or\r\n            // if we are not allowing freeform or\r\n            // our we have no pending value\r\n            // and no valid pending index\r\n            // flip the open state\r\n            this.setState({\r\n              isOpen: !isOpen\r\n            });\r\n          }\r\n        }\r\n        break;\r\n\r\n      case KeyCodes.tab:\r\n        // On enter submit the pending value\r\n        if (!this.props.multiSelect) {\r\n          this._submitPendingValue(ev);\r\n        }\r\n\r\n        // If we are not allowing freeform\r\n        // or the comboBox is open, flip the open state\r\n        if (isOpen) {\r\n          this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\r\n        }\r\n\r\n        // Allow TAB to propigate\r\n        return;\r\n\r\n      case KeyCodes.escape:\r\n        // reset the selected index\r\n        this._resetSelectedIndex();\r\n\r\n        // Close the menu if opened\r\n        if (isOpen) {\r\n          this.setState({\r\n            isOpen: false\r\n          });\r\n        } else {\r\n          return;\r\n        }\r\n        break;\r\n\r\n      case KeyCodes.up:\r\n        // if we are in clearAll state (e.g. the user as hovering\r\n        // and has since mousedOut of the menu items),\r\n        // go to the last index\r\n        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\r\n          index = this.state.currentOptions.length;\r\n        }\r\n\r\n        if ((ev.altKey || ev.metaKey) && isOpen) {\r\n          this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\r\n          return;\r\n        }\r\n\r\n        // Go to the previous option\r\n        this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\r\n        break;\r\n\r\n      case KeyCodes.down:\r\n        // Expand the comboBox on ALT + DownArrow\r\n        if (ev.altKey || ev.metaKey) {\r\n          this._setOpenStateAndFocusOnClose(true /* isOpen */, true /* focusInputAfterClose */);\r\n        } else {\r\n          // if we are in clearAll state (e.g. the user as hovering\r\n          // and has since mousedOut of the menu items),\r\n          // go to the first index\r\n          if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\r\n            index = -1;\r\n          }\r\n\r\n          // Got to the next option\r\n          this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\r\n        }\r\n        break;\r\n\r\n      case KeyCodes.home:\r\n      case KeyCodes.end:\r\n        if (allowFreeform) {\r\n          return;\r\n        }\r\n\r\n        // Set the initial values to respond to HOME\r\n        // which goes to the first selectable option\r\n        index = -1;\r\n        let directionToSearch = SearchDirection.forward;\r\n\r\n        // If end, update the values to respond to END\r\n        // which goes to the last selectable option\r\n        if (ev.which === KeyCodes.end) {\r\n          index = currentOptions.length;\r\n          directionToSearch = SearchDirection.backward;\r\n        }\r\n\r\n        this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\r\n        break;\r\n\r\n      case KeyCodes.space:\r\n        // event handled in _onComboBoxKeyUp\r\n        if (!allowFreeform && autoComplete === 'off') {\r\n          break;\r\n        }\r\n\r\n      default:\r\n        // are we processing a function key? if so bail out\r\n        if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {\r\n          return;\r\n        }\r\n\r\n        // If we get here and we got either and ALT key\r\n        // or meta key and we are current open, let's close the menu\r\n        if ((ev.altKey || ev.metaKey) && isOpen) {\r\n          this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\r\n        }\r\n\r\n        // If we are not allowing freeform and\r\n        // allowing autoComplete, handle the input here\r\n        // since we have marked the input as readonly\r\n        if (!allowFreeform && autoComplete === 'on') {\r\n          this._onInputChange(String.fromCharCode(ev.which));\r\n          break;\r\n        }\r\n\r\n        // allow the key to propigate by default\r\n        return;\r\n    }\r\n\r\n    ev.stopPropagation();\r\n    ev.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Handle keyup on the input\r\n   * @param ev - the keyboard event that was fired\r\n   */\r\n  private _onInputKeyUp = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\r\n    const {\r\n      disabled,\r\n      allowFreeform,\r\n      autoComplete\r\n    } = this.props;\r\n\r\n    if (disabled) {\r\n      this._handleInputWhenDisabled(ev);\r\n      return;\r\n    }\r\n\r\n    switch (ev.which) {\r\n      case KeyCodes.space:\r\n        // If we are not allowing freeform and are not autoComplete\r\n        // make space expand/collapse the comboBox\r\n        // and allow the event to propagate\r\n        if (!allowFreeform && autoComplete === 'off') {\r\n          const isOpen = this.state.isOpen;\r\n          this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\r\n          return;\r\n        }\r\n        break;\r\n\r\n      default:\r\n        return;\r\n    }\r\n\r\n    ev.stopPropagation();\r\n    ev.preventDefault();\r\n  }\r\n\r\n  private _onOptionMouseEnter(index: number): void {\r\n    if (!this._isScrollIdle) {\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      currentPendingValueValidIndexOnHover: index\r\n    });\r\n  }\r\n\r\n  private _onOptionMouseMove(index: number): void {\r\n    if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      currentPendingValueValidIndexOnHover: index\r\n    });\r\n  }\r\n\r\n  private _onOptionMouseLeave = () => {\r\n    if (!this._isScrollIdle) {\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      currentPendingValueValidIndexOnHover: HoverStatus.clearAll\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle dismissing the menu and\r\n   * eating the required key event when disabled\r\n   * @param ev - the keyboard event that was fired\r\n   */\r\n  private _handleInputWhenDisabled(ev: React.KeyboardEvent<HTMLElement | Autofill> | null): void {\r\n    // If we are disabled, close the menu (if needed)\r\n    // and eat all keystokes other than TAB or ESC\r\n    if (this.props.disabled) {\r\n      if (this.state.isOpen) {\r\n        this.setState({ isOpen: false });\r\n      }\r\n\r\n      // When disabled stop propagation and prevent default\r\n      // of the event unless we have a tab, escape, or function key\r\n      if (ev !== null &&\r\n        ev.which !== KeyCodes.tab &&\r\n        ev.which !== KeyCodes.escape &&\r\n        (ev.which < 112 /* F1 */ || ev.which > 123 /* F12 */)) {\r\n        ev.stopPropagation();\r\n        ev.preventDefault();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Click handler for the button of the comboBox\r\n   * and the input when not allowing freeform. This\r\n   * toggles the expand/collapse state of the comboBox (if enbled)\r\n   */\r\n  private _onComboBoxClick = (): void => {\r\n    const { disabled } = this.props;\r\n    const { isOpen } = this.state;\r\n\r\n    if (!disabled) {\r\n      this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Click handler for the autofill.\r\n   */\r\n  private _onAutofillClick = (): void => {\r\n    if (this.props.allowFreeform) {\r\n      this.focus(this.state.isOpen || this._processingTouch);\r\n    } else {\r\n      this._onComboBoxClick();\r\n    }\r\n  }\r\n\r\n  private _onTouchStart: () => void = () => {\r\n    if (this._comboBoxWrapper.value && !('onpointerdown' in this._comboBoxWrapper)) {\r\n      this._handleTouchAndPointerEvent();\r\n    }\r\n  }\r\n\r\n  private _onPointerDown = (ev: PointerEvent): void => {\r\n    if (ev.pointerType === 'touch') {\r\n      this._handleTouchAndPointerEvent();\r\n\r\n      ev.preventDefault();\r\n      ev.stopImmediatePropagation();\r\n    }\r\n  }\r\n\r\n  private _handleTouchAndPointerEvent() {\r\n    // If we already have an existing timeeout from a previous touch and pointer event\r\n    // cancel that timeout so we can set a nwe one.\r\n    if (this._lastTouchTimeoutId !== undefined) {\r\n      this._async.clearTimeout(this._lastTouchTimeoutId);\r\n      this._lastTouchTimeoutId = undefined;\r\n    }\r\n    this._processingTouch = true;\r\n\r\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\r\n      this._processingTouch = false;\r\n      this._lastTouchTimeoutId = undefined;\r\n    }, TouchIdleDelay);\r\n  }\r\n\r\n  /**\r\n * Get the styles for the current option.\r\n * @param item Item props for the current option\r\n */\r\n  private _getCaretButtonStyles(): IButtonStyles {\r\n    const { caretDownButtonStyles: customCaretDownButtonStyles } = this.props;\r\n    return getCaretDownButtonStyles(this.props.theme!, customCaretDownButtonStyles);\r\n  }\r\n\r\n  /**\r\n   * Get the styles for the current option.\r\n   * @param item Item props for the current option\r\n   */\r\n  private _getCurrentOptionStyles(item: IComboBoxOption): Partial<IComboBoxOptionStyles> {\r\n    const { comboBoxOptionStyles: customStylesForAllOptions } = this.props;\r\n    const { styles: customStylesForCurrentOption } = item;\r\n\r\n    return getOptionStyles(this.props.theme!, customStylesForAllOptions, customStylesForCurrentOption, this._isPendingOption(item));\r\n  }\r\n\r\n  /**\r\n   * Get the aria-activedescendant value for the comboxbox.\r\n   * @returns the id of the current focused combo item, otherwise the id of the currently selected element, null otherwise\r\n   */\r\n  private _getAriaActiveDescentValue(): string | undefined {\r\n    let descendantText = (this.state.isOpen && this.state.selectedIndices && this.state.selectedIndices.length >= 0 ? (this._id + '-list' + this.state.selectedIndices[0]) : undefined);\r\n    if (this.state.isOpen && this.state.focused && this.state.currentPendingValueValidIndex !== -1) {\r\n      descendantText = (this._id + '-list' + this.state.currentPendingValueValidIndex);\r\n    }\r\n    return descendantText;\r\n  }\r\n\r\n  /**\r\n  * Get the aria autocomplete value for the Combobox\r\n  * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from and can\r\n  * dynamically populate input, and 'none' if auto-complete is not enabled as we can't give user inputs.\r\n  */\r\n  private _getAriaAutoCompleteValue(): 'none' | 'inline' | 'list' | 'both' | undefined {\r\n    const autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\r\n    return autoComplete ? (this.props.allowFreeform ? 'inline' : 'both') : 'none';\r\n  }\r\n\r\n  private _isPendingOption(item: IComboBoxOption): boolean {\r\n    return item && item.index === this.state.currentPendingValueValidIndex;\r\n  }\r\n\r\n  /**\r\n   * Given default selected key(s) and selected key(s), return the selected keys(s).\r\n   * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\r\n   *\r\n   * @returns No matter what specific types the input parameters are, always return an array of\r\n   *  either strings or numbers instead of premitive type.  This normlization makes caller's logic easier.\r\n   */\r\n  private _getSelectedKeys(\r\n    defaultSelectedKey: string | number | string[] | number[] | undefined,\r\n    selectedKey: string | number | string[] | number[] | undefined\r\n  ): string[] | number[] {\r\n\r\n    let retKeys: string[] | number[] = [];\r\n\r\n    if (defaultSelectedKey) {\r\n      if (defaultSelectedKey instanceof Array) {\r\n        retKeys = defaultSelectedKey;\r\n      } else if (typeof defaultSelectedKey === 'string') {\r\n        retKeys = [defaultSelectedKey as string];\r\n      } else if (typeof defaultSelectedKey === 'number') {\r\n        retKeys = [defaultSelectedKey as number];\r\n      }\r\n    } else if (selectedKey) {\r\n      if (selectedKey instanceof Array) {\r\n        retKeys = selectedKey;\r\n      } else if (typeof selectedKey === 'string') {\r\n        retKeys = [selectedKey as string];\r\n      } else if (typeof selectedKey === 'number') {\r\n        retKeys = [selectedKey as number];\r\n      }\r\n    }\r\n\r\n    return retKeys;\r\n  }\r\n\r\n  // For scenarios where the option's text prop contains embedded styles, we use the option's\r\n  // ariaLabel value as the text in the input and for autocomplete matching. We know to use this\r\n  // when the useAriaLabelAsText prop is set to true\r\n  private _getPreviewText(item: IComboBoxOption): string {\r\n    return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\r\n  }\r\n}\r\n"]}