{"version":3,"file":"styleToClassName.js","sourceRoot":"../src/","sources":["styleToClassName.ts"],"names":[],"mappings":"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","sourcesContent":["import { IRawStyle, IStyle } from './IStyle';\r\n\r\nimport { Stylesheet } from './Stylesheet';\r\nimport { kebabRules } from './transforms/kebabRules';\r\nimport { prefixRules } from './transforms/prefixRules';\r\nimport { provideUnits } from './transforms/provideUnits';\r\nimport { rtlifyRules } from './transforms/rtlifyRules';\r\n\r\nconst DISPLAY_NAME = 'displayName';\r\n\r\n// tslint:disable-next-line:no-any\r\ntype IDictionary = { [key: string]: any };\r\n\r\ninterface IRuleSet {\r\n  __order: string[];\r\n  [key: string]: IDictionary;\r\n}\r\n\r\nfunction getDisplayName(rules?: { [key: string]: IRawStyle }): string | undefined {\r\n  const rootStyle: IStyle = rules && rules['&'];\r\n\r\n  return rootStyle ? (rootStyle as IRawStyle).displayName : undefined;\r\n}\r\n\r\nfunction extractRules(\r\n  args: IStyle[],\r\n  rules: IRuleSet = { __order: [] },\r\n  currentSelector: string = '&'\r\n): IRuleSet {\r\n  const stylesheet = Stylesheet.getInstance();\r\n  let currentRules: IDictionary | undefined = rules[currentSelector] as IDictionary;\r\n\r\n  if (!currentRules) {\r\n    currentRules = {};\r\n    rules[currentSelector] = currentRules;\r\n    rules.__order.push(currentSelector);\r\n  }\r\n\r\n  for (const arg of args) {\r\n    // If the arg is a string, we need to look up the class map and merge.\r\n    if (typeof arg === 'string') {\r\n      const expandedRules = stylesheet.argsFromClassName(arg);\r\n\r\n      if (expandedRules) {\r\n        extractRules(expandedRules, rules, currentSelector);\r\n      }\r\n      // Else if the arg is an array, we need to recurse in.\r\n    } else if (Array.isArray(arg)) {\r\n      extractRules(arg, rules, currentSelector);\r\n    } else {\r\n      // tslint:disable-next-line:no-any\r\n      for (const prop in (arg as any)) {\r\n        if (prop === 'selectors') {\r\n          // tslint:disable-next-line:no-any\r\n          const selectors: { [key: string]: IStyle } = (arg as any).selectors;\r\n\r\n          for (let newSelector in selectors) {\r\n            if (selectors.hasOwnProperty(newSelector)) {\r\n              const selectorValue = selectors[newSelector];\r\n\r\n              if (newSelector.indexOf(':global(') === 0) {\r\n                newSelector = newSelector.replace(/:global\\(|\\)$/g, '');\r\n              } else if (newSelector.indexOf('@media') === 0) {\r\n                newSelector = newSelector + '{' + currentSelector;\r\n              } else if (newSelector.indexOf(':') === 0) {\r\n                newSelector = currentSelector + newSelector;\r\n              } else if (newSelector.indexOf('&') < 0) {\r\n                newSelector = currentSelector + ' ' + newSelector;\r\n              }\r\n\r\n              extractRules([selectorValue], rules, newSelector);\r\n            }\r\n          }\r\n        } else {\r\n          // Else, add the rule to the currentSelector.\r\n          if (prop === 'margin' || prop === 'padding') {\r\n            // tslint:disable-next-line:no-any\r\n            expandQuads(currentRules, prop, (arg as any)[prop]);\r\n          } else {\r\n            // tslint:disable-next-line:no-any\r\n            (currentRules as any)[prop] = (arg as any)[prop] as any;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return rules;\r\n}\r\n\r\nfunction expandQuads(\r\n  currentRules: IDictionary,\r\n  name: string,\r\n  value: string\r\n): void {\r\n  const parts = (typeof value === 'string') ? value.split(' ') : [value];\r\n\r\n  currentRules[name + 'Top'] = parts[0];\r\n  currentRules[name + 'Right'] = parts[1] || parts[0];\r\n  currentRules[name + 'Bottom'] = parts[2] || parts[0];\r\n  currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\r\n}\r\n\r\nfunction getKeyForRules(rules: IRuleSet): string | undefined {\r\n  const serialized: string[] = [];\r\n  let hasProps = false;\r\n\r\n  for (const selector of rules.__order) {\r\n    serialized.push(selector);\r\n    const rulesForSelector = rules[selector];\r\n\r\n    for (const propName in rulesForSelector) {\r\n      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\r\n        hasProps = true;\r\n        serialized.push(propName, rulesForSelector[propName]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return hasProps ? serialized.join('') : undefined;\r\n}\r\n\r\nexport function serializeRuleEntries(ruleEntries: { [key: string]: string | number }): string {\r\n  if (!ruleEntries) {\r\n    return '';\r\n  }\r\n\r\n  const allEntries: (string | number)[] = [];\r\n\r\n  for (const entry in ruleEntries) {\r\n    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\r\n      allEntries.push(entry, ruleEntries[entry]);\r\n    }\r\n  }\r\n\r\n  // Apply transforms.\r\n  for (let i = 0; i < allEntries.length; i += 2) {\r\n    kebabRules(allEntries, i);\r\n    provideUnits(allEntries, i);\r\n    rtlifyRules(allEntries, i);\r\n    prefixRules(allEntries, i);\r\n  }\r\n\r\n  // Apply punctuation.\r\n  for (let i = 1; i < allEntries.length; i += 4) {\r\n    allEntries.splice(i, 1, ':', allEntries[i], ';');\r\n  }\r\n\r\n  return allEntries.join('');\r\n}\r\n\r\nexport interface IRegistration {\r\n  className: string;\r\n  key: string;\r\n  args: IStyle[];\r\n  rulesToInsert: string[];\r\n}\r\n\r\nexport function styleToRegistration(...args: IStyle[]): IRegistration | undefined {\r\n  const rules: IRuleSet = extractRules(args);\r\n  const key = getKeyForRules(rules);\r\n\r\n  if (key) {\r\n    const stylesheet = Stylesheet.getInstance();\r\n    const registration: Partial<IRegistration> = {\r\n      className: stylesheet.classNameFromKey(key),\r\n      key,\r\n      args\r\n    };\r\n\r\n    if (!registration.className) {\r\n      registration.className = stylesheet.getClassName(getDisplayName(rules));\r\n      const rulesToInsert: string[] = [];\r\n\r\n      for (const selector of rules.__order) {\r\n        rulesToInsert.push(\r\n          selector,\r\n          serializeRuleEntries(rules[selector])\r\n        );\r\n      }\r\n      registration.rulesToInsert = rulesToInsert;\r\n    }\r\n\r\n    return registration as IRegistration;\r\n  }\r\n}\r\n\r\nexport function applyRegistration(\r\n  registration: IRegistration,\r\n  classMap?: { [key: string]: string }\r\n): void {\r\n  const stylesheet = Stylesheet.getInstance();\r\n  const { className, key, args, rulesToInsert } = registration;\r\n\r\n  if (rulesToInsert) {\r\n    // rulesToInsert is an ordered array of selector/rule pairs.\r\n    for (let i = 0; i < rulesToInsert.length; i += 2) {\r\n      const rules = rulesToInsert[i + 1];\r\n      if (rules) {\r\n        let selector = rulesToInsert[i];\r\n\r\n        // Fix selector using map.\r\n        selector = selector.replace(/(&)|\\$([\\w-]+)\\b/g, (match: string, amp: string, cn: string): string => {\r\n          if (amp) {\r\n            return '.' + registration.className;\r\n          } else if (cn) {\r\n            return '.' + ((classMap && classMap[cn]) || cn);\r\n          }\r\n          return '';\r\n        });\r\n\r\n        // Insert. Note if a media query, we must close the query with a final bracket.\r\n        const processedRule = `${selector}{${rules}}${(selector.indexOf('@media') === 0) ? '}' : ''}`;\r\n\r\n        stylesheet.insertRule(processedRule);\r\n      }\r\n    }\r\n    stylesheet.cacheClassName(\r\n      className!,\r\n      key!,\r\n      args!,\r\n      rulesToInsert\r\n    );\r\n\r\n  }\r\n}\r\n\r\nexport function styleToClassName(...args: IStyle[]): string {\r\n  const registration = styleToRegistration(...args);\r\n  if (registration) {\r\n    applyRegistration(registration);\r\n\r\n    return registration.className;\r\n  }\r\n\r\n  return '';\r\n}\r\n"]}