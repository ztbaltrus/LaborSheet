/// <reference types="react" />
/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file Abstract React component for deferred component code.
 */
import * as React from 'react';
/**
 * Deferred component props.
 * @internal
 */
export interface IDeferredComponentProps<DeferredComponentProps, ComponentProps = undefined> {
    /**
     * Additional props for child class of DeferredComponent.
     */
    componentProps?: ComponentProps;
    /**
     * The props of the deferred React component.
     */
    deferredProps?: DeferredComponentProps;
    /**
     * Number of milliseconds to delay invoking the loader when the component will mount. Default is 0. If a negative
     * value is specified then loading must be manually invoked.
     */
    duration?: number;
    /**
     * An array of callbacks invoked after the _internalLoad Promise is resolved. Rendering is asynchronous so there
     * is no gurantee that is complete.
     */
    onAfterLoad?: Function[];
}
/**
 * Deferred component state
 * @internal
 */
export interface IDeferredComponentState<ComponentProps> {
    /**
     * The deferred React ComponentClass.
     */
    component: React.ComponentClass<ComponentProps>;
}
/**
 * DeferredComponent is a generic React component to define the pattern of React components loaded after
 * the initial code download.
 *
 * @param ComponentProps - The type of the props used to render the deferred component.
 *
 * Example:
 * class DeferredComponent extends Deferred<IComponentProps> {
 *   protected _internalLoad(): Promise<React.ComponentClass<IComponentProps>> {
 *     // code to lazy load e.g. require.ensure(...) or import(...)
 *   }
 * }
 *
 * @internal
 */
export default abstract class DeferredComponent<IDeferredProps, IComponentProps = undefined> extends React.Component<IDeferredComponentProps<IDeferredProps, IComponentProps>, Partial<IDeferredComponentState<IDeferredProps>>> {
    /**
     * Using any type because static members cannot reference class types. We either assign to or initialize with
     * strongly typed values so we should be able to safely assume the following types:
     * _loadedComponent: React.ComponentClass<IDeferredProps>
     * _loadPromise: Promise<React.ComponentClass<IDeferredProps>>
     */
    private static _loadedComponent;
    private static _loadPromise;
    /**
     * Typescript workaround for child classes to be able to access their own static instance of a static
     * member on the parent class. Note, this does not generate any additional code and only re-types the
     * constructor member as an object instead of a function.
     */
    'constructor': typeof DeferredComponent;
    /**
     * _asyncSetState is used to alias the _setState method. We dereference _setState when the component is
     * unmounted and set it back when the component will be mounted.
     */
    protected _asyncSetState: ((state: Partial<IDeferredComponentState<IDeferredProps>>) => void) | undefined;
    private _loadTimeoutId;
    /**
     * Construct a new instance of the DeferredComponent component.
     *
     * @param props - DeferredComponent props
     */
    constructor(props: IDeferredComponentProps<IDeferredProps, IComponentProps>);
    /**
     * @returns Whether or not the code should load. Value should not change during the lifecycle of an instance.
     */
    private readonly _shouldLoad;
    /**
     * Register setState callback when the component will mount. If we loaded the component while it
     * was unmounted, then update the state before mounting.
     */
    componentWillMount(): void;
    /**
     * Start component loading when the component mounts.
     */
    componentDidMount(): void;
    /**
     * Unregister setState callback if the component unmounts.
     */
    componentWillUnmount(): void;
    /**
     * Attempt to load if nextProps.duration indicates we should try to load and we have no previous attempts.
     */
    componentWillReceiveProps(nextProps: IDeferredComponentProps<IDeferredProps, IComponentProps>): void;
    /**
     * Render, if loaded, the deferred React component. If not loaded, skip rendering.
     *
     * @returns - The React component or false.
     */
    render(): React.ReactElement<IDeferredProps> | false;
    /**
     * Invokes _internalLoad to download the deferred code. After the download is complete,
     * re-render with a new instance of the deferred component and invoke any onAfterLoad callbacks.
     *
     * @returns - A Promise yielding the deferred React ComponentClass
     */
    load(): Promise<React.ComponentClass<IDeferredProps>>;
    /**
     * Abstract method to define the logic for loading the deferred React component.
     *
     * @returns - A promise yielding the deferred React ComponentClass.
     */
    protected abstract _internalLoad(): Promise<React.ComponentClass<IDeferredProps>>;
    /**
     * Overload this method to render a place holder for the deferred component. If not overloaded, then
     * we return false and nothing will render.
     *
     * @returns - An element to be rendered in place of the deferred component.
     */
    protected _renderPlaceHolder(): JSX.Element | false;
    private _handleComponentLoaded(component);
    /**
     * React.Component.setState should not be called if the component is not mounted. Due to the async component
     * loading we cannot guarantee the component is still mounted after the chunk is loaded. _asyncSetStateCallback
     * has a reference to this method when the component is mounted. Check and use _asyncSetStateCallback when you
     * are unsure if the component is mounted and want to invoke React.Component.setState.
     *
     * @param - state The new state
     */
    private _setState(state);
}
