import { DisplayMode } from '@microsoft/sp-core-library';
import { IClientSideWebPartManifest } from '@microsoft/sp-module-interfaces';
import IWebPartData from './IWebPartData';
import IWebPartHost from './IWebPartHost';
import IWebPartManagerContext from './IWebPartManagerContext';
import { IPropertyPaneConsumer } from '../propertyPane/propertyPaneConsumer/IPropertyPaneConsumer';
import { PropertyPaneAction } from '../propertyPane/propertyPaneDefinitions/PropertyPaneAction';
import WebPartContext from './WebPartContext';
/**
 * The ClientSideWebPartManager is expected to be the public interface to client side web parts. Each
 * host is expected to create an instance of this class and manage loading of all web parts in that host
 * through that one instance. e.g. On one page, if there are multiple Canvas objects, each one could have
 * one instance of this class. If the page hosts web parts without the Canvas, then the page can have an
 * instance of this class. Overall this class is expected to provide the following purpose:
 *
 *    - Orchestrates loading of one or more web parts in a host.
 *    - It takes care of loading web part dependencies asynchronously. Each web part loads completely
 *      independently of the other web parts in the host.
 *    - Keep a reference to all the loaded web parts and help provide bulk operations on the web parts.
 *    - Help manage memory leak type issues in one place.
 *    - Integrate the web parts with the PropertyPane and other external entities.
 *    - Help troubleshoot web parts during escalations.
 *
 * @internal
 */
export default class ClientSideWebPartManager {
    /**
     * Reference to the PropertyPane controller.
     * Note, all instances of ClientSideWebPartManager share the same PropertyPane controller.
     *
     * It is legacy, should be removed the killswitch 'ConsumePropertyPaneControllerFromServiceScope'
     */
    private static _legacyPropertyPaneController;
    /**
     * Reference to the instances of all ClientSideWebPartManager instances in the app.
     */
    private static readonly _webPartManagerList;
    /**
     * Reference to the PropertyPane controller.
     * Note, all instances of ClientSideWebPartManager share the same PropertyPane controller.
     */
    private _propertyPaneController;
    /**
     * Dictionary of all the active web parts in this insance of the manager.
     */
    private _webparts;
    /**
     * Host for this instance of the web part manager.
     * Note, at the current time there is no support for multiple hosts and the host is not expected to change.
     */
    private _host;
    private _logSource;
    /**
     * Timer to mark the canvas dirty.
     */
    private _dirtyBitTimer;
    /**
     * Event aggregator instance scoped to this web part manager instance.
     */
    private _eventAggregator;
    /**
     * Number of web parts asked to load, including web parts failed to load.
     */
    private _loadWebPartRequests;
    /**
     * Web part status renderer instance scoped to this web part manager instance.
     */
    private _statusRenderer;
    /**
     * Page context reference.
     */
    private _pageContext;
    /**
     * Promise for the async call to get edit-time web parts.
     */
    private _toolboxManifestsPromise;
    /**
     * Dictionary of all the iframed web parts in this instance of the manager.
     */
    private _iframedWebpartInstanceIds;
    /**
     * Reference to IframedWebPartController instance.
     * The instance is chunked loaded for the first time in 'this.loadWebPart'
     * and should be checked for existence before using.
     */
    private _iframedWebPartController?;
    private static _shouldLoadDynamicDependencies();
    private static _addPerfEUPLBreakdown(key, value, addToExistingValue?);
    /**
     * Returns true if the maintenanceMode query string parameter is provided.
     */
    static readonly isMaintenanceMode: boolean;
    /**
     * Initialize the ClientSideWebPartManager.
     *
     * @param host - Reference to the host. A web part host is a component that is deemed capable of hosting a web
     * part. Any component that implements the IWebPartHost is allowed to host a web part.
     */
    constructor(host: IWebPartHost);
    /**
     * Load a web part in the provided DOM element. Does the following steps
     *
     *    1. Validate params.
     *    2. Validate the web part manifest.
     *    3. Perform an async import of the web part modules from the provided manifest
     *      - i.e ClientSideWebPartManager._loadWebPartModules
     *    4. Instantiate and initialize the web part object
     *      - i.e. ClientSideWebPartManager._initializeWebPart
     *    5. Render the web part in the provided DOM element
     *      - i.e. ClientSideWebPartManager._renderWebPart
     *
     * If an error happens during any of the above steps, catch the error and log it.
     *
     * @param context - web part manager context.
     */
    loadWebPart(context: IWebPartManagerContext): Promise<void>;
    /**
     * Set a IPropertyPaneConsumer object into the set of the Client Side Web Part Manager's
     * managed web parts.
     *
     * @param id - A unique instance id.
     * @param control - A component which wants to use the property Pane.
     *
     * @internal
     */
    setPropertyPaneConsumer(id: string, control: IPropertyPaneConsumer): void;
    /**
     * Fetch web part manifests. This makes a REST call to load the current site's web parts into the module loader.
     */
    fetchWebPartManifests(): Promise<void>;
    /**
     * Get list of active web part manifests.
     *
     * @returns - array of manifests.
     */
    getWebPartManifests(): IClientSideWebPartManifest<any>[];
    /**
     * Set the display mode of the specified web part. If no web part id is specified, switch mode of all web parts.
     * If the display mode passed is same as the current mode, no change is applied.
     *
     * @param displayMode - the new DisplayMode.
     * @param instanceId - instance id of the web part.
     */
    setDisplayMode(displayMode: DisplayMode, instanceId?: string): void;
    /**
     * Serialize the specified web part. If no web part is specified, serialize all web parts.
     *
     * @param instanceId - instance id of the web part.
     */
    serialize(instanceId?: string): Map<string, IWebPartData | undefined>;
    /**
     * Set the web part data for the specified web part and re-render it.
     *
     * @param webPartData - the new web part data.
     * @param instanceId - instance id of the web part.
     */
    setWebPartData(webPartData: IWebPartData, instanceId: string): void;
    /**
     * Dispose of the current webpart manager and all of the webparts it has loaded.
     */
    dispose(): void;
    /**
     * Dispose the specified web part. If no web part is specified, dispose all web parts.
     *
     * @param instanceId - instance id of the web part.
     */
    disposeWebparts(instanceId?: string): void;
    tryGeneratePreviewImageUrl(instanceIds?: string[]): string | undefined;
    /**
     * Request property pane to perform the given action.
     *
     * @param instanceId - web part instance id.
     * @param propertyPaneAction - indicates what action needs to be performed on the property pane.
     * @param renderedByWebPart - indicates whether the the property pane rendered by a web part or not.
     */
    requestPropertyPaneAction(instanceId: string, propertyPaneAction?: PropertyPaneAction, renderedByWebPart?: boolean): void;
    /**
     * Returns true if the current property pane source is a web part and not the Canvas or any other source.
     */
    isPropertyPaneRenderedByWebPart(): boolean;
    /**
     * Returns the state of the PropertyPane if it is open or not.
     */
    isPropertyPaneOpen(): boolean;
    /**
      * Method to handle the web part delete action from the host. There is a key distinction between delete and dispose.
      * Delete implies that the web part has been deleted from the page and the web part should dispose all the server
      * side or other external resources attached to the web part. Dispose implies that an in-place navigation is
      * happening and the web part manager should delete the web part from its cache.
      *
      * @param instanceId - instance id of the webpart which is deleted.
      */
    onWebPartDelete(instanceId: string): void;
    /**
     * Render an error message in the web part container div.  Also logs the error message to the IWebPartHost logger.
     */
    renderError(domElement: HTMLElement, error: Error): void;
    /**
     * Notify webparts that their container has resized.
     *
     * @param instanceId - if specified only notify one webpart that its container has resized
     */
    notifyWebPartContainerResize(instanceId?: string): void;
    /** ------------------- PROTECTED ------------------- **/
    /**
     * Generate web part context.
     */
    protected _getWebPartContext(context: IWebPartManagerContext): WebPartContext;
    /** ------------------- PRIVATE ------------------- **/
    /**
     * Loads the web part component and any dynamic dependencies.
     */
    private _loadWebPartModules(context, webPartTag, qosMonitor);
    /**
     * Workaround for a server issue - disambiguate manifest locales if they haven't already been disambiguated
     * (VSO#243888) tracks fixing this issue.
     */
    private _disambiguateWebPartManifestLocales(manifests);
    /**
     * Validate and process input parameters.
     */
    private _validateInput(context);
    /**
     * Validate the web part manifest.
     */
    private _validateManifest(manifest, mode, webPartTag);
    /**
     * Execute the provided callback for the list of provided web part ids. If no list if provided,
     * execute the callback on all web parts.
     */
    private _executeForIdsOrAll(instanceIds, cb);
    private _instanceOfBase(wpi);
    private _getLoadedModuleList(moduleLibrary);
    /**
     * This is a temporary implementation of updating the host that a web part has updated properties.
     * Currently we run a timer that regularly checks for updated properties and raises the dirty bit
     * handler to the host. todo (VSO SPPPLAT#200728) tracks fixing this scenario in a better way.
     */
    private _startDirtyBitTimer(mode);
    /**
     * Creates a new extra data object for writing successes to QosMonitor.
     */
    private _createSuccessExtraData(alias, isInternal, manifestId, moduleLoadTime, initTime, renderTime);
    /**
     * Creates a new extra data object for writing unexpected failures to QosMonitor.
     */
    private _createUnexpectedFailureExtraData(alias, instanceId, isInternal, manifestId);
    /**
     * Creates a new QosMonitor with a scenario name specific to the web part type.
     */
    private _createLoadQosMonitor(manifest);
    /**
     * Create the web part tag. Web part tag is a unique tag per web part instance and is used for logging and telemetry.
     */
    private _createWebPartTag(manifest, instanceId);
    private _deleteWebPart(id);
    /**
     * Get web part manifest instance from manifest. Promotes the pre-configured entries.
     */
    private _getManifestInstance(context);
    /**
     * If non-non parameter passed, return array else return undefined.
     */
    private _getArrayOrUndefined(instanceId?);
    private _initialzeOnResizeEventHandler();
    /**
     * Window onresize event handler.
     */
    private _onContainerResize();
    /**
     * Listener for window post message that the property pane has been toggled open/close.
     *
     * @todo(SPPPLAT Bug #299413): Implement missing schema for property pane post messages
     */
    private _onPropertyPaneToggled(event);
    /**
    * Callback to handles property pane life cycle event change.
    * The callback is only triggered on the ClientSideWebPartManager that manages the currently configured WebPart.
    * Except for the ActiveWebPartChanged event, where all the ClientSideWebPartManager's
    * callbacks are triggered.
    */
    private _propertyPaneLifeCycleEventCallback(event, webpartInstanceId);
    /**
     * When all web parts added, check if in viewport web parts are rendered
     * If so then notify viewport loader to load rest of the web parts gradually.
     */
    private _onAllWebpartsAdded(context);
    private _onViewportWebpartsLoaded(context, endTime);
    /**
     * Return endtime of last rended web part if all web parts in the view port has rendered for current web part
     * manager instance, undefined otherwise.
     */
    private _getViewportRenderedEndTime();
    /**
     * Add all web parts in the viewport to the EUPL calculation
     */
    private _registerWebpartsInViewport();
    /**
    * Converts Module library into Internal Web part object.
    * Throws Exception if unexpectd found
    */
    private _instantiateWebPart(moduleLibrary, webPartTag);
    /**
     * Handle when exception occurred loading web part
     */
    private _handleErrorLoadingWebpart(manifest, instanceId, domElement, ex, qosMonitor);
    /**
     * handle when Module Promise is rejected
     */
    private _handleModulePromiseRejection(manifest, instanceId, domElement, webPartTag, error, qosMonitor);
    private _onFirstTimeWebpartRender(manifest, webPartTag, qosMonitor);
    private _getDataUpdatedEventName(webPartInstanceId);
    private _initializeWebPart(options);
    private _renderWebPart(options);
    /**
     * Load all valid dynamic dependencies and adds into moduleLoadPromises param.
     *
     * This is the core of dynamic dependency web part has provided through metadata. Framework ensures that the such
     * dependency is loaded for the web part before it starts rendering. Ideally this component's js bundle should be
     * already downloaded by server script preloading feature for first few web parts in viewport.
     */
    private _loadDynamicComponentDependencies(webPartData, webPartTag, moduleLoadPromises);
    /**
     * Registers a component as a property pane consumer.
     * @param instanceId - Instance id of the consumer, to be registered with the property pane.
     */
    private _registerWebPartAsPropertyPaneConsumer(instanceId);
}
