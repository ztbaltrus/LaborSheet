{"version":3,"sources":["Executable.ts"],"names":[],"mappings":"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","file":"Executable.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as child_process from 'child_process';\r\nimport * as os from 'os';\r\nimport * as path from 'path';\r\n\r\nimport { FileSystem, PosixModeBits } from './FileSystem';\r\n\r\n/**\r\n * Typings for one of the streams inside IExecutableSpawnSyncOptions.stdio.\r\n * @beta\r\n */\r\nexport type ExecutableStdioStreamMapping = 'pipe' | 'ignore' | 'inherit'\r\n  | NodeJS.WritableStream | NodeJS.ReadableStream\r\n  | number | undefined;\r\n\r\n/**\r\n * Typings for IExecutableSpawnSyncOptions.stdio.\r\n * @beta\r\n */\r\nexport type ExecutableStdioMapping = 'pipe' | 'ignore' | 'inherit' | ExecutableStdioStreamMapping[];\r\n\r\n/**\r\n * Options for Executable.tryResolve().\r\n * @beta\r\n */\r\nexport interface IExecutableResolveOptions {\r\n  /**\r\n   * The current working directory.  If omitted, process.cwd() will be used.\r\n   */\r\n  currentWorkingDirectory?: string;\r\n\r\n  /**\r\n   * The environment variables for the child process.  If omitted, process.env will be used.\r\n   */\r\n  environment?: NodeJS.ProcessEnv;\r\n}\r\n\r\n/**\r\n * Options for Executable.execute().\r\n * @beta\r\n */\r\nexport interface IExecutableSpawnSyncOptions extends IExecutableResolveOptions {\r\n  /**\r\n   * The content to be passed to the child process's stdin.\r\n   *\r\n   * NOTE: If specified, this content replaces any IExecutableSpawnSyncOptions.stdio[0]\r\n   * mapping for stdin.\r\n   */\r\n  input?: string;\r\n\r\n  /**\r\n   * The stdio mappings for the child process.\r\n   *\r\n   * NOTE: If IExecutableSpawnSyncOptions.input is provided, it will take precedence\r\n   * over the stdin mapping (stdio[0]).\r\n   */\r\n  stdio?: ExecutableStdioMapping;\r\n\r\n  /**\r\n   * The maximum time the process is allowed to run before it will be terminated.\r\n   */\r\n  timeoutMs?: number;\r\n\r\n  /**\r\n   * The largest amount of bytes allowed on stdout or stderr for this synchonous operation.\r\n   * If exceeded, the child process will be terminated.  The default is 200 * 1024.\r\n   */\r\n  maxBuffer?: number;\r\n}\r\n\r\n// Common environmental state used by Executable members\r\ninterface IExecutableContext {\r\n  currentWorkingDirectory: string;\r\n  environment: NodeJS.ProcessEnv;\r\n  // For Windows, the parsed PATHEXT environment variable\r\n  windowsExecutableExtensions: string[];\r\n}\r\n\r\n/**\r\n * The Executable class provides a safe, portable, recommended solution for tools that need\r\n * to launch child processes.\r\n *\r\n * @remarks\r\n * The NodeJS child_process API provides a solution for launching child processes, however\r\n * its design encourages reliance on the operating system shell for certain features.\r\n * Invoking the OS shell is not safe, not portable, and generally not recommended:\r\n *\r\n * - Different shells have different behavior and command-line syntax, and which shell you\r\n *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be\r\n *   available on all platforms.\r\n *\r\n * - If a command parameter contains symbol characters, a shell may interpret them, which\r\n *   can introduce a security vulnerability\r\n *\r\n * - Each shell has different rules for escaping these symbols.  On Windows, the default\r\n *   shell is incapable of escaping certain character sequences.\r\n *\r\n * The Executable API provides a pure JavaScript implementation of primitive shell-like\r\n * functionality for searching the default PATH, appending default file extensions on Windows,\r\n * and executing a file that may contain a POSIX shebang.  This primitive functionality\r\n * is sufficient (and recommended) for most tooling scenarios.\r\n *\r\n * If you need additional shell features such as wildcard globbing, environment variable\r\n * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`\r\n * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is\r\n * guaranteed to work consistently across all platforms.\r\n *\r\n * @public\r\n */\r\nexport class Executable {\r\n  /**\r\n   * Synchronously create a child process and optionally capture its output.\r\n   *\r\n   * @remarks\r\n   * This function is similar to child_process.spawnSync().  The main differences are:\r\n   *\r\n   * - It does not invoke the OS shell unless the executable file is a shell script.\r\n   * - Command-line arguments containing special characters are more accurately passed\r\n   *   through to the child process.\r\n   * - If the filename is missing a path, then the shell's default PATH will be searched.\r\n   * - If the filename is missing a file extension, then Windows default file extensions\r\n   *   will be searched.\r\n   *\r\n   * @param filename - The name of the executable file.  This string must not contain any\r\n   * command-line arguments.  If the name contains any path delimiters, then the shell's\r\n   * default PATH will not be searched.\r\n   * @param args - The command-line arguments to be passed to the process.\r\n   * @param options - Additional options\r\n   * @returns the same data type as returned by the NodeJS child_process.spawnSync() API\r\n   *\r\n   * @internalremarks\r\n   *\r\n   * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>\r\n   * polymorphically based on the options.encoding parameter value.  This is a fairly confusing\r\n   * design.  In most cases, developers want string with the default encoding.  If/when someone\r\n   * wants binary output or a non-default text encoding, we will introduce a separate API function\r\n   * with a name like \"spawnWithBufferSync\".\r\n   */\r\n  public static spawnSync(filename: string, args: string[], options?: IExecutableSpawnSyncOptions):\r\n    child_process.SpawnSyncReturns<string> {\r\n\r\n    if (!options) {\r\n      options = { };\r\n    }\r\n\r\n    const context: IExecutableContext = Executable._getExecutableContext(options);\r\n\r\n    const resolvedPath: string | undefined = Executable._tryResolve(filename, options, context);\r\n    if (!resolvedPath) {\r\n      throw new Error(`The executable file was not found: \"${filename}\"`);\r\n    }\r\n\r\n    const spawnOptions: child_process.SpawnSyncOptionsWithStringEncoding = {\r\n      cwd: context.currentWorkingDirectory,\r\n      env: context.environment,\r\n      input: options.input,\r\n      stdio: options.stdio,\r\n      timeout: options.timeoutMs,\r\n      maxBuffer: options.maxBuffer,\r\n\r\n      // NOTE: This is always false, because Rushell is recommended instead of relying on the OS shell.\r\n      shell: false\r\n    } as child_process.SpawnSyncOptionsWithStringEncoding;\r\n\r\n    // PROBLEM: Given an \"args\" array of strings that may contain special characters (e.g. spaces,\r\n    // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array\r\n    // without anything getting corrupted along the way.\r\n    //\r\n    // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:\r\n    // - The Win32 CreateProcess() API expects the args to be encoded as a single text string\r\n    // - The decoding of this string is up to the application (not the OS), and there are 3 different\r\n    //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and\r\n    //   the Win32 CommandLineToArgvW()\r\n    // - The encodings are counterintuitive and have lots of special cases\r\n    // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used\r\n    //\r\n    // See these articles for a full analysis:\r\n    // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/\r\n    // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/\r\n\r\n    const environment: NodeJS.ProcessEnv = options && options.environment\r\n      || process.env;\r\n    const fileExtension: string = path.extname(resolvedPath);\r\n\r\n    if (os.platform() === 'win32') {\r\n      // Do we need a custom handler for this file type?\r\n      switch (fileExtension.toUpperCase()) {\r\n        case '.EXE':\r\n        case '.COM':\r\n          // okay to execute directly\r\n          break;\r\n        case '.BAT':\r\n        case '.CMD':\r\n          {\r\n            Executable._validateArgsForWindowsShell(args);\r\n\r\n            // These file types must be invoked via the Windows shell\r\n            let shellPath: string | undefined = environment.COMSPEC;\r\n            if (!shellPath || !Executable._canExecute(shellPath, context)) {\r\n              shellPath = Executable.tryResolve('cmd.exe');\r\n            }\r\n            if (!shellPath) {\r\n              throw new Error(`Unable to execute \"${path.basename(resolvedPath)}\" `\r\n                + `because CMD.exe was not found in the PATH`);\r\n            }\r\n\r\n            const shellArgs: string[] = [];\r\n            // /D: Disable execution of AutoRun commands when starting the new shell context\r\n            shellArgs.push('/d');\r\n            // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line\r\n            shellArgs.push('/s');\r\n            // /C: Execute the following command and then exit immediately\r\n            shellArgs.push('/c');\r\n            shellArgs.push(resolvedPath);\r\n            shellArgs.push(...args);\r\n\r\n            return child_process.spawnSync(shellPath, shellArgs, spawnOptions);\r\n          }\r\n        default:\r\n          throw new Error(`Cannot execute \"${path.basename(resolvedPath)}\" because the file type is not supported`);\r\n      }\r\n    }\r\n\r\n    return child_process.spawnSync(resolvedPath, args, spawnOptions);\r\n  }\r\n\r\n  /**\r\n   * Given a filename, this determines the absolute path of the executable file that would\r\n   * be executed by a shell:\r\n   *\r\n   * - If the filename is missing a path, then the shell's default PATH will be searched.\r\n   * - If the filename is missing a file extension, then Windows default file extensions\r\n   *   will be searched.\r\n   *\r\n   * @remarks\r\n   *\r\n   * @param filename - The name of the executable file.  This string must not contain any\r\n   * command-line arguments.  If the name contains any path delimiters, then the shell's\r\n   * default PATH will not be searched.\r\n   * @param filename - the name of the executable, which may be missing the path or file extension\r\n   * @param options - optional other parameters\r\n   * @returns the absolute path of the executable, or undefined if it was not found\r\n   */\r\n  public static tryResolve(filename: string, options?: IExecutableResolveOptions): string | undefined {\r\n    return Executable._tryResolve(filename, options || { }, Executable._getExecutableContext(options));\r\n  }\r\n\r\n  private static _tryResolve(filename: string, options: IExecutableResolveOptions,\r\n    context: IExecutableContext): string | undefined {\r\n\r\n    // NOTE: Since \"filename\" cannot contain command-line arguments, the \"/\" here\r\n    // must be interpreted as a path delimiter\r\n    const hasPathSeparators: boolean = filename.indexOf('/') >= 0\r\n      || (os.platform() === 'win32' && filename.indexOf('\\\\') >= 0);\r\n\r\n    // Are there any path separators?\r\n    if (hasPathSeparators) {\r\n      // If so, then don't search the PATH.  Just resolve relative to the current working directory\r\n      const resolvedPath: string = path.resolve(context.currentWorkingDirectory, filename);\r\n      return Executable._tryResolveFileExtension(resolvedPath, context);\r\n    } else {\r\n      // Otherwise if it's a bare name, then try everything in the shell PATH\r\n      const pathsToSearch: string[] = Executable._getSearchFolders(context);\r\n\r\n      for (const pathToSearch of pathsToSearch) {\r\n        const resolvedPath: string = path.join(pathToSearch, filename);\r\n        const result: string | undefined = Executable._tryResolveFileExtension(resolvedPath, context);\r\n        if (result) {\r\n          return result;\r\n        }\r\n      }\r\n\r\n      // No match was found\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  private static _tryResolveFileExtension(resolvedPath: string, context: IExecutableContext): string | undefined {\r\n    if (Executable._canExecute(resolvedPath, context)) {\r\n      return resolvedPath;\r\n    }\r\n\r\n    // Try the default file extensions\r\n    for (const shellExtension of context.windowsExecutableExtensions) {\r\n      const resolvedNameWithExtension: string = resolvedPath + shellExtension;\r\n\r\n      if (Executable._canExecute(resolvedNameWithExtension, context)) {\r\n        return resolvedNameWithExtension;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * This is used when searching the shell PATH for an executable, to determine\r\n   * whether a match should be skipped or not.  If it returns true, this does not\r\n   * guarantee that the file can be successfully executed.\r\n   */\r\n  private static _canExecute(filePath: string, context: IExecutableContext): boolean {\r\n    if (!FileSystem.exists(filePath)) {\r\n      return false;\r\n    }\r\n\r\n    if (os.platform() === 'win32') {\r\n      // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.\r\n      // That environment variable determines which extensions can be appended if the\r\n      // extension is missing, but it does not affect whether a file may be executed or not.\r\n      // Windows does have a (seldom used) ACL that can be used to deny execution permissions\r\n      // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.\r\n\r\n      // However, Windows *does* require that the file has some kind of file extension\r\n      if (path.extname(filePath) === '') {\r\n        return false;\r\n      }\r\n\r\n    } else {\r\n      // For Unix, check whether any of the POSIX execute bits are set\r\n      try {\r\n        // tslint:disable-next-line:no-bitwise\r\n        if ((FileSystem.getPosixModeBits(filePath) & PosixModeBits.AllExecute) === 0) {\r\n          return false; // not executable\r\n        }\r\n      } catch (error) {\r\n        // If we have trouble accessing the file, ignore the error and consider it \"not executable\"\r\n        // since that's what a shell would do\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns the list of folders where we will search for an executable,\r\n   * based on the PATH environment variable.\r\n   */\r\n  private static _getSearchFolders(context: IExecutableContext): string[] {\r\n\r\n    const pathList: string = context.environment.PATH || '';\r\n\r\n    const folders: string[] = [];\r\n\r\n    // Avoid processing duplicates\r\n    const seenPaths: Set<string> = new Set<string>();\r\n\r\n    // NOTE: Cmd.exe on Windows always searches the current working directory first.\r\n    // PowerShell and Unix shells do NOT do that, because it's a security concern.\r\n    // We follow their behavior.\r\n\r\n    for (const splitPath of pathList.split(path.delimiter)) {\r\n      const trimmedPath: string = splitPath.trim();\r\n      if (trimmedPath !== '') {\r\n        if (!seenPaths.has(trimmedPath)) {\r\n          // Fun fact: If you put relative paths in your PATH environment variable,\r\n          // all shells will dynamically match them against the current working directory.\r\n          // This is a terrible design, and in practice nobody does that, but it is supported...\r\n          // so we allow it here.\r\n          const resolvedPath: string = path.resolve(context.currentWorkingDirectory, trimmedPath);\r\n\r\n          if (!seenPaths.has(resolvedPath)) {\r\n            if (FileSystem.exists(resolvedPath)) {\r\n              folders.push(resolvedPath);\r\n            }\r\n\r\n            seenPaths.add(resolvedPath);\r\n          }\r\n\r\n          seenPaths.add(trimmedPath);\r\n        }\r\n      }\r\n    }\r\n\r\n    return folders;\r\n  }\r\n\r\n  private static _getExecutableContext(options: IExecutableResolveOptions | undefined): IExecutableContext {\r\n    if (!options) {\r\n      options = { };\r\n    }\r\n\r\n    const environment: NodeJS.ProcessEnv = options.environment || process.env;\r\n\r\n    let currentWorkingDirectory: string;\r\n    if (options.currentWorkingDirectory) {\r\n      currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);\r\n    } else {\r\n      currentWorkingDirectory = process.cwd();\r\n    }\r\n\r\n    const windowsExecutableExtensions: string[] = [];\r\n\r\n    if (os.platform() === 'win32') {\r\n      const pathExtVariable: string = environment.PATHEXT || '';\r\n      for (const splitValue of pathExtVariable.split(';')) {\r\n        const trimmed: string = splitValue.trim().toLowerCase();\r\n        // Ignore malformed extensions\r\n        if (/^\\.[a-z0-9\\.]*[a-z0-9]$/i.test(trimmed)) {\r\n          // Don't add the same extension twice\r\n          if (windowsExecutableExtensions.indexOf(trimmed) < 0) {\r\n            windowsExecutableExtensions.push(trimmed);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      environment,\r\n      currentWorkingDirectory,\r\n      windowsExecutableExtensions\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Checks for characters that are unsafe to pass to a Windows batch file\r\n   * due to the way that cmd.exe implements escaping.\r\n   */\r\n  private static _validateArgsForWindowsShell(args: string[]): void {\r\n    const specialCharRegExp: RegExp = /[%\\^&|<>\\r\\n]/g;\r\n\r\n    for (const arg of args) {\r\n      const match: RegExpMatchArray | null = arg.match(specialCharRegExp);\r\n      if (match) {\r\n        // NOTE: It is possible to escape some of these characters by prefixing them\r\n        // with a caret (^), which allows these characters to be successfully passed\r\n        // through to the batch file %1 variables.  But they will be expanded again\r\n        // whenever they are used.  For example, NPM's binary wrapper batch files\r\n        // use \"%*\" to pass their arguments to Node.exe, which causes them to be expanded\r\n        // again.  Unfortunately the Cmd.exe batch language provides native escaping\r\n        // function (that could be used to insert the carets again).\r\n        //\r\n        // We could work around that by adding double carets, but in general there\r\n        // is no way to predict how many times the variable will get expanded.\r\n        // Thus, there is no generally reliable way to pass these characters.\r\n        throw new Error(`The command line argument ${JSON.stringify(arg)} contains a`\r\n          + ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":"../src"}