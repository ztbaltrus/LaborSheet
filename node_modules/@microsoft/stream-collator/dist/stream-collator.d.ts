/// <reference types="node" />
import * as Stream from 'stream';

/**
 * This is a special type of stream class which has two substreams (stderr and stdout), which you can write to.
 * The DualTaskStream will merge these two streams into a single readable stream.
 * Everything written to stderr is written in red, unless it is a Warning, in which case it appears in yellow.
 *
 * @public
 */
export declare class DualTaskStream extends Stream.Readable implements NodeJS.ReadableStream, NodeJS.EventEmitter {
    stdout: PersistentStream;
    stderr: PersistentStream;
    private _quietMode;
    private _stdoutClosed;
    private _stderrClosed;
    private _closed;
    /**
     * @param quietMode - true if things written to stdout (and warnings) should be ignored
     */
    constructor(quietMode?: boolean);
    _read(): void;
    /**
     * Closes both substreams and closes the readable stream
     */
    end(): void;
}

/**
 * A static class which manages the output of multiple threads.
 *
 * @public
 */
export declare class Interleaver {
    private static _tasks;
    private static _activeTask;
    private static _stdout;
    /**
     * Resets the default output stream
     */
    static setStdOut(stdout: {
        write: (text: string) => void;
    }): void;
    /**
     * Registers a task into the list of active buffers and returns a ITaskWriter for the
     * calling process to use to manage output.
     */
    static registerTask(taskName: string, quietMode?: boolean): ITaskWriter;
    /**
     * Removes information about all running tasks
     */
    static reset(): void;
    /**
     * Adds the text to the task's buffer, and writes it to the console if it is the active task
     */
    private static _writeTaskOutput(taskName, data, stream?);
    /**
     * Returns the current value of the task's buffer
     */
    private static _getTaskOutput(taskName, stream?);
    /**
     * Marks a task as completed. There are 3 cases:
     *  - If the task was the active task, also write out all completed, unwritten tasks
     *  - If there is no active task, write the output to the screen
     *  - If there is an active task, mark the task as completed and wait for active task to complete
     */
    private static _completeTask(taskName);
    /**
     * Helper function which writes all completed tasks
     */
    private static _writeAllCompletedTasks();
    /**
     * Write and delete task
     */
    private static _writeTask(taskName, taskInfo);
    /**
     * A constructor which throws an exception if used
     */
    constructor();
}

/**
 * An writable interface for managing output of simultaneous processes.
 *
 * @public
 */
export declare interface ITaskWriter {
    write(data: string): void;
    writeLine(data: string): void;
    writeError(data: string): void;
    getStdOutput(): string;
    getStdError(): string;
    close(): void;
}

/**
 * A special type of stream which keeps track of everything written to it, which can be read with the readAll() function
 *
 * @public
 */
export declare class PersistentStream extends Stream.Transform {
    private _buffer;
    constructor(opts?: Stream.TransformOptions);
    _transform(chunk: Buffer | String, encoding: string, done: (err?: Object, data?: Object) => void): void;
    readAll(): string;
}

/**
 * A class which manages the output of multiple threads.
 *
 * @public
 */
export declare class StreamCollator<T extends NodeJS.ReadableStream> extends Stream.Readable implements NodeJS.ReadableStream {
    private _streams;
    private _activeStream;
    _read(): void;
    /**
     * Registers a stream into the list of active buffers.
     */
    register(stream: T): void;
    /**
     * Locates a suitable stream which could be set as the new active stream
     */
    private _findActiveTaskCandidate();
    /**
     * Ensures that a stream is set as active, will set the passed in stream as the active stream if none exists
     */
    private _ensureActiveTask();
    /**
     * Flushes a streams buffer and writes it to disk
     */
    private _writeTaskBuffer(stream);
    /**
     * The on('data') callback handler, which either writes or buffers the data
     */
    private _streamData(stream);
    /**
     * Marks a stream as completed. There are 3 cases:
     *  - If the stream was the active stream, also write out all completed, unwritten streams
     *  - If there is no active stream, write the output to the screen
     *  - If there is an active stream, mark the stream as completed and wait for active stream to complete
     */
    private _streamEnd(stream);
    /**
     * Helper function which returns true if all streams have been closed
     */
    private _areStreamsClosedAndWritten();
    /**
     * Helper function which writes all completed streams
     */
    private _writeAllCompletedTasks();
}
