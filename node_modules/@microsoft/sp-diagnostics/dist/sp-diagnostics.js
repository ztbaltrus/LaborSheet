define("78359e4b-07c2-43c6-8d0b-d060b4d577e8_1.6.0", ["@microsoft/sp-core-library","@microsoft/sp-lodash-subset"], function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_2__) { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: external "@microsoft/sp-core-library"
var sp_core_library_ = __webpack_require__(0);
var sp_core_library__default = /*#__PURE__*/__webpack_require__.n(sp_core_library_);

// CONCATENATED MODULE: ./lib/Api/LogSource.js

var LogSource_LogSource = (function () {
    function LogSource(id) {
        sp_core_library_["Validate"].isNotNullOrUndefined(id, 'id');
        this._id = id;
    }
    LogSource.create = function (id) {
        return new LogSource(id);
    };
    Object.defineProperty(LogSource.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    LogSource.prototype.isEmpty = function () {
        return this._id.length === 0;
    };
    return LogSource;
}());
/* harmony default export */ var Api_LogSource = (LogSource_LogSource);
var logSourceServiceKey = sp_core_library_["ServiceKey"].createCustom('sp-client-base:LogSource', function (serviceScope) {
    return LogSource_LogSource.create('');
});

// CONCATENATED MODULE: ./lib/Api/LogManager/CircularBuffer.js
var CircularBuffer = (function () {
    function CircularBuffer(size) {
        this._head = -1;
        this._count = 0;
        this._isIterating = false;
        if (size <= 0) {
            throw new Error('Size must be positive');
        }
        this._size = size;
        this._buffer = new Array(size);
    }
    Object.defineProperty(CircularBuffer.prototype, "count", {
        get: function () {
            return this._count;
        },
        enumerable: true,
        configurable: true
    });
    CircularBuffer.prototype.push = function (item) {
        this._ensureNotIterating();
        this._head++;
        this._count++;
        if (this._head === this._size) {
            this._head = 0;
        }
        this._buffer[this._head] = item;
    };
    CircularBuffer.prototype.forEach = function (handle) {
        if (this._count === 0) {
            return;
        }
        this._isIterating = true;
        try {
            var current = this._tail;
            for (var i = 0; i < this._size; i++) {
                handle(this._buffer[current]);
                if (current === this._head) {
                    break;
                }
                current = this._getNext(current);
            }
        }
        finally {
            this._isIterating = false;
        }
    };
    CircularBuffer.prototype.removeAll = function () {
        this._ensureNotIterating();
        this._head = -1;
        this._count = 0;
    };
    Object.defineProperty(CircularBuffer.prototype, "_tail", {
        get: function () {
            if (this._isNotWrapped()) {
                return 0;
            }
            return this._getNext(this._head);
        },
        enumerable: true,
        configurable: true
    });
    CircularBuffer.prototype._isNotWrapped = function () {
        return this._count === (this._head + 1);
    };
    CircularBuffer.prototype._getNext = function (index) {
        var nextIndex = index + 1;
        if (nextIndex === this._size) {
            nextIndex = 0;
        }
        return nextIndex;
    };
    CircularBuffer.prototype._ensureNotIterating = function () {
        if (this._isIterating) {
            throw new Error('Circular buffer cannot be modified during iteration');
        }
    };
    return CircularBuffer;
}());
/* harmony default export */ var LogManager_CircularBuffer = (CircularBuffer);

// CONCATENATED MODULE: ./lib/Api/LogManager/LogManager.js

var LogManager_LogManager = (function () {
    function LogManager(initialHandler) {
        this._shouldLogInRealTime = [];
        this._handlers = [];
        this._events = new LogManager_CircularBuffer(LogManager._maxVerboseLog);
        if (initialHandler) {
            this.addHandler(initialHandler);
        }
    }
    Object.defineProperty(LogManager, "_maxVerboseLog", {
        get: function () {
            return 5000;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogManager.prototype, "events", {
        get: function () {
            return this._events;
        },
        enumerable: true,
        configurable: true
    });
    LogManager.prototype.addHandler = function (handler) {
        if (!this._containsHandler(handler)) {
            this._handlers.push(handler);
            this._shouldLogInRealTime.push(false);
        }
    };
    LogManager.prototype.log = function (event) {
        Object.freeze(event);
        this._events.push(event);
        this._processLogEvent(event);
    };
    LogManager.prototype.removeHandler = function (handler) {
        var index = this._handlers.indexOf(handler);
        if (index > -1) {
            this._handlers.splice(index, 1);
            this._shouldLogInRealTime.splice(index, 1);
        }
    };
    LogManager.prototype.reset = function () {
        this._handlers = [];
        this._shouldLogInRealTime = [];
        this._events.removeAll();
    };
    LogManager.prototype.processAll = function (handler) {
        if (this._handlers.indexOf(handler) > -1) {
            this._processAllEvents(handler);
        }
    };
    LogManager.prototype._containsHandler = function (handler) {
        for (var _i = 0, _a = this._handlers; _i < _a.length; _i++) {
            var existingHandler = _a[_i];
            if (existingHandler === handler) {
                return true;
            }
        }
        return false;
    };
    LogManager.prototype._processAllEvents = function (handler) {
        this._events.forEach(function (event) {
            if (event) {
                try {
                    handler(event);
                }
                catch (e) {
                    console.error('failed to handle event:' + e.toString());
                }
            }
        });
        this._shouldLogInRealTime[this._handlers.indexOf(handler)] = true;
    };
    LogManager.prototype._processLogEvent = function (event) {
        for (var i = 0; i < this._handlers.length; i++) {
            if (this._shouldLogInRealTime[i] && event) {
                try {
                    this._handlers[i](event);
                }
                catch (e) {
                    console.error('failed to handle event:' + e.toString());
                }
            }
        }
    };
    return LogManager;
}());
/* harmony default export */ var Api_LogManager_LogManager = (LogManager_LogManager);

// CONCATENATED MODULE: ./lib/Api/Trace/LogEvent.js


var LogEvent_LogEvent = (function () {
    function LogEvent(source, data, level, serviceScope) {
        this._validate(source, data);
        this._timestamp = new Date().getTime();
        this._scope = this._getScope(serviceScope);
        this._source = source.substr(0, this._maxSourceLength);
        this._setData(data);
        this._level = level;
        this._prefix = this._getPrefix();
    }
    LogEvent.log = function (source, data, level, serviceScope) {
        var event = new LogEvent(source, data, level, serviceScope);
        LogEvent.logManager.log(event);
        return event;
    };
    LogEvent.prototype.toString = function () {
        var timedPrefix = "[" + this._timestamp + "][" + this._prefix + "]";
        if (this._message) {
            return timedPrefix + " " + this._message;
        }
        else if (this._error) {
            return timedPrefix + " " + this._error.toString();
        }
        else {
            return timedPrefix;
        }
    };
    Object.defineProperty(LogEvent.prototype, "timestamp", {
        get: function () {
            return this._timestamp;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "level", {
        get: function () {
            return this._level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "prefix", {
        get: function () {
            return this._prefix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "scope", {
        get: function () {
            return this._scope;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "source", {
        get: function () {
            return this._source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "message", {
        get: function () {
            return this._message;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "error", {
        get: function () {
            return this._error;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "_maxSourceLength", {
        get: function () {
            return 30;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogEvent.prototype, "_maxMessageLength", {
        get: function () {
            return 150;
        },
        enumerable: true,
        configurable: true
    });
    LogEvent.prototype._validate = function (source, data) {
        if (!source) {
            throw new Error('source cannot be undefined or null for Logger');
        }
        if (!data) {
            throw new Error('data cannot be undefined or null');
        }
    };
    LogEvent.prototype._setData = function (data) {
        if (typeof data === 'string') {
            this._message = data.substr(0, this._maxMessageLength);
        }
        else if (data instanceof Error) {
            this._error = data;
        }
    };
    LogEvent.prototype._getPrefix = function () {
        var prefix = "" + this._source;
        if (this._scope && !this._scope.isEmpty()) {
            prefix = this._scope.id.substr(0, this._maxSourceLength) + "." + prefix;
        }
        return "" + prefix;
    };
    LogEvent.prototype._getScope = function (serviceScope) {
        var parentSource;
        if (serviceScope) {
            serviceScope.whenFinished(function () {
                parentSource = serviceScope.consume(logSourceServiceKey);
            });
        }
        return parentSource;
    };
    LogEvent.logManager = new Api_LogManager_LogManager();
    return LogEvent;
}());
/* harmony default export */ var Trace_LogEvent = (LogEvent_LogEvent);

// CONCATENATED MODULE: ./lib/Api/LogLevel.js
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Verbose"] = 1] = "Verbose";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warning"] = 3] = "Warning";
    LogLevel[LogLevel["Error"] = 4] = "Error";
})(LogLevel = LogLevel || (LogLevel = {}));

// CONCATENATED MODULE: ./lib/Api/Trace/DefaultTraceHandler.js
var DefaultTraceHandler = (function () {
    function DefaultTraceHandler() {
    }
    DefaultTraceHandler.prototype.log = function (traceLogEvent) {
        if (true) {
            console.log("Error: " + traceLogEvent.data + ", " +
                ("Event Name: " + traceLogEvent.eventName + ", ") +
                ("Result Code: " + traceLogEvent.resultCode));
        }
    };
    DefaultTraceHandler.prototype.verbose = function (verboseTraceEvent) {
        if (true) {
            console.log("Error: " + verboseTraceEvent.data + ", Event Name: " + verboseTraceEvent.eventName);
        }
    };
    return DefaultTraceHandler;
}());
/* harmony default export */ var Trace_DefaultTraceHandler = (DefaultTraceHandler);

// CONCATENATED MODULE: ./lib/Api/Trace/TraceLogger.js





var TraceLogger_TraceLogger = (function () {
    function TraceLogger() {
    }
    TraceLogger._addHandler = function (logger) {
        TraceLogger._logManager.addHandler(logger.log);
        TraceLogger._logManager.processAll(logger.log);
        TraceLogger._verboseLogManager.addHandler(logger.verbose);
        TraceLogger._verboseLogManager.processAll(logger.verbose);
    };
    TraceLogger.logError = function (source, error, eventName, resultCode) {
        sp_core_library_["Validate"].isNotNullOrUndefined(error, 'error');
        this._log(source, error, eventName, true, resultCode);
    };
    TraceLogger.logErrorData = function (data) {
        sp_core_library_["Validate"].isNotNullOrUndefined(data.error, 'error');
        var errorInfo = data.logEntry ? data.logEntry.toString() : data.error;
        this._log(data.source, errorInfo, data.eventName, true, data.resultCode, data.serviceScope);
    };
    TraceLogger.logVerbose = function (source, message, eventName) {
        sp_core_library_["Validate"].isNonemptyString(message, 'message');
        this._log(source, message, eventName, false, undefined);
    };
    TraceLogger.logVerboseData = function (data) {
        var message = data.logEntry ? data.logEntry.toString() : data.message;
        this._log(data.source, message, data.eventName, false, undefined, data.serviceScope);
    };
    TraceLogger.logErrorWithLogEntry = function (source, logEntry, eventName, resultCode) {
        sp_core_library_["Validate"].isNotNullOrUndefined(logEntry, 'LogEntry');
        this._log(source, logEntry.toString(), eventName, true, resultCode);
    };
    Object.defineProperty(TraceLogger, "shouldWriteToConsole", {
        get: function () { return TraceLogger._shouldWriteToConsole; },
        set: function (shouldWrite) {
            if (TraceLogger._shouldWriteToConsole && !shouldWrite) {
                TraceLogger._logManager.removeHandler(TraceLogger._defaultLogger.log);
                TraceLogger._verboseLogManager.removeHandler(TraceLogger._defaultLogger.verbose);
            }
            else if (!TraceLogger._shouldWriteToConsole && shouldWrite) {
                TraceLogger._logManager.addHandler(TraceLogger._defaultLogger.log);
                TraceLogger._verboseLogManager.addHandler(TraceLogger._defaultLogger.verbose);
            }
            TraceLogger._shouldWriteToConsole = shouldWrite;
        },
        enumerable: true,
        configurable: true
    });
    TraceLogger.logVerboseWithLogEntry = function (source, logEntry, eventName) {
        sp_core_library_["Validate"].isNotNullOrUndefined(logEntry, 'LogEntry');
        this._log(source, logEntry.toString(), eventName, false, undefined);
    };
    TraceLogger._log = function (source, data, eventName, isError, resultCode, serviceScope) {
        var enhancedEventName = this._addEventPrefix(source, eventName);
        var logEvent;
        if (isError) {
            logEvent = Trace_LogEvent.log(enhancedEventName, data, LogLevel.Error, serviceScope);
            TraceLogger._logManager.log({ data: data, eventName: logEvent.prefix, resultCode: resultCode });
        }
        else {
            logEvent = Trace_LogEvent.log(enhancedEventName, data.toString(), LogLevel.Verbose, serviceScope);
            TraceLogger._verboseLogManager.log({ data: data, eventName: logEvent.prefix });
        }
        if (TraceLogger.shouldWriteToConsole || (true && !false)) {
            this._writeToConsole(logEvent, isError, resultCode);
        }
    };
    TraceLogger._addEventPrefix = function (source, eventName) {
        if (!eventName) {
            return source.id;
        }
        else {
            return source.id + "." + eventName;
        }
    };
    TraceLogger._writeToConsole = function (logEvent, isError, resultCode) {
        var errorString = logEvent.toString();
        if (resultCode) {
            errorString += ". resultCode: " + resultCode;
        }
        if (isError) {
            console.error(errorString);
        }
        else {
            console.log(errorString);
        }
    };
    TraceLogger._logManager = new Api_LogManager_LogManager();
    TraceLogger._verboseLogManager = new Api_LogManager_LogManager();
    TraceLogger._defaultLogger = new Trace_DefaultTraceHandler();
    TraceLogger._shouldWriteToConsole = false;
    return TraceLogger;
}());
/* harmony default export */ var Trace_TraceLogger = (TraceLogger_TraceLogger);

// CONCATENATED MODULE: ./lib/Api/LogFeature.js
var LogFeature = (function () {
    function LogFeature() {
    }
    LogFeature.None = 'None';
    return LogFeature;
}());
/* harmony default export */ var Api_LogFeature = (LogFeature);

// CONCATENATED MODULE: ./lib/Api/LogType.js
var LogType;
(function (LogType) {
    LogType[LogType["Trace"] = 1] = "Trace";
    LogType[LogType["Event"] = 2] = "Event";
    LogType[LogType["Error"] = 3] = "Error";
})(LogType || (LogType = {}));
/* harmony default export */ var Api_LogType = (LogType);

// CONCATENATED MODULE: ./lib/Api/LogEntry.js


var LogEntry_LogEntry = (function () {
    function LogEntry(moduleName, logFeature, logType, logProperties) {
        if (logFeature === void 0) { logFeature = Api_LogFeature.None; }
        if (logType === void 0) { logType = Api_LogType.Trace; }
        if (moduleName) {
            this.moduleName = moduleName;
            this.logFeature = logFeature;
            this.logType = logType;
            this.logProperties = logProperties;
        }
        else {
            throw new Error('moduleName is invalid');
        }
    }
    LogEntry.prototype.toString = function () {
        var serializedLogProps = undefined;
        if (this.logProperties) {
            try {
                serializedLogProps = JSON.stringify(this.logProperties);
            }
            catch (e) {
                console.log('Error happens in toString():' + e);
            }
        }
        return this.moduleName + " | " + this.logFeature + " | " + this.logType + " | " + serializedLogProps;
    };
    return LogEntry;
}());
/* harmony default export */ var Api_LogEntry = (LogEntry_LogEntry);

// EXTERNAL MODULE: external "@microsoft/sp-lodash-subset"
var sp_lodash_subset_ = __webpack_require__(2);
var sp_lodash_subset__default = /*#__PURE__*/__webpack_require__.n(sp_lodash_subset_);

// CONCATENATED MODULE: ./lib/DiagnosticsSettingsManager.js


var DiagnosticsSettingsManager_DiagnosticsSettingsManager = (function () {
    function DiagnosticsSettingsManager() {
    }
    DiagnosticsSettingsManager.initialize = function (settings) {
        this.settings = Object(sp_lodash_subset_["cloneDeep"])(settings);
        this._initialized = true;
        this._normalizeSiteIdWebId();
    };
    DiagnosticsSettingsManager.updateSettings = function (settings) {
        this.settings = Object(sp_lodash_subset_["merge"])(this.settings, settings);
        this._normalizeSiteIdWebId();
    };
    Object.defineProperty(DiagnosticsSettingsManager, "isInitialized", {
        get: function () {
            return this._initialized;
        },
        enumerable: true,
        configurable: true
    });
    DiagnosticsSettingsManager.shouldUseBuffer = function () {
        var shouldUse = !sp_core_library_["_SPKillSwitch"].isActivated(DiagnosticsSettingsManager.enableCircularBufferLogging, '11/27/2017', 'enableCircularBufferLogging');
        return shouldUse;
    };
    DiagnosticsSettingsManager._normalizeId = function (id) {
        var guid = sp_core_library_["Guid"].tryParse(id);
        return guid ? guid.toString() : id;
    };
    DiagnosticsSettingsManager._normalizeSiteIdWebId = function () {
        this.settings.siteId = this._normalizeId(this.settings.siteId);
        this.settings.webId = this._normalizeId(this.settings.webId);
    };
    DiagnosticsSettingsManager.enableCircularBufferLogging = sp_core_library_["Guid"].parse('4b6e1a58-3e0c-43e2-b9cb-1a470f6fe402');
    DiagnosticsSettingsManager._initialized = false;
    return DiagnosticsSettingsManager;
}());
/* harmony default export */ var lib_DiagnosticsSettingsManager = (DiagnosticsSettingsManager_DiagnosticsSettingsManager);

// CONCATENATED MODULE: ./lib/Diagnostics.js



var Diagnostics_Diagnostics = (function () {
    function Diagnostics() {
    }
    Diagnostics.initialize = function (settings) {
        if (!Diagnostics._isInitialized) {
            lib_DiagnosticsSettingsManager.initialize(settings);
            Trace_TraceLogger.shouldWriteToConsole = settings.enableConsoleLog;
            Trace_TraceLogger._addHandler({
                log: function (traceEvent) {
                    sp_core_library_["Log"].info(traceEvent.data.toString(), "EventName:" + traceEvent.eventName + ", ResultCome: " + traceEvent.resultCode);
                },
                verbose: function (traceEvent) {
                    sp_core_library_["Log"].verbose(traceEvent.data.toString(), traceEvent.eventName);
                }
            });
            Diagnostics._isInitialized = true;
        }
    };
    Object.defineProperty(Diagnostics, "isInitialized", {
        get: function () {
            return this._isInitialized;
        },
        enumerable: true,
        configurable: true
    });
    Diagnostics.updateSettings = function (settings) {
        lib_DiagnosticsSettingsManager.updateSettings(settings);
    };
    Diagnostics._isInitialized = false;
    return Diagnostics;
}());
/* harmony default export */ var lib_Diagnostics = (Diagnostics_Diagnostics);

// CONCATENATED MODULE: ./lib/Api/Engagement/DefaultEngagementHandler.js
var DefaultEngagementHandler = (function () {
    function DefaultEngagementHandler() {
    }
    DefaultEngagementHandler.prototype.logData = function (data) {
        console.log("TagName: " + data.name + ", Action Name: " + data.extraData);
    };
    return DefaultEngagementHandler;
}());
/* harmony default export */ var Engagement_DefaultEngagementHandler = (DefaultEngagementHandler);

// CONCATENATED MODULE: ./lib/Api/Engagement/EngagementLogger.js



var EngagementLogger_EngagementLogger = (function () {
    function EngagementLogger() {
    }
    EngagementLogger._addHandler = function (logger) {
        if (lib_DiagnosticsSettingsManager.shouldUseBuffer()) {
            EngagementLogger._handler = function (e) { logger.logData(e); };
            EngagementLogger._logManager.addHandler(EngagementLogger._handler);
        }
        else {
            EngagementLogger._logger = logger;
        }
    };
    EngagementLogger.startRealTimeProcessing = function () {
        if (!this._shouldProcessInRealTime) {
            EngagementLogger._logManager.processAll(EngagementLogger._handler);
            this._shouldProcessInRealTime = true;
        }
    };
    EngagementLogger.log = function (engagementData) {
        EngagementLogger._logEngagementData(engagementData);
    };
    EngagementLogger.logEvent = function (tagName, actionName) {
        var logData = { name: tagName };
        if (actionName && actionName.length !== 0) {
            logData.extraData = { action: actionName };
        }
        EngagementLogger._logEngagementData(logData);
    };
    EngagementLogger.logEventWithLogEntry = function (logEntry) {
        var logData = {
            name: logEntry.moduleName + '.' + logEntry.logFeature,
            extraData: logEntry.logProperties
        };
        EngagementLogger._logEngagementData(logData, true);
    };
    EngagementLogger._logEngagementData = function (engagementData, isLogEntry) {
        if (isLogEntry === void 0) { isLogEntry = false; }
        if (!engagementData.name || engagementData.name.length === 0) {
            throw new Error('LogEntry is invalid');
        }
        EngagementLogger._checkValidTagName(engagementData, isLogEntry);
        EngagementLogger._addContextData(engagementData);
        if (lib_DiagnosticsSettingsManager.shouldUseBuffer()) {
            EngagementLogger._logManager.log(engagementData);
        }
        else {
            EngagementLogger._logger.logData(engagementData);
        }
    };
    EngagementLogger._checkValidTagName = function (engagementData, isLogEntry) {
        if (isLogEntry === void 0) { isLogEntry = false; }
        if (!isLogEntry) {
            var tagNameRegex = /(\w+)\.(\w+).(\w+)/ig;
            if (tagNameRegex.test(engagementData.name) === false) {
                throw new Error(engagementData.name + " tagName does not follow AppName.ControlName.ActionName pattern");
            }
        }
    };
    EngagementLogger._addContextData = function (data) {
        if (lib_DiagnosticsSettingsManager.isInitialized) {
            data.siteId = lib_DiagnosticsSettingsManager.settings.siteId;
            data.webId = lib_DiagnosticsSettingsManager.settings.webId;
        }
    };
    EngagementLogger._logManager = new Api_LogManager_LogManager();
    EngagementLogger._logger = new Engagement_DefaultEngagementHandler();
    return EngagementLogger;
}());
/* harmony default export */ var Engagement_EngagementLogger = (EngagementLogger_EngagementLogger);

// CONCATENATED MODULE: ./lib/Api/ExecutionQueue.js
var ExecutionQueue = (function () {
    function ExecutionQueue() {
        this._shouldExecuteInRealTime = false;
        this._handlers = {}; 
        this._executionEntries = [];
    }
    Object.defineProperty(ExecutionQueue.prototype, "shouldExecuteInRealTime", {
        get: function () {
            return this._shouldExecuteInRealTime;
        },
        set: function (executeInRealTime) {
            this._shouldExecuteInRealTime = executeInRealTime;
            if (this._shouldExecuteInRealTime) {
                this.flush();
            }
        },
        enumerable: true,
        configurable: true
    });
    ExecutionQueue.prototype.addHandler = function (key, handler) {
        if (this._containsHandler(key, handler)) {
            return;
        }
        this._initializeHandlerArrayForKey(key);
        var handlers = this._handlers[key]; 
        if (handlers.indexOf(handler) === -1) {
            handlers.push(handler);
        }
    };
    ExecutionQueue.prototype.addExecutionEntry = function (key) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        Object.freeze(args);
        if (this._shouldExecuteInRealTime) {
            this._processExecutionEntry(key, args);
        }
        else {
            this._executionEntries.push({ key: key, args: args });
        }
    };
    ExecutionQueue.prototype.removeHandler = function (key, handler) {
        var index = this._handlers[key].indexOf(handler);
        if (index > -1) {
            this._handlers[key].splice(index, 1);
        }
    };
    ExecutionQueue.prototype.reset = function () {
        this._handlers = {};
        this._executionEntries = [];
    };
    ExecutionQueue.prototype.flush = function () {
        this._processAllExecutionEntries();
        this._executionEntries = [];
    };
    ExecutionQueue.prototype._containsHandler = function (key, handler) {
        if (this._handlers[key] !== null && this._handlers[key] !== undefined) {
            return this._handlers[key].indexOf(handler) > -1;
        }
        return false;
    };
    ExecutionQueue.prototype._initializeHandlerArrayForKey = function (key) {
        if (this._handlers[key] === null || this._handlers[key] === undefined) {
            this._handlers[key] = [];
        }
    };
    ExecutionQueue.prototype._processAllExecutionEntries = function () {
        var _this = this;
        this._executionEntries.forEach(function (entry) {
            if (entry && _this._handlers[entry.key]) {
                try {
                    _this._handlers[entry.key].forEach(function (handler) {
                        handler.apply(_this, entry.args);
                    });
                }
                catch (e) {
                    console.error('failed to process execution entry:' + e.toString());
                }
            }
        });
    };
    ExecutionQueue.prototype._processExecutionEntry = function (key, args) {
        for (var i = 0; i < this._handlers[key].length; i++) {
            try {
                this._handlers[key][i].apply(this, args);
            }
            catch (e) {
                console.error('failed to process execution entry:' + e.toString());
            }
        }
    };
    return ExecutionQueue;
}());
/* harmony default export */ var Api_ExecutionQueue = (ExecutionQueue);

// CONCATENATED MODULE: ./lib/Api/Qos/QosLogger.js


var QosLogger_QosLogger = (function () {
    function QosLogger() {
        this._qosEvents = new Map();
        this._deferExecutor = new Api_ExecutionQueue();
        this._shouldProcessInRealTime = false;
        this.initializeLogger();
    }
    Object.defineProperty(QosLogger, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new QosLogger();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QosLogger.prototype, "shouldProcessInRealTime", {
        get: function () {
            return this._shouldProcessInRealTime;
        },
        set: function (processInRealTime) {
            this._shouldProcessInRealTime = processInRealTime;
            this._deferExecutor.shouldExecuteInRealTime = processInRealTime;
        },
        enumerable: true,
        configurable: true
    });
    QosLogger.prototype.setLogger = function (qosLogger) {
        this._qosLogger = qosLogger;
    };
    QosLogger.prototype.getQosEvent = function (key) {
        return this._qosEvents.get(key);
    };
    QosLogger.prototype.startQosMonitor = function (key, startData) {
        if (!this._qosEvents.has(key)) {
            if (lib_DiagnosticsSettingsManager.shouldUseBuffer()) {
                this._deferExecutor.addExecutionEntry('start', key, startData);
            }
            else {
                this._startMonitor(key, startData);
            }
        }
    };
    QosLogger.prototype.writeQosEndResult = function (key, endData) {
        if (lib_DiagnosticsSettingsManager.shouldUseBuffer()) {
            this._deferExecutor.addExecutionEntry('end', key, endData);
        }
        else {
            this._endMonitor(key, endData);
        }
    };
    QosLogger.prototype._startMonitor = function (key, event) {
        if (this._qosLogger) {
            this._qosEvents.set(key, new this._qosLogger(event)); 
        }
    };
    QosLogger.prototype._endMonitor = function (key, event) {
        if (this._qosEvents.has(key)) {
            this._qosEvents.get(key).end(event); 
            this._qosEvents.delete(key);
        }
    };
    QosLogger.prototype.initializeLogger = function () {
        var _this = this;
        var startHandler = function (key, e) { _this._startMonitor(key, e); }; 
        var endHandler = function (key, e) { _this._endMonitor(key, e); }; 
        this._deferExecutor.addHandler('start', startHandler);
        this._deferExecutor.addHandler('end', endHandler);
    };
    return QosLogger;
}());
/* harmony default export */ var Qos_QosLogger = (QosLogger_QosLogger);

// CONCATENATED MODULE: ./lib/Api/Qos/QosMonitor.js





var QosMonitor_QosMonitor = (function () {
    function QosMonitor(scenarioName, copyToEngagement) {
        if (copyToEngagement === void 0) { copyToEngagement = false; }
        this._qosResultTypeValue = (_a = {},
            _a[0 ] = 'Success',
            _a[1 ] = 'Failure',
            _a[2 ] = 'ExpectedFailure',
            _a);
        sp_core_library_["Validate"].isNonemptyString(scenarioName, 'scenarioName');
        this._id = sp_core_library_["Guid"].newGuid().toString();
        Qos_QosLogger.instance.startQosMonitor(this._id, { name: scenarioName });
        this._scenarioName = scenarioName;
        this._hasEnded = false;
        this._copyToEngagement = copyToEngagement;
        var _a;
    }
    QosMonitor.startRealTimeProcessing = function () {
        if (!Qos_QosLogger.instance.shouldProcessInRealTime) {
            this._shouldProcessInRealTime(true);
        }
    };
    QosMonitor._shouldProcessInRealTime = function (processInRealTime) {
        Qos_QosLogger.instance.shouldProcessInRealTime = processInRealTime;
    };
    Object.defineProperty(QosMonitor.prototype, "name", {
        get: function () {
            return lib_DiagnosticsSettingsManager.shouldUseBuffer() ? this._scenarioName : Qos_QosLogger.instance.getQosEvent(this._id).data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "shortEventName", {
        get: function () {
            return lib_DiagnosticsSettingsManager.shouldUseBuffer() ? 'Qos' : Qos_QosLogger.instance.getQosEvent(this._id).shortEventName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "resultCode", {
        get: function () {
            return lib_DiagnosticsSettingsManager.shouldUseBuffer() ? this._endResultCode : Qos_QosLogger.instance.getQosEvent(this._id).data.resultCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "resultType", {
        get: function () {
            return lib_DiagnosticsSettingsManager.shouldUseBuffer() ? this._endResult : Qos_QosLogger.instance.getQosEvent(this._id).data.resultType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "extraData", {
        get: function () {
            return lib_DiagnosticsSettingsManager.shouldUseBuffer() ? this._endExtraData : Qos_QosLogger.instance.getQosEvent(this._id).data.extraData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "hasEnded", {
        get: function () {
            return this._hasEnded;
        },
        enumerable: true,
        configurable: true
    });
    QosMonitor.prototype.writeSuccess = function (extraData) {
        this._writeQosEnd(0 , undefined, undefined, extraData);
    };
    QosMonitor.prototype.writeUnexpectedFailure = function (tagNameSuffix, ex, extraData) {
        if (tagNameSuffix === void 0) { tagNameSuffix = 'DefaultUnexpected'; }
        this._writeQosEnd(1 , tagNameSuffix, ex, extraData);
    };
    QosMonitor.prototype.writeExpectedFailure = function (tagNameSuffix, ex, extraData) {
        if (tagNameSuffix === void 0) { tagNameSuffix = 'DefaultExpected'; }
        this._writeQosEnd(2 , tagNameSuffix, ex, extraData);
    };
    QosMonitor.prototype._writeQosEnd = function (resultType, tagNameSuffix, ex, extraData) {
        if (!Qos_QosLogger.instance.getQosEvent(this._id) && !lib_DiagnosticsSettingsManager.shouldUseBuffer()) {
            throw new Error('monitor instance is null or undefined');
        }
        if (!this._shouldSkip(resultType)) {
            this._endResultCode = tagNameSuffix;
            this._endExtraData = extraData;
            this._endResult = resultType;
            var endData = {
                resultCode: this._endResultCode,
                resultType: this._endResult,
                error: ex ? ex.message : undefined,
                extraData: this._endExtraData
            };
            Qos_QosLogger.instance.writeQosEndResult(this._id, endData);
            this._writeToEngagement();
        }
    };
    QosMonitor.prototype._shouldSkip = function (result) {
        if (this._hasEnded && (this._endResult !== undefined)) {
            var message = sp_core_library_["Text"].format(QosMonitor.qosMonitorHasEndedErrorString, this.name, this._qosResultTypeValue[this._endResult], this._qosResultTypeValue[result]);
            if (this._endResult !== result) {
                Trace_TraceLogger.logError(QosMonitor.logSource, new Error(message));
            }
            if (true) {
                Trace_TraceLogger.logVerbose(QosMonitor.logSource, message, 'skipEnd');
            }
            return true;
        }
        else {
            this._hasEnded = true;
            return false;
        }
    };
    QosMonitor.prototype._writeToEngagement = function () {
        if (this._shouldWriteToEngagement()) {
            var engagementData = {
                name: 'Spfx.Qos.ToEngagement',
                extraData: this.extraData || {}
            };
            engagementData.extraData['qosName'] = this.name;
            if (this.resultType) {
                engagementData.extraData['qosResultType'] = this._qosResultTypeValue[this.resultType];
            }
            if (this.resultCode) {
                engagementData.extraData['qosResultCode'] = this.resultCode;
            }
            Engagement_EngagementLogger.log(engagementData);
        }
    };
    QosMonitor.prototype._shouldWriteToEngagement = function () {
        var shouldWriteEngagement = this._copyToEngagement &&
            (lib_DiagnosticsSettingsManager.shouldUseBuffer() || !!Qos_QosLogger.instance.getQosEvent(this._id).data);
        return shouldWriteEngagement;
    };
    QosMonitor.logSource = {
        id: 'QosMonitor'
    };
    QosMonitor.qosMonitorHasEndedErrorString = 'QoS monitor \'{0}\' has ended with \'{1}\' already. Ignoring \'{2}\' tag.';
    return QosMonitor;
}());
/* harmony default export */ var Qos_QosMonitor = (QosMonitor_QosMonitor);

// CONCATENATED MODULE: ./lib/index.js
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_TraceLogger", function() { return Trace_TraceLogger; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_LogEntry", function() { return Api_LogEntry; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_LogFeature", function() { return Api_LogFeature; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_LogSource", function() { return Api_LogSource; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_logSourceServiceKey", function() { return logSourceServiceKey; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_LogType", function() { return Api_LogType; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_Diagnostics", function() { return lib_Diagnostics; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_LogEvent", function() { return Trace_LogEvent; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_LogLevel", function() { return LogLevel; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_CircularBuffer", function() { return LogManager_CircularBuffer; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_LogManager", function() { return Api_LogManager_LogManager; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_EngagementLogger", function() { return Engagement_EngagementLogger; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_QosMonitor", function() { return Qos_QosMonitor; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_QosLogger", function() { return Qos_QosLogger; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "_ExecutionQueue", function() { return Api_ExecutionQueue; });
















/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ })
/******/ ])});;
//# sourceMappingURL=sp-diagnostics.js.map