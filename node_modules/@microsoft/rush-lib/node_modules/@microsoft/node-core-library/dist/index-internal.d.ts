/**
 * Core libraries that every NodeJS toolchain project should use.
 * 
 * @packagedocumentation
 */


/**
 * String constants for common filenames and parts of filenames.
 *
 * @public
 */
export declare const enum FileConstants {
    /**
     * "package.json" - the configuration file that defines an NPM package
     */
    PackageJson = "package.json",
}

/**
 * Implements a unit testing strategy that generates output files, and then
 * compares them against the expected input.  If the files are different, then
 * the test fails.
 *
 * @public
 */
export declare class FileDiffTest {
    private static _packageJsonLookup;
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    static clearCache(): void;
    /**
     * Sets up a folder in the temp directory where the unit test should write its output files
     * to be diffed.  Any previous contents of the folder will be deleted.
     *
     * @param unitTestDirName - the "__dirname" variable, evaluated in the context of the unit test
     * @param testModule - the name of the class being unit tested; must contain only letters, numbers, and underscores.
     * @returns A fully qualified path of the folder where the unit test should write its output
     */
    static prepareFolder(unitTestDirName: string, testModule: string): string;
    /**
     * Compares the contents of two files, and returns true if they are equivalent.
     * Note that these files are not normally edited by a human; the "equivalence"
     * comparison here is intended to ignore spurious changes that might be introduced
     * by a tool, e.g. Git newline normalization or an editor that strips
     * whitespace when saving.
     */
    static assertEqual(actualFilePath: string, expectedFilePath: string): void;
    private static _getNormalizedContent(s);
}

/**
 * String constants for common folder names.
 *
 * @public
 */
export declare const enum FolderConstants {
    /**
     * ".git" - the data storage for a Git working folder
     */
    Git = ".git",
    /**
     * "node_modules" - the folder where package managers install their files
     */
    NodeModules = "node_modules",
}

/**
 * Options for JsonFile.saveJsonFile()
 *
 * @public
 */
export declare interface IJsonFileSaveOptions extends IJsonFileStringifyOptions {
    /**
     * If there is an existing file, and the contents have not changed, then
     * don't write anything; this preserves the old timestamp.
     */
    onlyIfChanged?: boolean;
}

/**
 * Options for JsonFile.stringify()
 *
 * @public
 */
export declare interface IJsonFileStringifyOptions {
    /**
     * If true, then "\n" will be used for newlines instead of the default "\r\n".
     */
    unixNewlines?: boolean;
}

/**
 * Callback function arguments for JsonSchema.validateObjectWithCallback();
 * @public
 */
export declare interface IJsonSchemaErrorInfo {
    /**
     * The z-schema error tree, formatted as an indented text string.
     */
    details: string;
}

/**
 * Options for JsonSchema.fromFile()
 * @public
 */
export declare interface IJsonSchemaFromFileOptions {
    /**
     * Other schemas that this schema references, e.g. via the "$ref" directive.
     * @remarks
     * The tree of dependent schemas may reference the same schema more than once.
     * However, if the same schema "id" is used by two different JsonSchema instances,
     * an error will be reported.  This means you cannot load the same filename twice
     * and use them both together, and you cannot have diamond dependencies on different
     * versions of the same schema.  Although technically this would be possible to support,
     * it normally indicates an error or design problem.
     *
     * JsonSchema also does not allow circular references between schema dependencies.
     */
    dependentSchemas?: JsonSchema[];
}

/**
 * Options for JsonSchema.validateObject()
 * @public
 */
export declare interface IJsonSchemaValidateOptions {
    /**
     * A custom header that will be used to report schema errors.
     * @remarks
     * If omitted, the default header is "JSON validation failed:".  The error message starts with
     * the header, followed by the full input filename, followed by the z-schema error tree.
     * If you wish to customize all aspects of the error message, use JsonFile.loadAndValidateWithCallback()
     * or JsonSchema.validateObjectWithCallback().
     */
    customErrorHeader?: string;
}

/**
 * An interface for accessing common fields from a package.json file.
 *
 * @remarks
 * More fields may be added to this interface in the future.  Most fields are optional.
 * For documentation about this file format, see the
 * {@link http://wiki.commonjs.org/wiki/Packages/1.0 | CommonJS Packages specification}
 * and the {@link https://docs.npmjs.com/files/package.json | NPM manual page}.
 * @public
 */
export declare interface IPackageJson {
    /**
     * The name of the package.
     */
    name: string;
    /**
     * A version number conforming to the Semantic Versioning (SemVer) standard.
     */
    version: string;
    /**
     * Indicates whether this package is allowed to be published or not.
     */
    private?: boolean;
    /**
     * A brief description of the package.
     */
    description?: string;
    /**
     * The URL to the project's web page.
     */
    homepage?: string;
    /**
     * The name of the license.
     */
    license?: string;
    /**
     * The path to the module file that will act as the main entry point.
     */
    main?: string;
    /**
     * The path to the TypeScript *.d.ts file describing the module file
     * that will act as the main entry point.
     */
    typings?: string;
    /**
     * Describes the documentation comment syntax used for the *.d.ts files
     * exposed by this package.
     * @beta
     */
    tsdoc?: IPackageJsonTsdocConfiguration;
    /**
     * The main entry point for the package.
     */
    bin?: string;
    /**
     * An array of dependencies that must always be installed for this package.
     */
    dependencies?: IPackageJsonDependencyTable;
    /**
     * An array of optional dependencies that may be installed for this package.
     */
    optionalDependencies?: IPackageJsonDependencyTable;
    /**
     * An array of dependencies that must only be installed for developers who will
     * build this package.
     */
    devDependencies?: IPackageJsonDependencyTable;
    /**
     * An array of dependencies that must be installed by a consumer of this package,
     * but which will not be automatically installed by this package.
     */
    peerDependencies?: IPackageJsonDependencyTable;
    /**
     * A table of script hooks that a package manager or build tool may invoke.
     */
    scripts?: IPackageJsonScriptTable;
}

/**
 * This interface is part of the IPackageJson file format.  It is used for the
 * "dependencies", "optionalDependencies", and "devDependencies" fields.
 * @public
 */
export declare interface IPackageJsonDependencyTable {
    /**
     * The key is the name of a dependency.  The value is a Semantic Versioning (SemVer)
     * range specifier.
     */
    [dependencyName: string]: string;
}

/**
 * Constructor parameters for {@link PackageJsonLookup}
 *
 * @public
 */
export declare interface IPackageJsonLookupParameters {
    /**
     * Certain package.json fields such as "contributors" can be very large, and may
     * significantly increase the memory footprint for the PackageJsonLookup cache.
     * By default, PackageJsonLookup only loads a subset of standard commonly used
     * fields names.  Set loadExtraFields=true to always return all fields.
     */
    loadExtraFields?: boolean;
}

/**
 * This interface is part of the IPackageJson file format.  It is used for the
 * "scripts" field.
 * @public
 */
export declare interface IPackageJsonScriptTable {
    /**
     * The key is the name of the script hook.  The value is the script body which may
     * be a file path or shell script command.
     */
    [scriptName: string]: string;
}

/**
 * This interface is part of the IPackageJson file format.  It is used for the
 * "tsdoc" field.
 * @beta
 */
export declare interface IPackageJsonTsdocConfiguration {
    /**
     * A token indicating the dialect of TSDoc syntax used by *.d.ts files in this
     * package.
     */
    tsdocFlavor?: string;
}

/**
 * A package name that has been separated into its scope and unscoped name.
 *
 * @public
 */
export declare interface IParsedPackageName {
    /**
     * The parsed NPM scope, or an empty string if there was no scope.  The scope value will
     * always include the at-sign.
     * @remarks
     * For example, if the parsed input was "\@scope/example", then scope would be "\@scope".
     */
    scope: string;
    /**
     * The parsed NPM package name without the scope.
     * @remarks
     * For example, if the parsed input was "\@scope/example", then the name would be "example".
     */
    unscopedName: string;
}

/**
 * Result object returned by {@link PackageName.tryParse}
 *
 * @public
 */
export declare interface IParsedPackageNameOrError extends IParsedPackageName {
    /**
     * If the input string could not be parsed, then this string will contain a nonempty
     * error message.  Otherwise it will be an empty string.
     */
    error: string;
}

/**
 * Constructor parameters for {@link ProtectableMap}
 *
 * @public
 */
export declare interface IProtectableMapParameters<K, V> {
    /**
     * An optional hook that will be invoked before Map.clear() is performed.
     */
    onClear?: (source: ProtectableMap<K, V>) => void;
    /**
     * An optional hook that will be invoked before Map.delete() is performed.
     */
    onDelete?: (source: ProtectableMap<K, V>, key: K) => void;
    /**
     * An optional hook that will be invoked before Map.set() is performed.
     * @remarks
     * If this hook is provided, the function MUST return the `value` parameter.
     * This provides the opportunity to modify the value before it is added
     * to the map.
     */
    onSet?: (source: ProtectableMap<K, V>, key: K, value: V) => V;
}

/**
 * Utilities for reading/writing JSON files.
 * @public
 */
export declare class JsonFile {
    /**
     * Loads a JSON file.
     */
    static load(jsonFilename: string): any;
    /**
     * Loads a JSON file and validate its schema.
     */
    static loadAndValidate(jsonFilename: string, jsonSchema: JsonSchema, options?: IJsonSchemaValidateOptions): any;
    /**
     * Loads a JSON file and validate its schema, reporting errors using a callback
     * @remarks
     * See JsonSchema.validateObjectWithCallback() for more info.
     */
    static loadAndValidateWithCallback(jsonFilename: string, jsonSchema: JsonSchema, errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): any;
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static stringify(jsonObject: Object, options?: IJsonFileStringifyOptions): string;
    /**
     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
     * @param jsonObject - the object to be saved
     * @param jsonFilename - the file path to write
     * @param options - other settings that control how the file is saved
     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
     */
    static save(jsonObject: Object, jsonFilename: string, options?: IJsonFileSaveOptions): boolean;
    /**
     * Used to validate a data structure before writing.  Reports an error if there
     * are any undefined members.
     */
    static validateNoUndefinedMembers(jsonObject: Object): void;
    private static _validateNoUndefinedMembers(jsonObject, keyPath);
    private static _formatKeyPath(keyPath);
}

/**
 * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.
 * @remarks
 * The schema itself is normally loaded and compiled later, only if it is actually required to validate
 * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls
 * JsonSchema.ensureCompiled() for each of your schema objects.
 *
 * @public
 */
export declare class JsonSchema {
    private _dependentSchemas;
    private _filename;
    private _validator;
    private _schemaObject;
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromFile(filename: string, options?: IJsonSchemaFromFileOptions): JsonSchema;
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromLoadedObject(schemaObject: Object): JsonSchema;
    private static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds);
    /**
     * Used to nicely format the ZSchema error tree.
     */
    private static _formatErrorDetails(errorDetails);
    /**
     * Used by _formatErrorDetails.
     */
    private static _formatErrorDetailsHelper(errorDetails, indent, buffer);
    /**
     * Returns a short name for this schema, for use in error messages.
     * @remarks
     * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
     * field is used if available.
     */
    readonly shortName: string;
    /**
     * If not already done, this loads the schema from disk and compiles it.
     * @remarks
     * Any dependencies will be compiled as well.
     */
    ensureCompiled(): void;
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * an exception will be thrown.
     * @param jsonObject - The JSON data to be validated
     * @param filenameForErrors - The filename that the JSON data was available, or an empty string
     *    if not applicable
     * @param options - Other options that control the validation
     */
    validateObject(jsonObject: Object, filenameForErrors: string, options?: IJsonSchemaValidateOptions): void;
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * a callback is called for each validation error.
     */
    validateObjectWithCallback(jsonObject: Object, errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): void;
    private constructor();
    private _ensureLoaded();
}

/**
 * A helper utility for working with file-based locks.
 * This class should only be used for locking resources across processes,
 * but should not be used for attempting to lock a resource in the same process.
 * @public
 */
export declare class LockFile {
    private _fileDescriptor;
    private _filePath;
    private _dirtyWhenAcquired;
    private static _getStartTime;
    /**
     * Returns the path to the lockfile, should it be created successfully.
     */
    static getLockFilePath(resourceDir: string, resourceName: string, pid?: number): string;
    /**
     * Attempts to create a lockfile with the given filePath.
     * If successful, returns a LockFile instance.
     * If unable to get a lock, returns undefined.
     * @param resourceName - the name of the resource we are locking on. Should be an alphabetic string.
     */
    static tryAcquire(resourceDir: string, resourceName: string): LockFile | undefined;
    /**
     * Attempts to create the lockfile.
     * Will continue to loop at every 100ms until the lock becomes available or the maxWaitMs is surpassed.
     * @remarks This function is subject to starvation, whereby it does not ensure that the process that has been
     *          waiting the longest to acquire the lock will get it first. This means that a process could theoretically
     *          wait for the lock forever, while other processes skipped it in line and acquired the lock first.
     */
    static acquire(resourceDir: string, resourceName: string, maxWaitMs?: number): Promise<LockFile>;
    private static _sleepForMs(timeout);
    /**
     * Attempts to acquire the lock on a Linux or OSX machine
     */
    private static _tryAcquireMacOrLinux(resourceDir, resourceName);
    /**
     * Attempts to acquire the lock using Windows
     * This algorithm is much simpler since we can rely on the operating system
     */
    private static _tryAcquireWindows(resourceDir, resourceName);
    /**
     * Unlocks a file and removes it from disk.
     * This can only be called once.
     */
    release(): void;
    /**
     * Returns the initial state of the lock.
     * This can be used to detect if the previous process was terminated before releasing the resource.
     */
    readonly dirtyWhenAcquired: boolean;
    /**
     * Returns the absolute path to the lockfile
     */
    readonly filePath: string;
    /**
     * Returns true if this lock is currently being held.
     */
    readonly isReleased: boolean;
    private constructor();
}

/**
 * Helper functions for working with the Map<K,V> data type.
 *
 * @public
 */
export declare class MapExtensions {
    /**
     * Adds all the (key, value) pairs from the source map into the target map.
     * @remarks
     * This function modifies targetMap.  Any existing keys will be overwritten.
     * @param targetMap - The map that entries will be added to
     * @param sourceMap - The map containing the entries to be added
     */
    static mergeFromMap<K, V>(targetMap: Map<K, V>, sourceMap: Map<K, V>): void;
}

/**
 * This class provides methods for finding the nearest "package.json" for a folder
 * and retrieving the name of the package.  The results are cached.
 *
 * @public
 */
export declare class PackageJsonLookup {
    private _loadExtraFields;
    private _packageFolderCache;
    private _packageJsonCache;
    constructor(parameters?: IPackageJsonLookupParameters);
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    clearCache(): void;
    /**
     * Returns the absolute path of a folder containing a package.json file, by looking
     * upwards from the specified fileOrFolderPath.  If no package.json can be found,
     * undefined is returned.
     *
     * @remarks
     * The fileOrFolderPath is not required to actually exist on disk.
     * The fileOrFolderPath itself can be the return value, if it is a folder containing
     * a package.json file.
     * Both positive and negative lookup results are cached.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to a folder containing a package.json file
     */
    tryGetPackageFolderFor(fileOrFolderPath: string): string | undefined;
    /**
     * If the specified file or folder is part of a package, this returns the absolute path
     * to the associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to * package.json file
     */
    tryGetPackageJsonFilePathFor(fileOrFolderPath: string): string | undefined;
    /**
     * If the specified file or folder is part of a package, this loads and returns the
     * associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
     * belong to a package
     */
    tryLoadPackageJsonFor(fileOrFolderPath: string): IPackageJson | undefined;
    /**
     * Loads the specified package.json file, if it is not already present in the cache.
     *
     * @remarks
     * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
     * the returned IPackageJson object will contain a subset of essential fields.
     * The returned object should be considered to be immutable; the caller must never
     * modify it.
     *
     * @param jsonFilename - a relative or absolute path to a package.json file
     */
    loadPackageJson(jsonFilename: string): IPackageJson;
    private _tryGetPackageFolderFor(resolvedFileOrFolderPath);
}

/**
 * Various functions for working with package names that may include scopes.
 *
 * @public
 */
export declare class PackageName {
    private static readonly invalidNameCharactersRegExp;
    /**
     * This attempts to parse a package name that may include a scope component.
     * @remarks
     * This function will not throw an exception.
     *
     * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
     * nonempty if the string could not be parsed.
     */
    static tryParse(packageName: string): IParsedPackageNameOrError;
    /**
     * Same as {@link PackageName.tryParse}, except this throws an exception if the input
     * cannot be parsed
     */
    static parse(packageName: string): IParsedPackageName;
    /**
     * {@inheritdoc IParsedPackageName.scope}
     */
    static getScope(packageName: string): string;
    /**
     * {@inheritdoc IParsedPackageName.unscopedName}
     */
    static getUnscopedName(packageName: string): string;
    /**
     * Returns true if the specified package name is valid, or false otherwise.
     * @remarks
     * This function will not throw an exception.
     */
    static isValidName(packageName: string): boolean;
    /**
     * Throws an exception if the specified name is not a valid package name.
     */
    static validate(packageName: string): void;
    /**
     * Combines an optional package scope with an unscoped root name.
     * @param scope - Must be either an empty string, or a scope name such as "\@example"
     * @param unscopedName - Must be a nonempty package name that does not contain a scope
     * @returns A full package name such as "\@example/some-library".
     */
    static combineParts(scope: string, unscopedName: string): string;
}

/**
 * Common operations for manipulating file and directory paths.
 * @remarks
 * This API is intended to eventually be a complete replacement for the NodeJS "path" API.
 * @public
 */
export declare class Path {
    /**
     * Returns true if childPath refers to a location under parentFolderPath.
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnder(childPath: string, parentFolderPath: string): boolean;
}

/**
 * The ProtectableMap provides an easy way for an API to expose a Map<K, V> property
 * while intercepting and validating any write operations that are performed by
 * consumers of the API.
 *
 * @remarks
 * The ProtectableMap itself is intended to be a private object that only its owner
 * can access directly.  Any operations performed directly on the ProtectableMap will
 * bypass the hooks and any validation they perform.  The public property that is exposed
 * to API consumers should return {@link ProtectableMap.protectedView} instead.
 *
 * For example, suppose you want to share your Map<string,number> data structure,
 * but you want to enforce that the key must always be an upper case string:
 * You could use the onSet() hook to validate the keys and throw an exception
 * if the key is not uppercase.
 *
 * @public
 */
export declare class ProtectableMap<K, V> {
    private readonly _protectedView;
    constructor(parameters: IProtectableMapParameters<K, V>);
    /**
     * The owner of the protectable map should return this object via its public API.
     */
    readonly protectedView: Map<K, V>;
    /**
     * Removes all entries from the map.
     * This operation does NOT invoke the ProtectableMap onClear() hook.
     */
    clear(): void;
    /**
     * Removes the specified key from the map.
     * This operation does NOT invoke the ProtectableMap onDelete() hook.
     */
    delete(key: K): boolean;
    /**
     * Sets a value for the specified key.
     * This operation does NOT invoke the ProtectableMap onSet() hook.
     */
    set(key: K, value: V): this;
    /**
     * Performs an operation for each (key, value) entries in the map.
     */
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
    /**
     * Retrieves the value for the specified key.
     * @returns undefined if the value is undefined OR if the key is missing;
     * otherwise returns the value associated with the key.
     */
    get(key: K): V | undefined;
    /**
     * Returns true if the specified key belongs to the map.
     */
    has(key: K): boolean;
    /**
     * Returns the number of (key, value) entries in the map.
     */
    readonly size: number;
}

/**
 * Operations for working with strings that contain text.
 *
 * @remarks
 * The utilities provided by this class are intended to be simple, small, and very
 * broadly applicable.
 *
 * @public
 */
export declare class Text {
    private static readonly _newLineRegEx;
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param input         - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static replaceAll(input: string, searchValue: string, replaceValue: string): string;
    /**
     * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
     */
    static convertToCrLf(input: string): string;
    /**
     * Converts all newlines in the provided string to use Unix-style LF end of line characters.
     */
    static convertToLf(input: string): string;
}
