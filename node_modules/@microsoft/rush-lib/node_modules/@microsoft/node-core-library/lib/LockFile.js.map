{"version":3,"sources":["LockFile.ts"],"names":[],"mappings":"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","file":"LockFile.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as fsx from 'fs-extra';\r\nimport * as path from 'path';\r\nimport * as child_process from 'child_process';\r\nimport { setTimeout } from 'timers';\r\n\r\n/**\r\n * Helper function that is exported for unit tests only.\r\n * Returns undefined if the process doesn't exist with that pid.\r\n */\r\nexport function getProcessStartTime(pid: number): string | undefined {\r\n  let args: string[];\r\n  if (process.platform === 'darwin') {\r\n    args = [`-p ${pid.toString()}`, '-o lstart'];\r\n  } else if (process.platform === 'linux') {\r\n    args = ['-p', pid.toString(), '-o', 'lstart'];\r\n  } else {\r\n    throw new Error(`Unsupported system: ${process.platform}`);\r\n  }\r\n\r\n  const psResult: string = child_process.spawnSync('ps', args).stdout.toString();\r\n\r\n  // there was an error executing psresult\r\n  if (!psResult) {\r\n    throw new Error(`Unexpected output from \"ps\" command`);\r\n  }\r\n\r\n  const psSplit: string[] = psResult.split('\\n');\r\n\r\n  // successfuly able to run \"ps\", but no process was found\r\n  if (psSplit[1] === '') {\r\n    return undefined;\r\n  }\r\n\r\n  if (psSplit[1]) {\r\n    const trimmed: string = psSplit[1].trim();\r\n    if (trimmed.length > 10) {\r\n      return trimmed;\r\n    }\r\n  }\r\n\r\n  throw new Error(`Unexpected output from the \"ps\" command`);\r\n}\r\n\r\n/**\r\n * A helper utility for working with file-based locks.\r\n * This class should only be used for locking resources across processes,\r\n * but should not be used for attempting to lock a resource in the same process.\r\n * @public\r\n */\r\nexport class LockFile {\r\n  private static _getStartTime: (pid: number) => string | undefined = getProcessStartTime;\r\n\r\n  /**\r\n   * Returns the path to the lockfile, should it be created successfully.\r\n   */\r\n  public static getLockFilePath(resourceDir: string, resourceName: string, pid: number = process.pid): string {\r\n    if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {\r\n      throw new Error(`The resource name \"${resourceName}\" is invalid.`\r\n        + ` It must be an alphanumberic string with only \"-\" or \".\" It must start with an alphanumeric character.`);\r\n    }\r\n\r\n    if (process.platform === 'win32') {\r\n      return path.join(path.resolve(resourceDir), `${resourceName}.lock`);\r\n    } else if (process.platform === 'linux' || process.platform === 'darwin') {\r\n      return path.join(path.resolve(resourceDir), `${resourceName}#${pid}.lock`);\r\n    }\r\n\r\n    throw new Error(`File locking not implemented for platform: \"${process.platform}\"`);\r\n  }\r\n\r\n  /**\r\n   * Attempts to create a lockfile with the given filePath.\r\n   * If successful, returns a LockFile instance.\r\n   * If unable to get a lock, returns undefined.\r\n   * @param resourceName - the name of the resource we are locking on. Should be an alphabetic string.\r\n   */\r\n  public static tryAcquire(resourceDir: string, resourceName: string): LockFile | undefined {\r\n    fsx.mkdirsSync(resourceDir);\r\n    if (process.platform === 'win32') {\r\n      return LockFile._tryAcquireWindows(resourceDir, resourceName);\r\n    } else if (process.platform === 'linux' || process.platform === 'darwin') {\r\n      return LockFile._tryAcquireMacOrLinux(resourceDir, resourceName);\r\n    }\r\n    throw new Error(`File locking not implemented for platform: \"${process.platform}\"`);\r\n  }\r\n\r\n  /**\r\n   * Attempts to create the lockfile.\r\n   * Will continue to loop at every 100ms until the lock becomes available or the maxWaitMs is surpassed.\r\n   * @remarks This function is subject to starvation, whereby it does not ensure that the process that has been\r\n   *          waiting the longest to acquire the lock will get it first. This means that a process could theoretically\r\n   *          wait for the lock forever, while other processes skipped it in line and acquired the lock first.\r\n   */\r\n  public static acquire(resourceDir: string, resourceName: string, maxWaitMs?: number): Promise<LockFile> {\r\n    const interval: number = 100;\r\n    const startTime: number = Date.now();\r\n\r\n    const retryLoop: () => Promise<LockFile> = () => {\r\n      const lock: LockFile | undefined = LockFile.tryAcquire(resourceDir, resourceName);\r\n      if (lock) {\r\n        return Promise.resolve(lock);\r\n      }\r\n      if (maxWaitMs && (Date.now() > startTime + maxWaitMs)) {\r\n        return Promise.reject(new Error(`Exceeded maximum wait time to acquire lock for resource \"${resourceName}\"`));\r\n      }\r\n\r\n      return LockFile._sleepForMs(interval).then(() => {\r\n        return retryLoop();\r\n      });\r\n    };\r\n\r\n    return retryLoop();\r\n  }\r\n\r\n  private static _sleepForMs(timeout: number): Promise<void> {\r\n    return new Promise<void>((resolve: () => void, reject: () => void) => {\r\n      setTimeout(() => {\r\n        resolve();\r\n      }, timeout);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Attempts to acquire the lock on a Linux or OSX machine\r\n   */\r\n  private static _tryAcquireMacOrLinux(resourceDir: string, resourceName: string): LockFile | undefined {\r\n    let dirtyWhenAcquired: boolean = false;\r\n\r\n    // get the current process' pid\r\n    const pid: number = process.pid;\r\n    const startTime: string | undefined = LockFile._getStartTime(pid);\r\n\r\n    if (!startTime) {\r\n      throw new Error(`Unable to calculate start time for current process.`);\r\n    }\r\n\r\n    const pidLockFilePath: string = LockFile.getLockFilePath(resourceDir, resourceName);\r\n    let lockFileDescriptor: number | undefined;\r\n\r\n    let lockFile: LockFile;\r\n\r\n    try {\r\n      // open in write mode since if this file exists, it cannot be from the current process\r\n      // TODO: This will malfunction if the same process tries to acquire two locks on the same file.\r\n      // We should ideally maintain a dictionary of normalized acquired filenames\r\n      lockFileDescriptor = fsx.openSync(pidLockFilePath, 'w');\r\n      fsx.writeSync(lockFileDescriptor, startTime);\r\n\r\n      const currentBirthTimeMs: number = fsx.statSync(pidLockFilePath).birthtime.getTime();\r\n\r\n      let smallestBirthTimeMs: number = currentBirthTimeMs;\r\n      let smallestBirthTimePid: string = pid.toString();\r\n\r\n      // now, scan the directory for all lockfiles\r\n      const files: string[] = fsx.readdirSync(resourceDir);\r\n\r\n      // look for anything ending with # then numbers and \".lock\"\r\n      const lockFileRegExp: RegExp = /^(.+)#([0-9]+)\\.lock$/;\r\n\r\n      let match: RegExpMatchArray | null;\r\n      let otherPid: string;\r\n      for (const fileInFolder of files) {\r\n        if ((match = fileInFolder.match(lockFileRegExp))\r\n          && (match[1] === resourceName)\r\n          && ((otherPid = match[2]) !== pid.toString())) {\r\n\r\n          // we found at least one lockfile hanging around that isn't ours\r\n          const fileInFolderPath: string = path.join(resourceDir, fileInFolder);\r\n          dirtyWhenAcquired = true;\r\n\r\n          // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);\r\n\r\n          const otherPidCurrentStartTime: string | undefined = LockFile._getStartTime(parseInt(otherPid, 10));\r\n\r\n          let otherPidOldStartTime: string | undefined;\r\n          try {\r\n            otherPidOldStartTime = fsx.readFileSync(fileInFolderPath).toString();\r\n          } catch (err) {\r\n            // this means the file is probably deleted already\r\n          }\r\n\r\n          // check the timestamp of the file\r\n          const otherBirthtimeMs: number = fsx.statSync(fileInFolderPath).birthtime.getTime();\r\n\r\n          // if the otherPidOldStartTime is invalid, then we should look at the timestamp,\r\n          // if this file was created after us, ignore it\r\n          // if it was created within 1 second before us, then it could be good, so we\r\n          //  will conservatively fail\r\n          // otherwise it is an old lock file and will be deleted\r\n          if (otherPidOldStartTime === '') {\r\n            if (otherBirthtimeMs > currentBirthTimeMs) {\r\n              // ignore this file, he will be unable to get the lock since this process\r\n              // will hold it\r\n              // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);\r\n              continue;\r\n            } else if (otherBirthtimeMs - currentBirthTimeMs < 0        // it was created before us AND\r\n              && otherBirthtimeMs - currentBirthTimeMs > -1000) { // it was created less than a second before\r\n\r\n              // conservatively be unable to keep the lock\r\n              return undefined;\r\n            }\r\n          }\r\n\r\n          // console.log(`Other pid ${otherPid} lockfile has start time: \"${otherPidOldStartTime}\"`);\r\n          // console.log(`Other pid ${otherPid} actually has start time: \"${otherPidCurrentStartTime}\"`);\r\n\r\n          // this means the process is no longer executing, delete the file\r\n          if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {\r\n            // console.log(`Other pid ${otherPid} is no longer executing!`);\r\n            fsx.removeSync(fileInFolderPath);\r\n            continue;\r\n          }\r\n\r\n          // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);\r\n          // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);\r\n          // this is a lockfile pointing at something valid\r\n          if (otherBirthtimeMs < smallestBirthTimeMs) {\r\n            smallestBirthTimeMs = otherBirthtimeMs;\r\n            smallestBirthTimePid = otherPid;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (smallestBirthTimePid !== pid.toString()) {\r\n        // we do not have the lock\r\n        return undefined;\r\n      }\r\n\r\n      // we have the lock!\r\n      lockFile = new LockFile(lockFileDescriptor, pidLockFilePath, dirtyWhenAcquired);\r\n      lockFileDescriptor = undefined; // we have handed the descriptor off to the instance\r\n    } finally {\r\n      if (lockFileDescriptor) {\r\n        // ensure our lock is closed\r\n        fsx.closeSync(lockFileDescriptor);\r\n        fsx.removeSync(pidLockFilePath);\r\n      }\r\n    }\r\n    return lockFile;\r\n  }\r\n\r\n  /**\r\n   * Attempts to acquire the lock using Windows\r\n   * This algorithm is much simpler since we can rely on the operating system\r\n   */\r\n  private static _tryAcquireWindows(resourceDir: string, resourceName: string): LockFile | undefined {\r\n    const lockFilePath: string = LockFile.getLockFilePath(resourceDir, resourceName);\r\n    let dirtyWhenAcquired: boolean = false;\r\n\r\n    let fileDescriptor: number | undefined;\r\n    let lockFile: LockFile;\r\n\r\n    try {\r\n      if (fsx.existsSync(lockFilePath)) {\r\n        dirtyWhenAcquired = true;\r\n\r\n        // If the lockfile is held by an process with an exclusive lock, then removing it will\r\n        // silently fail. OpenSync() below will then fail and we will be unable to create a lock.\r\n\r\n        // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that\r\n        // the last process to hold it died.\r\n        fsx.unlinkSync(lockFilePath);\r\n      }\r\n\r\n      try {\r\n        // Attempt to open an exclusive lockfile\r\n        fileDescriptor = fsx.openSync(lockFilePath, 'wx');\r\n      } catch (error) {\r\n        // we tried to delete the lock, but something else is holding it,\r\n        // (probably an active process), therefore we are unable to create a lock\r\n        return undefined;\r\n      }\r\n\r\n      // Ensure we can hand off the file descriptor to the lockfile\r\n      lockFile = new LockFile(fileDescriptor, lockFilePath, dirtyWhenAcquired);\r\n      fileDescriptor = undefined;\r\n    } finally {\r\n      if (fileDescriptor) {\r\n        fsx.closeSync(fileDescriptor);\r\n      }\r\n    }\r\n\r\n    return lockFile;\r\n  }\r\n\r\n  /**\r\n   * Unlocks a file and removes it from disk.\r\n   * This can only be called once.\r\n   */\r\n  public release(): void {\r\n    if (this.isReleased) {\r\n      throw new Error(`The lock for file \"${path.basename(this._filePath)}\" has already been released.`);\r\n    }\r\n\r\n    fsx.closeSync(this._fileDescriptor!);\r\n    fsx.removeSync(this._filePath);\r\n    this._fileDescriptor = undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the initial state of the lock.\r\n   * This can be used to detect if the previous process was terminated before releasing the resource.\r\n   */\r\n  public get dirtyWhenAcquired(): boolean {\r\n    return this._dirtyWhenAcquired;\r\n  }\r\n\r\n  /**\r\n   * Returns the absolute path to the lockfile\r\n   */\r\n  public get filePath(): string {\r\n    return this._filePath;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this lock is currently being held.\r\n   */\r\n  public get isReleased(): boolean {\r\n    return this._fileDescriptor === undefined;\r\n  }\r\n\r\n  private constructor(\r\n    private _fileDescriptor: number | undefined,\r\n    private _filePath: string,\r\n    private _dirtyWhenAcquired: boolean) {\r\n  }\r\n}"],"sourceRoot":"../src"}