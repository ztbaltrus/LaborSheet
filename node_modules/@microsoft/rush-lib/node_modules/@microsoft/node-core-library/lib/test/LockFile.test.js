"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference types='mocha' />
const fsx = require("fs-extra");
const chai_1 = require("chai");
const path = require("path");
const LockFile_1 = require("../LockFile");
function setLockFileGetProcessStartTime(fn) {
    // tslint:disable-next-line:no-any
    LockFile_1.LockFile._getStartTime = fn;
}
describe('LockFile', () => {
    afterEach(() => {
        setLockFileGetProcessStartTime(LockFile_1.getProcessStartTime);
    });
    describe('getLockFilePath', () => {
        it('only acceps alphabetical characters for resource name', () => {
            chai_1.assert.doesNotThrow(() => {
                LockFile_1.LockFile.getLockFilePath(process.cwd(), 'foo123');
            });
            chai_1.assert.doesNotThrow(() => {
                LockFile_1.LockFile.getLockFilePath(process.cwd(), 'bar.123');
            });
            chai_1.assert.doesNotThrow(() => {
                LockFile_1.LockFile.getLockFilePath(process.cwd(), 'foo.bar');
            });
            chai_1.assert.doesNotThrow(() => {
                LockFile_1.LockFile.getLockFilePath(process.cwd(), 'lock-file.123');
            });
            chai_1.assert.throws(() => {
                LockFile_1.LockFile.getLockFilePath(process.cwd(), '.foo123');
            });
            chai_1.assert.throws(() => {
                LockFile_1.LockFile.getLockFilePath(process.cwd(), 'foo123.');
            });
            chai_1.assert.throws(() => {
                LockFile_1.LockFile.getLockFilePath(process.cwd(), '-foo123');
            });
            chai_1.assert.throws(() => {
                LockFile_1.LockFile.getLockFilePath(process.cwd(), 'foo123-');
            });
            chai_1.assert.throws(() => {
                LockFile_1.LockFile.getLockFilePath(process.cwd(), '');
            });
        });
    });
    if (process.platform === 'darwin' || process.platform === 'linux') {
        describe('Linux and Mac', () => {
            describe('getLockFilePath()', () => {
                it('returns a resolved path containing the pid', () => {
                    chai_1.assert.equal(path.join(process.cwd(), `test#${process.pid}.lock`), LockFile_1.LockFile.getLockFilePath('./', 'test'));
                });
                it('allows for overridden pid', () => {
                    chai_1.assert.equal(path.join(process.cwd(), `test#99.lock`), LockFile_1.LockFile.getLockFilePath('./', 'test', 99));
                });
            });
            it('can acquire and close a clean lockfile', () => {
                // ensure test folder is clean
                const testFolder = path.join(__dirname, '1');
                fsx.emptyDirSync(testFolder);
                const resourceName = 'test';
                const pidLockFileName = LockFile_1.LockFile.getLockFilePath(testFolder, resourceName);
                const lock = LockFile_1.LockFile.tryAcquire(testFolder, resourceName);
                // The lockfile should exist and be in a clean state
                chai_1.assert.isDefined(lock);
                chai_1.assert.isFalse(lock.dirtyWhenAcquired);
                chai_1.assert.isFalse(lock.isReleased);
                chai_1.assert.isTrue(fsx.existsSync(pidLockFileName));
                // Ensure that we can release the "clean" lockfile
                lock.release();
                chai_1.assert.isFalse(fsx.existsSync(pidLockFileName));
                chai_1.assert.isTrue(lock.isReleased);
                // Ensure we cannot release the lockfile twice
                chai_1.assert.throws(() => {
                    lock.release();
                });
            });
            it('cannot acquire a lock if another valid lock exists', () => {
                // ensure test folder is clean
                const testFolder = path.join(__dirname, '2');
                fsx.emptyDirSync(testFolder);
                const otherPid = 999999999;
                const otherPidStartTime = '2012-01-02 12:53:12';
                const resourceName = 'test';
                const otherPidLockFileName = LockFile_1.LockFile.getLockFilePath(testFolder, resourceName, otherPid);
                setLockFileGetProcessStartTime((pid) => {
                    return pid === process.pid ? LockFile_1.getProcessStartTime(process.pid) : otherPidStartTime;
                });
                // create an open lockfile
                const lockFileDescriptor = fsx.openSync(otherPidLockFileName, 'w');
                fsx.writeSync(lockFileDescriptor, otherPidStartTime);
                fsx.closeSync(lockFileDescriptor);
                fsx.utimesSync(otherPidLockFileName, 10000, 10000);
                const lock = LockFile_1.LockFile.tryAcquire(testFolder, resourceName);
                // this lock should be undefined since there is an existing lock
                chai_1.assert.isUndefined(lock);
            });
        });
    }
    if (process.platform === 'win32') {
        describe('getLockFilePath()', () => {
            it('returns a resolved path that doesn\'t contain', () => {
                chai_1.assert.equal(path.join(process.cwd(), `test.lock`), LockFile_1.LockFile.getLockFilePath('./', 'test'));
            });
            it('ignores pid that is passed in', () => {
                chai_1.assert.equal(path.join(process.cwd(), `test.lock`), LockFile_1.LockFile.getLockFilePath('./', 'test', 99));
            });
        });
        it('will not acquire if existing lock is there', () => {
            // ensure test folder is clean
            const testFolder = path.join(__dirname, '1');
            fsx.removeSync(testFolder);
            fsx.mkdirsSync(testFolder);
            // create an open lockfile
            const resourceName = 'test';
            const lockFileName = LockFile_1.LockFile.getLockFilePath(testFolder, resourceName);
            const lockFileDescriptor = fsx.openSync(lockFileName, 'wx');
            const lock = LockFile_1.LockFile.tryAcquire(testFolder, resourceName);
            // this lock should be undefined since there is an existing lock
            chai_1.assert.isUndefined(lock);
            fsx.closeSync(lockFileDescriptor);
        });
        it('can acquire and close a dirty lockfile', () => {
            // ensure test folder is clean
            const testFolder = path.join(__dirname, '1');
            fsx.removeSync(testFolder);
            fsx.mkdirsSync(testFolder);
            // Create a lockfile that is still hanging around on disk,
            const resourceName = 'test';
            const lockFileName = LockFile_1.LockFile.getLockFilePath(testFolder, resourceName);
            fsx.closeSync(fsx.openSync(lockFileName, 'wx'));
            const lock = LockFile_1.LockFile.tryAcquire(testFolder, resourceName);
            chai_1.assert.isDefined(lock);
            chai_1.assert.isTrue(lock.dirtyWhenAcquired);
            chai_1.assert.isFalse(lock.isReleased);
            chai_1.assert.isTrue(fsx.existsSync(lockFileName));
            // Ensure that we can release the "dirty" lockfile
            lock.release();
            chai_1.assert.isFalse(fsx.existsSync(lockFileName));
            chai_1.assert.isTrue(lock.isReleased);
        });
        it('can acquire and close a clean lockfile', () => {
            // ensure test folder is clean
            const testFolder = path.join(__dirname, '1');
            fsx.removeSync(testFolder);
            fsx.mkdirsSync(testFolder);
            const resourceName = 'test';
            const lockFileName = LockFile_1.LockFile.getLockFilePath(testFolder, resourceName);
            const lock = LockFile_1.LockFile.tryAcquire(testFolder, resourceName);
            // The lockfile should exist and be in a clean state
            chai_1.assert.isDefined(lock);
            chai_1.assert.isFalse(lock.dirtyWhenAcquired);
            chai_1.assert.isFalse(lock.isReleased);
            chai_1.assert.isTrue(fsx.existsSync(lockFileName));
            // Ensure that we can release the "clean" lockfile
            lock.release();
            chai_1.assert.isFalse(fsx.existsSync(lockFileName));
            chai_1.assert.isTrue(lock.isReleased);
            // Ensure we cannot release the lockfile twice
            chai_1.assert.throws(() => {
                lock.release();
            });
        });
    }
});

//# sourceMappingURL=LockFile.test.js.map
