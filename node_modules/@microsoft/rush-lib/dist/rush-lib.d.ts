/**
 * A library for writing scripts that interact with the Rush tool.
 * @packagedocumentation
 */

import { IPackageJson } from '@microsoft/node-core-library';

/**
 * This represents the JSON file specified via the "approvedPackagesFile" option in rush.json.
 * @public
 */
export declare class ApprovedPackagesConfiguration {
    private static _jsonSchema;
    items: ApprovedPackagesItem[];
    private _itemsByName;
    private _loadedJson;
    private _jsonFilename;
    constructor(jsonFilename: string);
    /**
     * Clears all the settings, returning to an empty state.
     */
    clear(): void;
    getItemByName(packageName: string): ApprovedPackagesItem | undefined;
    addOrUpdatePackage(packageName: string, reviewCategory: string): void;
    /**
     * If the file exists, calls loadFromFile().
     */
    tryLoadFromFile(approvedPackagesPolicyEnabled: boolean): boolean;
    /**
     * Loads the configuration data from the filename that was passed to the constructor.
     */
    loadFromFile(): void;
    /**
     * Loads the configuration data to the filename that was passed to the constructor.
     */
    saveToFile(): void;
    /**
     * Helper function only used by the constructor when loading the file.
     */
    private _addItemJson(itemJson, jsonFilename);
    /**
     * Helper function that adds an already created ApprovedPackagesItem to the
     * list and set.
     */
    private _addItem(item);
}

/**
 * An item returned by ApprovedPackagesConfiguration
 * @public
 */
export declare class ApprovedPackagesItem {
    /**
     * The NPM package name
     */
    packageName: string;
    /**
     * The project categories that are allowed to use this package.
     */
    allowedCategories: Set<string>;
}

/**
 * This is a helper object for RushConfiguration.
 * It exposes the "approvedPackagesPolicy" feature from rush.json.
 * @public
 */
export declare class ApprovedPackagesPolicy {
    private _enabled;
    private _ignoredNpmScopes;
    private _reviewCategories;
    private _browserApprovedPackages;
    private _nonbrowserApprovedPackages;
    /** @internal */
    constructor(rushConfiguration: RushConfiguration, rushConfigurationJson: IRushConfigurationJson);
    /**
     * Whether the feature is enabled.  The feature is enabled if the "approvedPackagesPolicy"
     * field is assigned in rush.json.
     */
    readonly enabled: boolean;
    /**
     * A list of NPM package scopes that will be excluded from review (e.g. \"@types\")
     */
    readonly ignoredNpmScopes: Set<string>;
    /**
     * A list of category names that are valid for usage as the RushConfigurationProject.reviewCategory field.
     * This array will never be undefined.
     */
    readonly reviewCategories: Set<string>;
    /**
     * Packages approved for usage in a web browser.  This is the stricter of the two types, so by default
     * all new packages are added to this file.
     *
     * @remarks
     *
     * This is part of an optional approval workflow, whose purpose is to review any new dependencies
     * that are introduced (e.g. maybe a legal review is required, or maybe we are trying to minimize bloat).
     * When Rush discovers a new dependency has been added to package.json, it will update the file.
     * The intent is that the file will be stored in Git and tracked by a branch policy that notifies
     * reviewers when a PR attempts to modify the file.
     *
     * Example filename: "C:\MyRepo\common\config\rush\browser-approved-packages.json"
     */
    readonly browserApprovedPackages: ApprovedPackagesConfiguration;
    /**
     * Packages approved for usage everywhere *except* in a web browser.
     *
     * @remarks
     *
     * This is part of an optional approval workflow, whose purpose is to review any new dependencies
     * that are introduced (e.g. maybe a legal review is required, or maybe we are trying to minimize bloat).
     * The intent is that the file will be stored in Git and tracked by a branch policy that notifies
     * reviewers when a PR attempts to modify the file.
     *
     * Example filename: "C:\MyRepo\common\config\rush\browser-approved-packages.json"
     */
    readonly nonbrowserApprovedPackages: ApprovedPackagesConfiguration;
}

/**
 * Type of version bumps
 * @beta
 */
export declare enum BumpType {
    'none' = 0,
    'prerelease' = 1,
    'patch' = 2,
    'preminor' = 3,
    'minor' = 4,
    'major' = 5,
}

/**
 * This class represents a single change file.
 * @public
 */
export declare class ChangeFile {
    private _changeFileData;
    private _rushConfiguration;
    /**
     * @internal
     */
    constructor(changeFileData: IChangeFile, rushConfiguration: RushConfiguration);
    /**
     * Adds a change entry into the change file
     * @param data - change information
     */
    addChange(data: IChangeInfo): void;
    /**
     * Gets all the change entries about the specified package from the change file.
     * @param packageName - package name
     */
    getChanges(packageName: string): IChangeInfo[];
    /**
     * Writes the change file to disk in sync mode
     */
    writeSync(): void;
    /**
     * Generates a file path for storing the change file to disk
     */
    generatePath(): string;
    /**
    * Gets the current time, formatted as YYYY-MM-DD-HH-MM
    * Optionally will include seconds
    */
    private _getTimestamp(useSeconds?);
    private _escapeFilename(filename, replacer?);
}

/**
 * Represents all of the types of change requests.
 * @public
 */
export declare enum ChangeType {
    none = 0,
    dependency = 1,
    hotfix = 2,
    patch = 3,
    minor = 4,
    major = 5,
}

/**
 * Use this class to load and save the "common/config/rush/common-versions.json" config file.
 * This config file stores dependency version information that affects all projects in the repo.
 * @public
 */
export declare class CommonVersionsConfiguration {
    private static _jsonSchema;
    private _filename;
    private _preferredVersions;
    private _xstitchPreferredVersions;
    private _allowedAlternativeVersions;
    /**
     * Loads the common-versions.json data from the specified file path.
     * If the file has not been created yet, then an empty object is returned.
     */
    static loadFromFile(jsonFilename: string): CommonVersionsConfiguration;
    private static _deserializeTable<TValue>(map, object);
    private static _serializeTable<TValue>(map);
    /**
     * Writes the "common-versions.json" file to disk, using the filename that was passed to loadFromFile().
     */
    save(): void;
    /**
     * A table that specifies a "preferred version" for a dependency package.
     *
     * @remarks
     * The "preferred version" is typically used to hold an indirect dependency back to a specific
     * version, however generally it can be any SemVer range specifier (e.g. "~1.2.3"), and it
     * will narrow any (compatible) SemVer range specifier.
     *
     * For example, suppose local project A depends on an external package B, and B asks
     * for C@^1.0.0, which normally would select C@1.5.0.  If we specify C@~1.2.3 as our preferred version,
     * and it selects C@1.2.9, then that will be installed for B instead of C@1.5.0.  Whereas if the
     * preferred version was C@~2.0.0 then it would have no effect, because this is incompatible
     * with C@^1.0.0.  A compatible parent dependency will take precedence over the preferred version;
     * for example  if A had a direct dependency on C@1.2.2, then B would get C@1.2.2 regardless of the
     * preferred version.
     *
     * Rush's implementation relies on the package manager's heuristic for avoiding duplicates by
     * trying to reuse dependencies requested by a parent in the graph:  The preferred versions
     * are simply injected into the fake common/temp/package.json file that acts as the root
     * for all local projects in the Rush repo.
     */
    readonly preferredVersions: Map<string, string>;
    /**
     * A table of specifies preferred versions maintained by the XStitch tool.
     *
     * @remarks
     * This property has the same behavior as the "preferredVersions" property, except these entries
     * are automatically managed by the XStitch tool.  It is an error for the same dependency name
     * to appear in both tables.
     */
    readonly xstitchPreferredVersions: Map<string, string>;
    /**
     * A table that stores, for a given dependency, a list of SemVer ranges that will be accepted
     * by "rush check" in addition to the normal version range.
     *
     * @remarks
     * The "rush check" command can be used to enforce that every project in the repo
     * must specify the same SemVer range for a given dependency.  However, sometimes
     * exceptions are needed.  The allowedAlternativeVersions table allows you to list
     * other SemVer ranges that will be accepted by "rush check" for a given dependency.
     * Note that the normal version range (as inferred by looking at all projects in the repo)
     * should NOT be included in this list.
     */
    readonly allowedAlternativeVersions: Map<string, ReadonlyArray<string>>;
    /**
     * Returns the union of preferredVersions and xstitchPreferredVersions.
     */
    getAllPreferredVersions(): Map<string, string>;
    private constructor();
    private _onSetPreferredVersions(source, key, value);
    private _onSetAllowedAlternativeVersions(source, key, value);
    private _serialize();
}

/**
 * Names of environment variables used by Rush.
 * @public
 */
export declare const enum EnvironmentVariableNames {
    /**
     * This variable overrides the temporary folder used by Rush.
     * The default value is "common/temp" under the repoistory root.
     */
    RUSH_TEMP_FOLDER = "RUSH_TEMP_FOLDER",
    /**
     * This variable overrides the version of Rush that will be installed by
     * the version selector.  The default value is determined by the "rushVersion"
     * field from rush.json.
     */
    RUSH_PREVIEW_VERSION = "RUSH_PREVIEW_VERSION",
}

/**
 * Events happen during Rush runs.
 * @beta
 */
export declare enum Event {
    /**
     * Pre Rush install event
     */
    preRushInstall = 1,
    /**
     * Post Rush install event
     */
    postRushInstall = 2,
    /**
     * Pre Rush build event
     */
    preRushBuild = 3,
    /**
     * Post Rush build event
     */
    postRushBuild = 4,
}

/**
 * This class represents Rush event hooks configured for this repo.
 * Hooks are customized script actions that Rush executes when specific events occur.
 * The actions are expressed as a command-line that is executed using the operating system shell.
 * @beta
 */
export declare class EventHooks {
    private _hooks;
    /**
     * @internal
     */
    constructor(eventHooksJson: IEventHooksJson);
    /**
     * Return all the scripts associated with the specified event.
     * @param event - Rush event
     */
    get(event: Event): string[];
}

/**
 * Part of IRushConfigurationJson.
 */
declare interface IApprovedPackagesPolicyJson {
    reviewCategories?: string[];
    ignoredNpmScopes?: string[];
}

/**
 * Representation for a changes file
 * @public
 */
declare interface IChangeFile {
    changes: IChangeInfo[];
    packageName: string;
    email: string | undefined;
}

/**
 * Defines an IChangeInfo object.
 * @public
 */
export declare interface IChangeInfo {
    /**
     * Defines the type of change. This is not expected to exist within the JSON file definition as we
     * parse it from the "type" property.
     */
    changeType?: ChangeType;
    /**
     * Defines the array of related changes for the given package. This is used to iterate over comments
     * requested by the change requests.
     */
    changes?: IChangeInfo[];
    /**
     * A user provided comment for the change.
     */
    comment?: string;
    /**
     * The email of the user who provided the comment. Pulled from the git log.
     */
    author?: string;
    /**
     * The commit hash for the change.
     */
    commit?: string;
    /**
     * The new downstream range dependency, as calculated by the findChangeRequests function.
     */
    newRangeDependency?: string;
    /**
     * The new version for the package, as calculated by the findChangeRequests function.
     */
    newVersion?: string;
    /**
     * The order in which the change request should be published.
     */
    order?: number;
    /**
     * The name of the package.
     */
    packageName: string;
    /**
     * The type of the package publishing request (patch/minor/major), as provided by the JSON file.
     */
    type?: string;
}

/**
 * Part of IRushConfigurationJson.
 * @beta
 */
declare interface IEventHooksJson {
    /**
     * The list of scripts to run after every Rush build command finishes
     */
    postRushBuild?: string[];
}

/**
 * @beta
 */
declare interface IIndividualVersionJson extends IVersionPolicyJson {
    lockedMajor?: number;
}

/**
 * @beta
 */
declare interface ILockStepVersionJson extends IVersionPolicyJson {
    version: string;
    nextBump: string;
    mainProject?: string;
}

/**
 * This policy indicates all related projects get version bump driven by their own changes.
 * @beta
 */
export declare class IndividualVersionPolicy extends VersionPolicy {
    private _lockedMajor;
    /**
     * @internal
     */
    constructor(versionPolicyJson: IIndividualVersionJson);
    /**
     * The major version that has been locked
     */
    readonly lockedMajor: number | undefined;
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    readonly _json: IIndividualVersionJson;
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    /**
     * Bumps version.
     * Individual version policy lets change files drive version bump. This method currently does not do anything.
     *
     * @param bumpType - bump type
     * @param identifier - prerelease id
     */
    bump(bumpType?: BumpType, identifier?: string): void;
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString: string, packageName: string): void;
}

/**
 * This represents the JSON data structure for the "rush.json" configuration file.
 * See rush.schema.json for documentation.
 */
declare interface IRushConfigurationJson {
    $schema: string;
    npmVersion?: string;
    pnpmVersion?: string;
    rushVersion: string;
    repository?: IRushRepositoryJson;
    nodeSupportedVersionRange?: string;
    projectFolderMinDepth?: number;
    projectFolderMaxDepth?: number;
    approvedPackagesPolicy?: IApprovedPackagesPolicyJson;
    gitPolicy?: IRushGitPolicyJson;
    telemetryEnabled?: boolean;
    projects: IRushConfigurationProjectJson[];
    eventHooks?: IEventHooksJson;
    hotfixChangeEnabled?: boolean;
}

/**
 * This represents the JSON data object for a project entry in the rush.json configuration file.
 */
declare interface IRushConfigurationProjectJson {
    packageName: string;
    projectFolder: string;
    reviewCategory?: string;
    cyclicDependencyProjects: string[];
    versionPolicyName?: string;
    shouldPublish?: boolean;
    skipRushCheck?: boolean;
}

/**
 * Part of IRushConfigurationJson.
 */
declare interface IRushGitPolicyJson {
    allowedEmailRegExps?: string[];
    sampleEmail?: string;
}

/**
 * Part of IRushConfigurationJson.
 */
declare interface IRushRepositoryJson {
    /**
     * The remote url of the repository. It helps 'Rush change' finds the right remote to compare against.
     */
    url: string;
}

/**
 * @beta
 */
declare interface IVersionPolicyJson {
    policyName: string;
    definitionName: string;
}

/**
 * A helper class for managing last-install flags, which are persistent and
 * indicate that something installed in the folder was sucessfully completed.
 * It also compares state, so that if something like the Node.js version has changed,
 * it can invalidate the last install.
 * @internal
 */
export declare class _LastInstallFlag {
    private _path;
    private _state;
    /**
     * Creates a new LastInstall flag
     * @param folderPath - the folder that this flag is managing
     * @param state - optional, the state that should be managed or compared
    */
    constructor(folderPath: string, state?: Object);
    /**
     * Returns true if the file exists and the contents match the current state
     */
    isValid(): boolean;
    /**
     * Writes the flag file to disk with the current state
     */
    create(): void;
    /**
     * Removes the flag file
     */
    clear(): void;
    /**
     * Returns the full path to the flag file
     */
    readonly path: string;
}

/**
 * This policy indicates all related projects should use the same version.
 * @beta
 */
export declare class LockStepVersionPolicy extends VersionPolicy {
    private _version;
    private _nextBump;
    private _mainProject;
    /**
     * @internal
     */
    constructor(versionPolicyJson: ILockStepVersionJson);
    /**
     * The value of the lockstep version
     */
    readonly version: string;
    /**
     * The type of bump for next bump.
     */
    readonly nextBump: BumpType;
    /**
     * The main project for the version policy.
     *
     * If the value is provided, change logs will only be generated in that project.
     * If the value is not provided, change logs will be hosted in each project associated with the policy.
     */
    readonly mainProject: string | undefined;
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    readonly _json: ILockStepVersionJson;
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    /**
     * Bumps the version of the lockstep policy
     *
     * @param bumpType - Overwrite bump type in version-policy.json with the provided value.
     * @param identifier - Prerelease identifier if bump type is prerelease.
     */
    bump(bumpType?: BumpType, identifier?: string): void;
    /**
     * Updates the version of the policy directly with a new value
     * @param newVersionString - New version
     */
    update(newVersionString: string): boolean;
    /**
     * Validates the specified version and throws if the version does not satisfy lockstep version.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString: string, packageName: string): void;
    private _updatePackageVersion(project, newVersion);
    private _getReleaseType(bumpType);
}

/**
 * This represents the available Package Manager tools as a string
 * @public
 */
export declare type PackageManager = 'pnpm' | 'npm';

/**
 * Operations involving the rush tool and its operation.
 *
 * @public
 */
export declare class Rush {
    private static _version;
    /**
     * Executes the Rush CLI. This is expected to be called by the @microsoft/rush package, which acts as a version
     *  manager for the Rush tool. The rush-lib API is exposed through the index.ts/js file.
     *
     * @param launcherVersion - The version of the @microsoft/rush wrapper used to call invoke the CLI.
     * @param isManaged - True if the tool was invoked from within a project with a rush.json file, otherwise false. We
     *  consider a project without a rush.json to be "unmanaged" and we'll print that to the command line when
     *  the tool is executed. This is mainly used for debugging purposes.
     */
    static launch(launcherVersion: string, isManaged: boolean): void;
    /**
     * The currently executing version of the "rush-lib" library.
     * This is the same as the Rush tool version for that release.
     * @public
     */
    static readonly version: string;
}

/**
 * This represents the Rush configuration for a repository, based on the "rush.json"
 * configuration file.
 * @public
 */
export declare class RushConfiguration {
    private static _jsonSchema;
    private _rushJsonFile;
    private _rushJsonFolder;
    private _changesFolder;
    private _commonFolder;
    private _commonTempFolder;
    private _commonRushConfigFolder;
    private _packageManager;
    private _pnpmStoreFolder;
    private _npmCacheFolder;
    private _npmTmpFolder;
    private _committedShrinkwrapFilename;
    private _tempShrinkwrapFilename;
    private _tempShrinkwrapPreinstallFilename;
    private _rushUserFolder;
    private _rushLinkJsonFilename;
    private _packageManagerToolVersion;
    private _packageManagerToolFilename;
    private _projectFolderMinDepth;
    private _projectFolderMaxDepth;
    private _approvedPackagesPolicy;
    private _gitAllowedEmailRegExps;
    private _gitSampleEmail;
    private _hotfixChangeEnabled;
    private _repositoryUrl;
    private _eventHooks;
    private _commonVersions;
    private _telemetryEnabled;
    private _projects;
    private _projectsByName;
    private _versionPolicyConfiguration;
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    static loadFromConfigurationFile(rushJsonFilename: string): RushConfiguration;
    static loadFromDefaultLocation(): RushConfiguration;
    /**
     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
     */
    static tryFindRushJsonLocation(verbose?: boolean): string | undefined;
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    private static _generateTempNamesForProjects(sortedProjectJsons);
    /**
     * If someone adds a config file in the "common/rush/config" folder, it would be a bad
     * experience for Rush to silently ignore their file simply because they misspelled the
     * filename, or maybe it's an old format that's no longer supported.  The
     * _validateCommonRushConfigFolder() function makes sure that this folder only contains
     * recognized config files.
     */
    private static _validateCommonRushConfigFolder(commonRushConfigFolder, packageManager);
    /**
     * The name of the package manager being used to install dependencies
     */
    readonly packageManager: PackageManager;
    /**
     * The Rush configuration file
     */
    readonly rushJsonFile: string;
    /**
     * The folder that contains rush.json for this project.
     */
    readonly rushJsonFolder: string;
    /**
     * The folder that contains all change files.
     */
    readonly changesFolder: string;
    /**
     * The fully resolved path for the "common" folder where Rush will store settings that
     * affect all Rush projects.  This is always a subfolder of the folder containing "rush.json".
     * Example: "C:\MyRepo\common"
     */
    readonly commonFolder: string;
    /**
     * The folder where Rush's additional config files are stored.  This folder is always a
     * subfolder called "config\rush" inside the common folder.  (The "common\config" folder
     * is reserved for configuration files used by other tools.)  To avoid confusion or mistakes,
     * Rush will report an error if this this folder contains any unrecognized files.
     *
     * Example: "C:\MyRepo\common\config\rush"
     */
    readonly commonRushConfigFolder: string;
    /**
     * The folder where temporary files will be stored.  This is always a subfolder called "temp"
     * inside the common folder.
     * Example: "C:\MyRepo\common\temp"
     */
    readonly commonTempFolder: string;
    /**
     * The local folder that will store the NPM package cache.  Rush does not rely on the
     * npm's default global cache folder, because npm's caching implementation does not
     * reliably handle multiple processes.  (For example, if a build box is running
     * "rush install" simultaneously for two different working folders, it may fail randomly.)
     *
     * Example: "C:\MyRepo\common\temp\npm-cache"
     */
    readonly npmCacheFolder: string;
    /**
     * The local folder where npm's temporary files will be written during installation.
     * Rush does not rely on the global default folder, because it may be on a different
     * hard disk.
     *
     * Example: "C:\MyRepo\common\temp\npm-tmp"
     */
    readonly npmTmpFolder: string;
    /**
     * The local folder where PNPM stores a global installation for every installed package
     *
     * Example: "C:\MyRepo\common\temp\pnpm-store"
     */
    readonly pnpmStoreFolder: string;
    /**
     * The full path of the shrinkwrap file that is tracked by Git.  (The "rush install"
     * command uses a temporary copy, whose path is tempShrinkwrapFilename.)
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: "C:\MyRepo\common\npm-shrinkwrap.json" or "C:\MyRepo\common\shrinkwrap.yaml"
     */
    readonly committedShrinkwrapFilename: string;
    /**
     * The full path of the temporary shrinkwrap file that is used during "rush install".
     * This file may get rewritten by the package manager during installation.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: "C:\MyRepo\common\temp\npm-shrinkwrap.json" or "C:\MyRepo\common\temp\shrinkwrap.yaml"
     */
    readonly tempShrinkwrapFilename: string;
    /**
     * The full path of a backup copy of tempShrinkwrapFilename. This backup copy is made
     * before installation begins, and can be compared to determine how the package manager
     * modified tempShrinkwrapFilename.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: "C:\MyRepo\common\temp\npm-shrinkwrap-preinstall.json"
     * or "C:\MyRepo\common\temp\shrinkwrap-preinstall.yaml"
     */
    readonly tempShrinkwrapPreinstallFilename: string;
    /**
     * The absolute path to Rush's storage in the home directory for the current user.  On Windows,
     * it would be something like "C:\Users\YourName\.rush".
     */
    readonly rushUserFolder: string;
    /**
     * The filename of the build dependency data file.  By default this is
     * called 'rush-link.json' resides in the Rush common folder.
     * Its data structure is defined by IRushLinkJson.
     *
     * Example: "C:\MyRepo\common\temp\rush-link.json"
     */
    readonly rushLinkJsonFilename: string;
    /**
     * The version of the locally installed NPM tool.  (Example: "1.2.3")
     */
    readonly packageManagerToolVersion: string;
    /**
     * The absolute path to the locally installed NPM tool.  If "rush install" has not
     * been run, then this file may not exist yet.
     * Example: "C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm"
     */
    readonly packageManagerToolFilename: string;
    /**
     * The minimum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements a standard 2-level hierarchy of <categoryFolder>/<projectFolder>/package.json.
     */
    readonly projectFolderMinDepth: number;
    /**
     * The maximum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements on a standard convention of <categoryFolder>/<projectFolder>/package.json.
     */
    readonly projectFolderMaxDepth: number;
    /**
     * The "approvedPackagesPolicy" settings.
     */
    readonly approvedPackagesPolicy: ApprovedPackagesPolicy;
    /**
     * [Part of the "gitPolicy" feature.]
     * A list of regular expressions describing allowable e-mail patterns for Git commits.
     * They are case-insensitive anchored JavaScript RegExps.
     * Example: ".*@example\.com"
     * This array will never be undefined.
     */
    readonly gitAllowedEmailRegExps: string[];
    /**
     * [Part of the "gitPolicy" feature.]
     * An example valid e-mail address that conforms to one of the allowedEmailRegExps.
     * Example: "foxtrot@example\.com"
     * This will never be undefined, and will always be nonempty if gitAllowedEmailRegExps is used.
     */
    readonly gitSampleEmail: string;
    /**
     * [Part of the "hotfixChange" feature.]
     * Enables creating hotfix changes
     */
    readonly hotfixChangeEnabled: boolean;
    /**
     * The remote url of the repository. It helps 'Rush change' finds the right remote to compare against.
     */
    readonly repositoryUrl: string;
    /**
     * Indicates whether telemetry collection is enabled for Rush runs.
     * @beta
     */
    readonly telemetryEnabled: boolean;
    readonly projects: RushConfigurationProject[];
    readonly projectsByName: Map<string, RushConfigurationProject>;
    /**
     * Settings from the common-versions.json config file.
     * @remarks
     * If the common-versions.json file is missing, this property will not be undefined.
     * Instead it will be initialized in an empty state, and calling CommonVersionsConfiguration.save()
     * will create the file.
     */
    readonly commonVersions: CommonVersionsConfiguration;
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     * @beta
     */
    readonly eventHooks: EventHooks;
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    getProjectByName(projectName: string): RushConfigurationProject | undefined;
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like "@something/example".  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    findProjectByShorthandName(shorthandProjectName: string): RushConfigurationProject | undefined;
    /**
     * Looks up a project by its RushConfigurationProject.tempProjectName field.
     * @returns The found project, or undefined if no match was found.
     */
    findProjectByTempName(tempProjectName: string): RushConfigurationProject | undefined;
    /**
     * @beta
     */
    readonly versionPolicyConfiguration: VersionPolicyConfiguration;
    /**
     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    private constructor();
    private _populateDownstreamDependencies(dependencies, packageName);
}

/**
 * This represents the configuration of a project that is built by Rush, based on
 * the Rush.json configuration file.
 * @public
 */
export declare class RushConfigurationProject {
    private _packageName;
    private _projectFolder;
    private _projectRelativeFolder;
    private _reviewCategory;
    private _packageJson;
    private _tempProjectName;
    private _unscopedTempProjectName;
    private _cyclicDependencyProjects;
    private _versionPolicyName;
    private _versionPolicy;
    private _shouldPublish;
    private _skipRushCheck;
    private _downstreamDependencyProjects;
    private readonly _rushConfiguration;
    /** @internal */
    constructor(projectJson: IRushConfigurationProjectJson, rushConfiguration: RushConfiguration, tempProjectName: string);
    /**
     * The name of the NPM package.  An error is reported if this name is not
     * identical to packageJson.name.
     *
     * Example: "@scope/MyProject"
     */
    readonly packageName: string;
    /**
     * The full path of the folder that contains the project to be built by Rush.
     *
     * Example: "C:\MyRepo\libraries\my-project"
     */
    readonly projectFolder: string;
    /**
     * The relative path of the folder that contains the project to be built by Rush.
     *
     * Example: "libraries\my-project"
     */
    readonly projectRelativeFolder: string;
    /**
     * The review category name, or undefined if no category was assigned.
     * This name must be one of the valid choices listed in RushConfiguration.reviewCategories.
     */
    readonly reviewCategory: string;
    /**
     * A list of local projects that appear as devDependencies for this project, but cannot be
     * locally linked because it would create a cyclic dependency; instead, the last published
     * version will be installed in the Common folder.
     *
     * These are package names that would be found by RushConfiguration.getProjectByName().
     */
    readonly cyclicDependencyProjects: Set<string>;
    /**
     * A list of projects within the Rush configuration which directly depend on this package.
     */
    readonly downstreamDependencyProjects: string[];
    /**
     * The parsed NPM "package.json" file from projectFolder.
     */
    readonly packageJson: IPackageJson;
    /**
     * The unique name for the temporary project that will be generated in the Common folder.
     * For example, if the project name is "@scope/MyProject", the temporary project name
     * might be "@rush-temp/MyProject-2".
     *
     * Example: "@rush-temp/MyProject-2"
     */
    readonly tempProjectName: string;
    /**
     * The unscoped temporary project name
     *
     * Example: "my-project-2"
     */
    readonly unscopedTempProjectName: string;
    /**
     * A flag which indicates whether changes to this project should be published. This controls
     * whether or not the project would show up when running `rush change`, and whether or not it
     * should be published during `rush publish`.
     */
    readonly shouldPublish: boolean;
    /**
     * If true, then this project will be ignored by the "rush check" command.
     * The default value is false.
     */
    readonly skipRushCheck: boolean;
    /**
     * Name of the version policy used by this project.
     * @beta
     */
    readonly versionPolicyName: string | undefined;
    /**
     * Version policy of the project
     * @beta
     */
    readonly versionPolicy: VersionPolicy | undefined;
    /**
     * Indicate whether this project is the main project for the related version policy.
     *
     * False if the project is not for publishing.
     * True if the project is individually versioned or if its lockstep version policy does not specify main project.
     * False if the project is lockstepped and is not the main project for its version policy.
     *
     * @beta
     */
    readonly isMainProject: boolean;
}

/**
 * This is the base class for version policy which controls how versions get bumped.
 * @beta
 */
export declare abstract class VersionPolicy {
    private _policyName;
    private _definitionName;
    /**
     * Loads from version policy json
     *
     * @param versionPolicyJson - version policy Json
     *
     * @internal
     */
    static load(versionPolicyJson: IVersionPolicyJson): VersionPolicy | undefined;
    /**
     * @internal
     */
    constructor(versionPolicyJson: IVersionPolicyJson);
    /**
     * Version policy name
     */
    readonly policyName: string;
    /**
     * Version policy definition name
     */
    readonly definitionName: VersionPolicyDefinitionName;
    /**
     * Whether it is a lockstepped version policy
     */
    readonly isLockstepped: boolean;
    /**
     * Returns an updated package json that satisfies the policy.
     *
     * @param project - package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    abstract ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    /**
     * Bumps version based on the policy
     *
     * @param bumpType - (optional) override bump type
     * @param identifier - (optional) override prerelease Id
     */
    abstract bump(bumpType?: BumpType, identifier?: string): void;
    /**
     * Serialized json for the policy
     *
     * @internal
     */
    readonly abstract _json: IVersionPolicyJson;
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    abstract validate(versionString: string, packageName: string): void;
}

/**
 * Use this class to load and save the "common/config/rush/version-policies.json" config file.
 * This config file configures how different groups of projects will be published by Rush,
 * and how their version numbers will be determined.
 * @beta
 */
export declare class VersionPolicyConfiguration {
    private static _jsonSchema;
    private _versionPolicies;
    private _jsonFileName;
    /**
     * @internal
     */
    constructor(jsonFileName: string);
    /**
     * Validate the version policy configuration against the rush config
     */
    validate(projectsByName: Map<string, RushConfigurationProject>): void;
    /**
     * Gets the version policy by its name.
     * Throws error if the version policy is not found.
     * @param policyName - Name of the version policy
     */
    getVersionPolicy(policyName: string): VersionPolicy;
    /**
     * Gets all the version policies
     */
    readonly versionPolicies: Map<string, VersionPolicy>;
    /**
     * Bumps up versions for the specified version policy or all version policies
     *
     * @param versionPolicyName - version policy name
     * @param bumpType - bump type to override what policy has defined.
     * @param identifier - prerelease identifier to override what policy has defined.
     * @param shouldCommit - should save to disk
     */
    bump(versionPolicyName?: string, bumpType?: BumpType, identifier?: string, shouldCommit?: boolean): void;
    /**
     * Updates the version directly for the specified version policy
     * @param versionPolicyName - version policy name
     * @param newVersion - new version
     */
    update(versionPolicyName: string, newVersion: string): void;
    private _loadFile();
    private _saveFile(shouldCommit);
}

/**
 * Version policy base type names
 * @beta
 */
export declare enum VersionPolicyDefinitionName {
    'lockStepVersion' = 0,
    'individualVersion' = 1,
}
