"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fsx = require("fs-extra");
const semver = require("semver");
const node_core_library_1 = require("@microsoft/node-core-library");
const Rush_1 = require("../Rush");
const RushConfigurationProject_1 = require("./RushConfigurationProject");
const RushConstants_1 = require("../RushConstants");
const ApprovedPackagesPolicy_1 = require("./ApprovedPackagesPolicy");
const EventHooks_1 = require("./EventHooks");
const VersionPolicyConfiguration_1 = require("./VersionPolicyConfiguration");
const EnvironmentConfiguration_1 = require("./EnvironmentConfiguration");
const CommonVersionsConfiguration_1 = require("./CommonVersionsConfiguration");
const Utilities_1 = require("../utilities/Utilities");
const MINIMUM_SUPPORTED_RUSH_JSON_VERSION = '0.0.0';
/**
 * A list of known config filenames that are expected to appear in the "./common/config/rush" folder.
 * To avoid confusion/mistakes, any extra files will be reported as an error.
 */
const knownRushConfigFilenames = [
    '.npmrc',
    RushConstants_1.RushConstants.pinnedVersionsFilename,
    RushConstants_1.RushConstants.commonVersionsFilename,
    RushConstants_1.RushConstants.browserApprovedPackagesFilename,
    RushConstants_1.RushConstants.nonbrowserApprovedPackagesFilename,
    RushConstants_1.RushConstants.versionPoliciesFileName,
    RushConstants_1.RushConstants.commandLineFilename
];
/**
 * This represents the Rush configuration for a repository, based on the "rush.json"
 * configuration file.
 * @public
 */
class RushConfiguration {
    /**
     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    constructor(rushConfigurationJson, rushJsonFilename) {
        EnvironmentConfiguration_1.EnvironmentConfiguration.initialize();
        if (rushConfigurationJson.nodeSupportedVersionRange) {
            if (!semver.validRange(rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error('Error parsing the node-semver expression in the "nodeSupportedVersionRange"'
                    + ` field from rush.json: "${rushConfigurationJson.nodeSupportedVersionRange}"`);
            }
            if (!semver.satisfies(process.version, rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error(`Your dev environment is running Node.js version ${process.version} which does`
                    + ` not meet the requirements for building this repository.  (The rush.json configuration`
                    + ` requires nodeSupportedVersionRange="${rushConfigurationJson.nodeSupportedVersionRange}")`);
            }
        }
        this._rushJsonFile = rushJsonFilename;
        this._rushJsonFolder = path.dirname(rushJsonFilename);
        this._commonFolder = path.resolve(path.join(this._rushJsonFolder, RushConstants_1.RushConstants.commonFolderName));
        this._commonRushConfigFolder = path.join(this._commonFolder, 'config', 'rush');
        this._commonTempFolder = EnvironmentConfiguration_1.EnvironmentConfiguration.rushTempFolderOverride ||
            path.join(this._commonFolder, RushConstants_1.RushConstants.rushTempFolderName);
        this._npmCacheFolder = path.resolve(path.join(this._commonTempFolder, 'npm-cache'));
        this._npmTmpFolder = path.resolve(path.join(this._commonTempFolder, 'npm-tmp'));
        this._pnpmStoreFolder = path.resolve(path.join(this._commonTempFolder, 'pnpm-store'));
        this._changesFolder = path.join(this._commonFolder, RushConstants_1.RushConstants.changeFilesFolderName);
        this._rushUserFolder = path.join(Utilities_1.Utilities.getHomeDirectory(), '.rush');
        this._rushLinkJsonFilename = path.join(this._commonTempFolder, 'rush-link.json');
        if (rushConfigurationJson.npmVersion) {
            this._packageManager = 'npm';
            this._committedShrinkwrapFilename = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.npmShrinkwrapFilename);
            this._tempShrinkwrapFilename = path.join(this._commonTempFolder, RushConstants_1.RushConstants.npmShrinkwrapFilename);
            this._packageManagerToolVersion = rushConfigurationJson.npmVersion;
            this._packageManagerToolFilename = path.resolve(path.join(this._commonTempFolder, 'npm-local', 'node_modules', '.bin', 'npm'));
        }
        else if (rushConfigurationJson.pnpmVersion) {
            this._packageManager = 'pnpm';
            this._committedShrinkwrapFilename = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.pnpmShrinkwrapFilename);
            this._tempShrinkwrapFilename = path.join(this._commonTempFolder, RushConstants_1.RushConstants.pnpmShrinkwrapFilename);
            this._packageManagerToolVersion = rushConfigurationJson.pnpmVersion;
            this._packageManagerToolFilename = path.resolve(path.join(this._commonTempFolder, 'pnpm-local', 'node_modules', '.bin', 'pnpm'));
        }
        else {
            throw new Error(`Neither "npmVersion" nor "pnpmVersion" was defined in the rush configuration.`);
        }
        /// From "C:\repo\common\temp\shrinkwrap.yaml" --> "C:\repo\common\temp\shrinkwrap-preinstall.yaml"
        const parsedPath = path.parse(this._tempShrinkwrapFilename);
        this._tempShrinkwrapPreinstallFilename = path.join(parsedPath.dir, parsedPath.name + '-preinstall' + parsedPath.ext);
        RushConfiguration._validateCommonRushConfigFolder(this._commonRushConfigFolder, this.packageManager);
        this._projectFolderMinDepth = rushConfigurationJson.projectFolderMinDepth !== undefined
            ? rushConfigurationJson.projectFolderMinDepth : 1;
        if (this._projectFolderMinDepth < 1) {
            throw new Error('Invalid projectFolderMinDepth; the minimum possible value is 1');
        }
        this._projectFolderMaxDepth = rushConfigurationJson.projectFolderMaxDepth !== undefined
            ? rushConfigurationJson.projectFolderMaxDepth : 2;
        if (this._projectFolderMaxDepth < this._projectFolderMinDepth) {
            throw new Error('The projectFolderMaxDepth cannot be smaller than the projectFolderMinDepth');
        }
        this._approvedPackagesPolicy = new ApprovedPackagesPolicy_1.ApprovedPackagesPolicy(this, rushConfigurationJson);
        this._gitAllowedEmailRegExps = [];
        this._gitSampleEmail = '';
        if (rushConfigurationJson.gitPolicy) {
            if (rushConfigurationJson.gitPolicy.sampleEmail) {
                this._gitSampleEmail = rushConfigurationJson.gitPolicy.sampleEmail;
            }
            if (rushConfigurationJson.gitPolicy.allowedEmailRegExps) {
                this._gitAllowedEmailRegExps = rushConfigurationJson.gitPolicy.allowedEmailRegExps;
                if (this._gitSampleEmail.trim().length < 1) {
                    throw new Error('The rush.json file is missing the "sampleEmail" option, ' +
                        'which is required when using "allowedEmailRegExps"');
                }
            }
        }
        this._hotfixChangeEnabled = false;
        if (rushConfigurationJson.hotfixChangeEnabled) {
            this._hotfixChangeEnabled = rushConfigurationJson.hotfixChangeEnabled;
        }
        if (rushConfigurationJson.repository) {
            this._repositoryUrl = rushConfigurationJson.repository.url;
        }
        this._telemetryEnabled = !!rushConfigurationJson.telemetryEnabled;
        if (rushConfigurationJson.eventHooks) {
            this._eventHooks = new EventHooks_1.EventHooks(rushConfigurationJson.eventHooks);
        }
        const versionPolicyConfigFile = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.versionPoliciesFileName);
        this._versionPolicyConfiguration = new VersionPolicyConfiguration_1.VersionPolicyConfiguration(versionPolicyConfigFile);
        this._projects = [];
        this._projectsByName = new Map();
        // We sort the projects array in alphabetical order.  This ensures that the packages
        // are processed in a deterministic order by the various Rush algorithms.
        const sortedProjectJsons = rushConfigurationJson.projects.slice(0);
        sortedProjectJsons.sort((a, b) => a.packageName.localeCompare(b.packageName));
        const tempNamesByProject = RushConfiguration._generateTempNamesForProjects(sortedProjectJsons);
        for (const projectJson of sortedProjectJsons) {
            const tempProjectName = tempNamesByProject.get(projectJson);
            if (tempProjectName) {
                const project = new RushConfigurationProject_1.RushConfigurationProject(projectJson, this, tempProjectName);
                this._projects.push(project);
                if (this._projectsByName.get(project.packageName)) {
                    throw new Error(`The project name "${project.packageName}" was specified more than once`
                        + ` in the rush.json configuration file.`);
                }
                this._projectsByName.set(project.packageName, project);
            }
        }
        for (const project of this._projects) {
            project.cyclicDependencyProjects.forEach((cyclicDependencyProject) => {
                if (!this.getProjectByName(cyclicDependencyProject)) {
                    throw new Error(`In rush.json, the "${cyclicDependencyProject}" project does not exist,`
                        + ` but was referenced by the cyclicDependencyProjects for ${project.packageName}`);
                }
            });
            // Compute the downstream dependencies within the list of Rush projects.
            this._populateDownstreamDependencies(project.packageJson.dependencies, project.packageName);
            this._populateDownstreamDependencies(project.packageJson.devDependencies, project.packageName);
            this._versionPolicyConfiguration.validate(this._projectsByName);
        }
        // Example: "./common/config/rush/common-versions.json"
        const commonVersionsFilename = path.join(this.commonRushConfigFolder, RushConstants_1.RushConstants.commonVersionsFilename);
        this._commonVersions = CommonVersionsConfiguration_1.CommonVersionsConfiguration.loadFromFile(commonVersionsFilename);
    }
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    static loadFromConfigurationFile(rushJsonFilename) {
        const rushConfigurationJson = node_core_library_1.JsonFile.load(rushJsonFilename);
        // Check the Rush version *before* we validate the schema, since if the version is outdated
        // then the schema may have changed. This should no longer be a problem after Rush 4.0 and the C2R wrapper,
        // but we'll validate anyway.
        const expectedRushVersion = rushConfigurationJson.rushVersion;
        const rushJsonBaseName = path.basename(rushJsonFilename);
        // If the version is missing or malformed, fall through and let the schema handle it.
        if (expectedRushVersion && semver.valid(expectedRushVersion)) {
            // Make sure the requested version isn't too old
            if (semver.lt(expectedRushVersion, MINIMUM_SUPPORTED_RUSH_JSON_VERSION)) {
                throw new Error(`${rushJsonBaseName} is version ${expectedRushVersion}, which is too old for this tool. ` +
                    `The minimum supported version is ${MINIMUM_SUPPORTED_RUSH_JSON_VERSION}.`);
            }
            // Make sure the requested version isn't too new.
            //
            // If the major/minor versions are the same, then we consider the file to be compatible.
            // This is somewhat lax, e.g. "5.0.2-dev.3" will be assumed to be loadable by rush-lib 5.0.0.
            //
            // IMPORTANT: Whenever a breaking change is introduced for one of the config files, we must
            // increment the minor version number for Rush.
            if (semver.major(Rush_1.Rush.version) !== semver.major(expectedRushVersion)
                || semver.minor(Rush_1.Rush.version) !== semver.minor(expectedRushVersion)) {
                // If the major/minor are different, then make sure it's an older version.
                if (semver.lt(Rush_1.Rush.version, expectedRushVersion)) {
                    throw new Error(`Unable to load ${rushJsonBaseName} because its RushVersion is`
                        + ` ${rushConfigurationJson.rushVersion}, whereas @microsoft/rush-lib is version ${Rush_1.Rush.version}.`
                        + ` Consider upgrading the library.`);
                }
            }
        }
        RushConfiguration._jsonSchema.validateObject(rushConfigurationJson, rushJsonFilename);
        return new RushConfiguration(rushConfigurationJson, rushJsonFilename);
    }
    static loadFromDefaultLocation() {
        const rushJsonLocation = RushConfiguration.tryFindRushJsonLocation();
        if (rushJsonLocation) {
            return RushConfiguration.loadFromConfigurationFile(rushJsonLocation);
        }
        else {
            throw new Error('Unable to find rush.json configuration file');
        }
    }
    /**
     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
     */
    static tryFindRushJsonLocation(verbose = true) {
        let currentFolder = process.cwd();
        // Look upwards at parent folders until we find a folder containing rush.json
        for (let i = 0; i < 10; ++i) {
            const rushJsonFilename = path.join(currentFolder, 'rush.json');
            if (fsx.existsSync(rushJsonFilename)) {
                if (i > 0 && verbose) {
                    console.log('Found configuration in ' + rushJsonFilename);
                }
                if (verbose) {
                    console.log('');
                }
                return rushJsonFilename;
            }
            const parentFolder = path.dirname(currentFolder);
            if (parentFolder === currentFolder) {
                break;
            }
            currentFolder = parentFolder;
        }
        return undefined;
    }
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    static _generateTempNamesForProjects(sortedProjectJsons) {
        const tempNamesByProject = new Map();
        const usedTempNames = new Set();
        // NOTE: projectJsons was already sorted in alphabetical order by the caller.
        for (const projectJson of sortedProjectJsons) {
            // If the name is "@ms/MyProject", extract the "MyProject" part
            const unscopedName = node_core_library_1.PackageName.getUnscopedName(projectJson.packageName);
            // Generate a unique like name "@rush-temp/MyProject", or "@rush-temp/MyProject-2" if
            // there is a naming conflict
            let counter = 0;
            let tempProjectName = `${RushConstants_1.RushConstants.rushTempNpmScope}/${unscopedName}`;
            while (usedTempNames.has(tempProjectName)) {
                ++counter;
                tempProjectName = `${RushConstants_1.RushConstants.rushTempNpmScope}/${unscopedName}-${counter}`;
            }
            usedTempNames.add(tempProjectName);
            tempNamesByProject.set(projectJson, tempProjectName);
        }
        return tempNamesByProject;
    }
    /**
     * If someone adds a config file in the "common/rush/config" folder, it would be a bad
     * experience for Rush to silently ignore their file simply because they misspelled the
     * filename, or maybe it's an old format that's no longer supported.  The
     * _validateCommonRushConfigFolder() function makes sure that this folder only contains
     * recognized config files.
     */
    static _validateCommonRushConfigFolder(commonRushConfigFolder, packageManager) {
        if (!fsx.existsSync(commonRushConfigFolder)) {
            console.log(`Creating folder: ${commonRushConfigFolder}`);
            fsx.mkdirsSync(commonRushConfigFolder);
            return;
        }
        const filenames = fsx.readdirSync(commonRushConfigFolder);
        for (const filename of filenames) {
            const resolvedFilename = path.resolve(commonRushConfigFolder, filename);
            // Ignore things that aren't actual files
            const stat = fsx.lstatSync(resolvedFilename);
            if (!stat.isFile() && !stat.isSymbolicLink()) {
                continue;
            }
            // Ignore harmless file extensions
            const fileExtension = path.extname(filename);
            if (['.bak', '.disabled', '.md', '.old', '.orig'].indexOf(fileExtension) >= 0) {
                continue;
            }
            const knownSet = new Set(knownRushConfigFilenames.map(x => x.toUpperCase()));
            if (packageManager === 'npm') {
                knownSet.add(RushConstants_1.RushConstants.npmShrinkwrapFilename.toUpperCase());
            }
            else if (packageManager === 'pnpm') {
                knownSet.add(RushConstants_1.RushConstants.pnpmShrinkwrapFilename.toUpperCase());
                knownSet.add(RushConstants_1.RushConstants.pnpmFileFilename.toUpperCase());
            }
            // Is the filename something we know?  If not, report an error.
            if (!knownSet.has(filename.toUpperCase())) {
                throw new Error(`An unrecognized file "${filename}" was found in the Rush config folder:`
                    + ` ${commonRushConfigFolder}`);
            }
        }
        const pinnedVersionsFilename = path.join(commonRushConfigFolder, RushConstants_1.RushConstants.pinnedVersionsFilename);
        if (fsx.existsSync(pinnedVersionsFilename)) {
            throw new Error('The "pinned-versions.json" config file is no longer supported;'
                + ' please move your settings to the "preferredVersions" field of a "common-versions.json" config file.'
                + ` (See the ${RushConstants_1.RushConstants.rushWebSiteUrl} documentation for details.)\n\n`
                + pinnedVersionsFilename);
        }
    }
    /**
     * The name of the package manager being used to install dependencies
     */
    get packageManager() {
        return this._packageManager;
    }
    /**
     * The Rush configuration file
     */
    get rushJsonFile() {
        return this._rushJsonFile;
    }
    /**
     * The folder that contains rush.json for this project.
     */
    get rushJsonFolder() {
        return this._rushJsonFolder;
    }
    /**
     * The folder that contains all change files.
     */
    get changesFolder() {
        return this._changesFolder;
    }
    /**
     * The fully resolved path for the "common" folder where Rush will store settings that
     * affect all Rush projects.  This is always a subfolder of the folder containing "rush.json".
     * Example: "C:\MyRepo\common"
     */
    get commonFolder() {
        return this._commonFolder;
    }
    /**
     * The folder where Rush's additional config files are stored.  This folder is always a
     * subfolder called "config\rush" inside the common folder.  (The "common\config" folder
     * is reserved for configuration files used by other tools.)  To avoid confusion or mistakes,
     * Rush will report an error if this this folder contains any unrecognized files.
     *
     * Example: "C:\MyRepo\common\config\rush"
     */
    get commonRushConfigFolder() {
        return this._commonRushConfigFolder;
    }
    /**
     * The folder where temporary files will be stored.  This is always a subfolder called "temp"
     * inside the common folder.
     * Example: "C:\MyRepo\common\temp"
     */
    get commonTempFolder() {
        return this._commonTempFolder;
    }
    /**
     * The local folder that will store the NPM package cache.  Rush does not rely on the
     * npm's default global cache folder, because npm's caching implementation does not
     * reliably handle multiple processes.  (For example, if a build box is running
     * "rush install" simultaneously for two different working folders, it may fail randomly.)
     *
     * Example: "C:\MyRepo\common\temp\npm-cache"
     */
    get npmCacheFolder() {
        return this._npmCacheFolder;
    }
    /**
     * The local folder where npm's temporary files will be written during installation.
     * Rush does not rely on the global default folder, because it may be on a different
     * hard disk.
     *
     * Example: "C:\MyRepo\common\temp\npm-tmp"
     */
    get npmTmpFolder() {
        return this._npmTmpFolder;
    }
    /**
     * The local folder where PNPM stores a global installation for every installed package
     *
     * Example: "C:\MyRepo\common\temp\pnpm-store"
     */
    get pnpmStoreFolder() {
        return this._pnpmStoreFolder;
    }
    /**
     * The full path of the shrinkwrap file that is tracked by Git.  (The "rush install"
     * command uses a temporary copy, whose path is tempShrinkwrapFilename.)
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: "C:\MyRepo\common\npm-shrinkwrap.json" or "C:\MyRepo\common\shrinkwrap.yaml"
     */
    get committedShrinkwrapFilename() {
        return this._committedShrinkwrapFilename;
    }
    /**
     * The full path of the temporary shrinkwrap file that is used during "rush install".
     * This file may get rewritten by the package manager during installation.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: "C:\MyRepo\common\temp\npm-shrinkwrap.json" or "C:\MyRepo\common\temp\shrinkwrap.yaml"
     */
    get tempShrinkwrapFilename() {
        return this._tempShrinkwrapFilename;
    }
    /**
     * The full path of a backup copy of tempShrinkwrapFilename. This backup copy is made
     * before installation begins, and can be compared to determine how the package manager
     * modified tempShrinkwrapFilename.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: "C:\MyRepo\common\temp\npm-shrinkwrap-preinstall.json"
     * or "C:\MyRepo\common\temp\shrinkwrap-preinstall.yaml"
     */
    get tempShrinkwrapPreinstallFilename() {
        return this._tempShrinkwrapPreinstallFilename;
    }
    /**
     * The absolute path to Rush's storage in the home directory for the current user.  On Windows,
     * it would be something like "C:\Users\YourName\.rush".
     */
    get rushUserFolder() {
        return this._rushUserFolder;
    }
    /**
     * The filename of the build dependency data file.  By default this is
     * called 'rush-link.json' resides in the Rush common folder.
     * Its data structure is defined by IRushLinkJson.
     *
     * Example: "C:\MyRepo\common\temp\rush-link.json"
     */
    get rushLinkJsonFilename() {
        return this._rushLinkJsonFilename;
    }
    /**
     * The version of the locally installed NPM tool.  (Example: "1.2.3")
     */
    get packageManagerToolVersion() {
        return this._packageManagerToolVersion;
    }
    /**
     * The absolute path to the locally installed NPM tool.  If "rush install" has not
     * been run, then this file may not exist yet.
     * Example: "C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm"
     */
    get packageManagerToolFilename() {
        return this._packageManagerToolFilename;
    }
    /**
     * The minimum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements a standard 2-level hierarchy of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMinDepth() {
        return this._projectFolderMinDepth;
    }
    /**
     * The maximum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements on a standard convention of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMaxDepth() {
        return this._projectFolderMaxDepth;
    }
    /**
     * The "approvedPackagesPolicy" settings.
     */
    get approvedPackagesPolicy() {
        return this._approvedPackagesPolicy;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * A list of regular expressions describing allowable e-mail patterns for Git commits.
     * They are case-insensitive anchored JavaScript RegExps.
     * Example: ".*@example\.com"
     * This array will never be undefined.
     */
    get gitAllowedEmailRegExps() {
        return this._gitAllowedEmailRegExps;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * An example valid e-mail address that conforms to one of the allowedEmailRegExps.
     * Example: "foxtrot@example\.com"
     * This will never be undefined, and will always be nonempty if gitAllowedEmailRegExps is used.
     */
    get gitSampleEmail() {
        return this._gitSampleEmail;
    }
    /**
     * [Part of the "hotfixChange" feature.]
     * Enables creating hotfix changes
     */
    get hotfixChangeEnabled() {
        return this._hotfixChangeEnabled;
    }
    /**
     * The remote url of the repository. It helps 'Rush change' finds the right remote to compare against.
     */
    get repositoryUrl() {
        return this._repositoryUrl;
    }
    /**
     * Indicates whether telemetry collection is enabled for Rush runs.
     * @beta
     */
    get telemetryEnabled() {
        return this._telemetryEnabled;
    }
    get projects() {
        return this._projects;
    }
    get projectsByName() {
        return this._projectsByName;
    }
    /**
     * Settings from the common-versions.json config file.
     * @remarks
     * If the common-versions.json file is missing, this property will not be undefined.
     * Instead it will be initialized in an empty state, and calling CommonVersionsConfiguration.save()
     * will create the file.
     */
    get commonVersions() {
        return this._commonVersions;
    }
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     * @beta
     */
    get eventHooks() {
        return this._eventHooks;
    }
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    getProjectByName(projectName) {
        return this._projectsByName.get(projectName);
    }
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like "@something/example".  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    findProjectByShorthandName(shorthandProjectName) {
        // Is there an exact match?
        let result = this._projectsByName.get(shorthandProjectName);
        if (result) {
            return result;
        }
        // Is there an approximate match?
        for (const project of this._projects) {
            if (node_core_library_1.PackageName.getUnscopedName(project.packageName) === shorthandProjectName) {
                if (result) {
                    // Ambiguous -- there is more than one match
                    return undefined;
                }
                else {
                    result = project;
                }
            }
        }
        return result;
    }
    /**
     * Looks up a project by its RushConfigurationProject.tempProjectName field.
     * @returns The found project, or undefined if no match was found.
     */
    findProjectByTempName(tempProjectName) {
        // Is there an approximate match?
        for (const project of this._projects) {
            if (project.tempProjectName === tempProjectName) {
                return project;
            }
        }
        return undefined;
    }
    /**
     * @beta
     */
    get versionPolicyConfiguration() {
        return this._versionPolicyConfiguration;
    }
    _populateDownstreamDependencies(dependencies, packageName) {
        if (!dependencies) {
            return;
        }
        Object.keys(dependencies).forEach(dependencyName => {
            const depProject = this._projectsByName.get(dependencyName);
            if (depProject) {
                depProject.downstreamDependencyProjects.push(packageName);
            }
        });
    }
}
RushConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/rush.schema.json'));
exports.RushConfiguration = RushConfiguration;

//# sourceMappingURL=RushConfiguration.js.map
