"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @public
 */
class VersionMismatchFinder {
    constructor(projects, allowedAlternativeVersions) {
        this._projects = projects;
        this._mismatches = new Map();
        this._allowedAlternativeVersion = allowedAlternativeVersions || new Map();
        this._analyze();
    }
    get numberOfMismatches() {
        return this._mismatches.size;
    }
    getMismatches() {
        return this._getKeys(this._mismatches);
    }
    getVersionsOfMismatch(mismatch) {
        return this._mismatches.has(mismatch)
            ? this._getKeys(this._mismatches.get(mismatch))
            : undefined;
    }
    getConsumersOfMismatch(mismatch, version) {
        const mismatchedPackage = this._mismatches.get(mismatch);
        if (!mismatchedPackage) {
            return undefined;
        }
        const mismatchedVersion = mismatchedPackage.get(version);
        return mismatchedVersion;
    }
    _analyze() {
        this._projects.forEach((project) => {
            if (!project.skipRushCheck) {
                // NOTE: We do not consider peer dependencies here.  The purpose of "rush check" is
                // mainly to avoid side-by-side duplicates in the node_modules folder, whereas
                // peer dependencies are just a compatibility statement that will be satisfied by a
                // regular dependency.  (It might be useful for Rush to help people keep their peer dependency
                // patterns consistent, but on the other hand different projects may have different
                // levels of compatibility -- we should wait for someone to actually request this feature
                // before we get into that.)
                this._addDependenciesToList(project.packageName, project.packageJson.dependencies, project.cyclicDependencyProjects);
                this._addDependenciesToList(project.packageName, project.packageJson.devDependencies, project.cyclicDependencyProjects);
                this._addDependenciesToList(project.packageName, project.packageJson.optionalDependencies, project.cyclicDependencyProjects);
            }
        });
        this._mismatches.forEach((mismatches, project) => {
            if (mismatches.size <= 1) {
                this._mismatches.delete(project);
            }
        });
    }
    _addDependenciesToList(project, dependencyMap, exclude) {
        if (dependencyMap) {
            Object.keys(dependencyMap).forEach((dependency) => {
                if (!exclude || !exclude.has(dependency)) {
                    const version = dependencyMap[dependency];
                    if (this._isVersionAllowedAlternative(dependency, version)) {
                        return;
                    }
                    if (!this._mismatches.has(dependency)) {
                        this._mismatches.set(dependency, new Map());
                    }
                    const dependencyVersions = this._mismatches.get(dependency);
                    if (!dependencyVersions.has(version)) {
                        dependencyVersions.set(version, []);
                    }
                    dependencyVersions.get(version).push(project);
                }
            });
        }
    }
    _isVersionAllowedAlternative(dependency, version) {
        const allowedAlternatives = this._allowedAlternativeVersion.get(dependency);
        return Boolean(allowedAlternatives && allowedAlternatives.indexOf(version) > -1);
    }
    // tslint:disable-next-line:no-any
    _getKeys(iterable) {
        const keys = [];
        if (iterable) {
            // tslint:disable-next-line:no-any
            iterable.forEach((value, key) => {
                keys.push(key);
            });
        }
        return keys;
    }
}
exports.VersionMismatchFinder = VersionMismatchFinder;

//# sourceMappingURL=VersionMismatchFinder.js.map
