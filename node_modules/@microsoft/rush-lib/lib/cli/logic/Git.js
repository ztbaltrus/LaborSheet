"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const gitInfo = require("git-repo-info");
const child_process = require("child_process");
const PublishUtilities_1 = require("./PublishUtilities");
class Git {
    static detectIfGitIsSupported() {
        const command = process.platform === 'win32' ? 'where' : 'which';
        const result = child_process.spawnSync(command, ['git']);
        if (result.status !== 0) {
            return false;
        }
        try {
            return !!gitInfo().sha;
        }
        catch (e) {
            return false; // Unexpected, but possible if the .git directory is corrupted.
        }
    }
    constructor(targetBranch) {
        this._targetBranch = targetBranch;
    }
    checkout(branchName, createBranch) {
        const params = `checkout ${createBranch ? '-b ' : ''}${branchName}`;
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, 'git', params.split(' '));
    }
    merge(branchName) {
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, 'git', `merge ${branchName} --no-edit`.split(' '));
    }
    deleteBranch(branchName, hasRemote = true) {
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, 'git', `branch -d ${branchName}`.split(' '));
        if (hasRemote) {
            PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, 'git', `push origin --delete ${branchName}`.split(' '));
        }
    }
    pull() {
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, 'git', `pull origin ${this._targetBranch}`.split(' '));
    }
    addChanges(pathspec, workingDirectory) {
        const files = pathspec ? pathspec : '.';
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, 'git', ['add', files], workingDirectory ? workingDirectory : process.cwd());
    }
    addTag(shouldExecute, packageName, packageVersion) {
        // Tagging only happens if we're publishing to real NPM and committing to git.
        const tagName = PublishUtilities_1.PublishUtilities.createTagname(packageName, packageVersion);
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch && shouldExecute, 'git', ['tag', '-a', tagName, '-m', `${packageName} v${packageVersion}`]);
    }
    commit(message) {
        const commitMessage = message ? message : 'Applying package updates.';
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, 'git', ['commit', '-m', commitMessage]);
    }
    push(branchName) {
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, 'git', ['push', 'origin', 'HEAD:' + branchName, '--follow-tags', '--verbose']);
    }
}
exports.Git = Git;

//# sourceMappingURL=Git.js.map
