"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const colors = require("colors");
const wordwrap = require("wordwrap");
const ts_command_line_1 = require("@microsoft/ts-command-line");
const RushConstants_1 = require("../../RushConstants");
const CommandLineConfiguration_1 = require("../../data/CommandLineConfiguration");
const RushConfiguration_1 = require("../../data/RushConfiguration");
const Utilities_1 = require("../../utilities/Utilities");
const ChangeAction_1 = require("./ChangeAction");
const CheckAction_1 = require("./CheckAction");
const UpdateAction_1 = require("./UpdateAction");
const InstallAction_1 = require("./InstallAction");
const LinkAction_1 = require("./LinkAction");
const PublishAction_1 = require("./PublishAction");
const PurgeAction_1 = require("./PurgeAction");
const UnlinkAction_1 = require("./UnlinkAction");
const ScanAction_1 = require("./ScanAction");
const VersionAction_1 = require("./VersionAction");
const CustomCommandFactory_1 = require("./CustomCommandFactory");
const Telemetry_1 = require("../logic/Telemetry");
const AlreadyReportedError_1 = require("../../utilities/AlreadyReportedError");
class RushCommandLineParser extends ts_command_line_1.CommandLineParser {
    constructor() {
        super({
            toolFilename: 'rush',
            toolDescription: 'Rush makes life easier for JavaScript developers who develop, build, and publish'
                + ' many packages from a central Git repo.  It is designed to handle very large repositories'
                + ' supporting many projects and people.  Rush provides policies, protections, and customizations'
                + ' that help coordinate teams and safely onboard new contributors.  Rush also generates change logs'
                + ' and automates package publishing.  It can manage decoupled subsets of projects with different'
                + ' release and versioning strategies.  A full API is included to facilitate integration with other'
                + ' automation tools.  If you are looking for a proven turnkey solution for monorepo management,'
                + ' Rush is for you.'
        });
        this._populateActions();
    }
    get isDebug() {
        return this._debugParameter.value;
    }
    flushTelemetry() {
        if (this.telemetry) {
            this.telemetry.flush();
        }
    }
    onDefineParameters() {
        this._debugParameter = this.defineFlagParameter({
            parameterLongName: '--debug',
            parameterShortName: '-d',
            description: 'Show the full call stack if an error occurs while executing the tool'
        });
    }
    onExecute() {
        return this._wrapOnExecute().catch((error) => {
            this._reportErrorAndSetExitCode(error);
        });
    }
    _wrapOnExecute() {
        try {
            if (this.rushConfiguration) {
                this.telemetry = new Telemetry_1.Telemetry(this.rushConfiguration);
            }
            return super.onExecute().then(() => {
                if (this.telemetry) {
                    this.flushTelemetry();
                }
            });
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    _populateActions() {
        try {
            let commandLineConfig = undefined;
            const rushJsonFilename = RushConfiguration_1.RushConfiguration.tryFindRushJsonLocation();
            if (rushJsonFilename) {
                this.rushConfiguration = RushConfiguration_1.RushConfiguration.loadFromConfigurationFile(rushJsonFilename);
                const commandLineConfigFile = path.join(this.rushConfiguration.commonRushConfigFolder, RushConstants_1.RushConstants.commandLineFilename);
                commandLineConfig = CommandLineConfiguration_1.CommandLineConfiguration.tryLoadFromFile(commandLineConfigFile);
            }
            this.addAction(new ChangeAction_1.ChangeAction(this));
            this.addAction(new CheckAction_1.CheckAction(this));
            this.addAction(new InstallAction_1.InstallAction(this));
            this.addAction(new LinkAction_1.LinkAction(this));
            this.addAction(new PublishAction_1.PublishAction(this));
            this.addAction(new PurgeAction_1.PurgeAction(this));
            this.addAction(new ScanAction_1.ScanAction(this));
            this.addAction(new UpdateAction_1.UpdateAction(this));
            this.addAction(new UnlinkAction_1.UnlinkAction(this));
            this.addAction(new VersionAction_1.VersionAction(this));
            CustomCommandFactory_1.CustomCommandFactory.createCommands(this, commandLineConfig)
                .forEach((customAction) => {
                this.addAction(customAction);
            });
        }
        catch (error) {
            this._reportErrorAndSetExitCode(error);
        }
    }
    _reportErrorAndSetExitCode(error) {
        if (!(error instanceof AlreadyReportedError_1.AlreadyReportedError)) {
            const prefix = 'ERROR: ';
            const wrap = wordwrap.soft(prefix.length, Utilities_1.Utilities.getConsoleWidth());
            console.error(os.EOL + colors.red(prefix + wrap(error.message).trim()));
        }
        if (this._debugParameter.value) {
            // If catchSyncErrors() called this, then show a call stack similar to what NodeJS
            // would show for an uncaught error
            console.error(os.EOL + error.stack);
        }
        this.flushTelemetry();
        // Ideally we want to remove all calls to process.exit() from our code, and replace them
        // with normal control flow that properly cleans up its data structures.
        // For this particular call, we have a problem that the RushCommandLineParser constructor
        // performs nontrivial work that can throw an exception.  Either the Rush class would need
        // to handle reporting for those exceptions, or else _populateActions() should be moved
        // to a RushCommandLineParser lifecycle stage that can handle it.
        process.exit(1);
    }
}
exports.RushCommandLineParser = RushCommandLineParser;

//# sourceMappingURL=RushCommandLineParser.js.map
