"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const os = require("os");
const BaseRushAction_1 = require("./BaseRushAction");
const EventHooks_1 = require("../../data/EventHooks");
const InstallManager_1 = require("../logic/InstallManager");
const PurgeManager_1 = require("../logic/PurgeManager");
const Stopwatch_1 = require("../../utilities/Stopwatch");
/**
 * This is the common base class for InstallAction and UpdateAction.
 */
class BaseInstallAction extends BaseRushAction_1.BaseRushAction {
    onDefineParameters() {
        this._purgeParameter = this.defineFlagParameter({
            parameterLongName: '--purge',
            parameterShortName: '-p',
            description: 'Perform "rush purge" before starting the installation'
        });
        this._bypassPolicyParameter = this.defineFlagParameter({
            parameterLongName: '--bypass-policy',
            description: 'Overrides enforcement of the "gitPolicy" rules from rush.json (use honorably!)'
        });
        this._noLinkParameter = this.defineFlagParameter({
            parameterLongName: '--no-link',
            description: 'If "--no-link" is specified, then project symlinks will NOT be created'
                + ' after the installation completes.  You will need to run "rush link" manually.'
                + ' This flag is useful for automated builds that want to report stages individually'
                + ' or perform extra operations in between the two stages.'
        });
    }
    run() {
        const stopwatch = Stopwatch_1.Stopwatch.start();
        this.eventHooksManager.handle(EventHooks_1.Event.preRushInstall, this.parser.isDebug);
        const purgeManager = new PurgeManager_1.PurgeManager(this.rushConfiguration);
        const installManager = new InstallManager_1.InstallManager(this.rushConfiguration, purgeManager);
        if (this._purgeParameter.value) {
            console.log('The --purge flag was specified, so performing "rush purge"');
            purgeManager.purgeNormal();
            console.log('');
        }
        const installManagerOptions = this.buildInstallOptions();
        return installManager.doInstall(installManagerOptions)
            .then(() => {
            purgeManager.deleteAll();
            stopwatch.stop();
            this._collectTelemetry(stopwatch, installManagerOptions, true);
            this.eventHooksManager.handle(EventHooks_1.Event.postRushInstall, this.parser.isDebug);
            console.log(os.EOL + colors.green(`Rush ${this.actionName} finished successfully. (${stopwatch.toString()})`));
        })
            .catch((error) => {
            purgeManager.deleteAll();
            stopwatch.stop();
            this._collectTelemetry(stopwatch, installManagerOptions, false);
            throw error;
        });
    }
    _collectTelemetry(stopwatch, installManagerOptions, success) {
        if (this.parser.telemetry) {
            this.parser.telemetry.log({
                name: 'install',
                duration: stopwatch.duration,
                result: success ? 'Succeeded' : 'Failed',
                extraData: {
                    mode: this.actionName,
                    clean: (!!this._purgeParameter.value).toString(),
                    full: installManagerOptions.fullUpgrade.toString()
                }
            });
        }
    }
}
exports.BaseInstallAction = BaseInstallAction;

//# sourceMappingURL=BaseInstallAction.js.map
