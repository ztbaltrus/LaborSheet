"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const RushConstants_1 = require("../../RushConstants");
const VersionMismatchFinder_1 = require("../../data/VersionMismatchFinder");
const BaseRushAction_1 = require("./BaseRushAction");
class CheckAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'check',
            summary: 'Checks each project\'s package.json files and ensures that all dependencies are of the same ' +
                'version throughout the repository.',
            documentation: 'Checks each project\'s package.json files and ensures that all dependencies are of the ' +
                'same version throughout the repository.',
            safeForSimultaneousRushProcesses: true,
            parser
        });
    }
    onDefineParameters() {
        // abstract
    }
    run() {
        // Collect all the preferred versions into a single table
        const allPreferredVersions = {};
        this.rushConfiguration.commonVersions.getAllPreferredVersions().forEach((version, dependency) => {
            allPreferredVersions[dependency] = version;
        });
        // Create a fake project for the purposes of reporting conflicts with preferredVersions
        // or xstitchPreferredVersions from common-versions.json
        this.rushConfiguration.projects.push({
            packageName: 'preferred versions from ' + RushConstants_1.RushConstants.commonVersionsFilename,
            packageJson: { dependencies: allPreferredVersions }
        });
        const mismatchFinder = new VersionMismatchFinder_1.VersionMismatchFinder(this.rushConfiguration.projects, this.rushConfiguration.commonVersions.allowedAlternativeVersions);
        // Iterate over the list. For any dependency with mismatching versions, print the projects
        mismatchFinder.getMismatches().forEach((dependency) => {
            console.log(colors.yellow(dependency));
            mismatchFinder.getVersionsOfMismatch(dependency).forEach((version) => {
                console.log(`  ${version}`);
                mismatchFinder.getConsumersOfMismatch(dependency, version).forEach((project) => {
                    console.log(`   - ${project}`);
                });
            });
            console.log();
        });
        if (mismatchFinder.numberOfMismatches) {
            console.log(colors.red(`Found ${mismatchFinder.numberOfMismatches} mis-matching dependencies!`));
            process.exit(1);
        }
        else {
            console.log(colors.green(`Found no mis-matching dependencies!`));
        }
        return Promise.resolve();
    }
}
exports.CheckAction = CheckAction;

//# sourceMappingURL=CheckAction.js.map
