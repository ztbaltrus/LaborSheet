{"version":3,"sources":["utilities/LastInstallFlag.ts"],"names":[],"mappings":";;AAAA,6BAA6B;AAC7B,gCAAgC;AAChC,4BAA4B;AAEf,QAAA,2BAA2B,GAAW,mBAAmB,CAAC;AAEvE;;;;;;GAMG;AACH;IAIE;;;;MAIE;IACF,YAAY,UAAkB,EAAE,QAAgB,EAAE;QAChD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,mCAA2B,CAAC,CAAC;QAChE,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;IACtB,CAAC;IAED;;OAEG;IACI,OAAO;QACZ,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAChC,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;QACD,IAAI,CAAC;YACH,MAAM,QAAQ,GAAW,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACtD,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QAC1C,CAAC;QAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACf,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IAED;;OAEG;IACI,MAAM;QACX,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QACzC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7C,CAAC;IAED;;OAEG;IACI,KAAK;QACV,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;IAED;;OAEG;IACH,IAAW,IAAI;QACb,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;CACF;AAlDD,0CAkDC","file":"LastInstallFlag.js","sourcesContent":["import * as path from 'path';\r\nimport * as fsx from 'fs-extra';\r\nimport * as _ from 'lodash';\r\n\r\nexport const LAST_INSTALL_FLAG_FILE_NAME: string = 'last-install.flag';\r\n\r\n/**\r\n * A helper class for managing last-install flags, which are persistent and\r\n * indicate that something installed in the folder was sucessfully completed.\r\n * It also compares state, so that if something like the Node.js version has changed,\r\n * it can invalidate the last install.\r\n * @internal\r\n */\r\nexport class LastInstallFlag {\r\n  private _path: string;\r\n  private _state: Object;\r\n\r\n  /**\r\n   * Creates a new LastInstall flag\r\n   * @param folderPath - the folder that this flag is managing\r\n   * @param state - optional, the state that should be managed or compared\r\n  */\r\n  constructor(folderPath: string, state: Object = {}) {\r\n    this._path = path.join(folderPath, LAST_INSTALL_FLAG_FILE_NAME);\r\n    this._state = state;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the file exists and the contents match the current state\r\n   */\r\n  public isValid(): boolean {\r\n    if (!fsx.existsSync(this._path)) {\r\n      return false;\r\n    }\r\n    try {\r\n      const contents: Object = fsx.readJsonSync(this._path);\r\n      return _.isEqual(contents, this._state);\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes the flag file to disk with the current state\r\n   */\r\n  public create(): void {\r\n    fsx.mkdirsSync(path.dirname(this._path));\r\n    fsx.writeJsonSync(this._path, this._state);\r\n  }\r\n\r\n  /**\r\n   * Removes the flag file\r\n   */\r\n  public clear(): void {\r\n    fsx.removeSync(this._path);\r\n  }\r\n\r\n  /**\r\n   * Returns the full path to the flag file\r\n   */\r\n  public get path(): string {\r\n    return this._path;\r\n  }\r\n}"],"sourceRoot":"../../../src"}