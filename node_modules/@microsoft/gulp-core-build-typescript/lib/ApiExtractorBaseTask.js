"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const node_core_library_1 = require("@microsoft/node-core-library");
const api_extractor_1 = require("@microsoft/api-extractor");
/**
 * The ApiExtractorTask uses the api-extractor tool to analyze a project for public APIs. api-extractor will detect
 * common problems and generate a report of the exported public API. The task uses the entry point of a project to
 * find the aliased exports of the project. An api-extractor.ts file is generated for the project in the temp folder.
 * @internal
 */
class ApiExtractorBaseTask extends gulp_core_build_1.GulpTask {
    constructor() {
        super('api-extractor', {
            enabled: false,
            entry: undefined,
            apiReviewFolder: undefined,
            apiJsonFolder: undefined
        });
    }
    loadSchema() {
        return require('./schemas/api-extractor.schema.json');
    }
    executeTask(gulp, completeCallback) {
        if (!this.taskConfig.enabled || !this._validateConfiguration()) {
            completeCallback();
            return;
        }
        if (!this.taskConfig.entry) {
            completeCallback('taskConfig.entry must be defined');
            return;
        }
        if (!this.taskConfig.apiJsonFolder) {
            completeCallback('taskConfig.apiJsonFolder must be defined');
            return;
        }
        if (!this.taskConfig.apiReviewFolder) {
            completeCallback('taskConfig.apiReviewFolder must be defined');
            return;
        }
        try {
            let entryPointFile;
            if (this.taskConfig.entry === 'src/index.ts') {
                // backwards compatibility for legacy projects that used *.ts files as their entry point
                entryPointFile = path.join(this.buildConfig.rootPath, 'lib/index.d.ts');
            }
            else {
                entryPointFile = path.join(this.buildConfig.rootPath, this.taskConfig.entry);
            }
            const extractorConfig = {
                project: {
                    entryPointSourceFile: entryPointFile,
                    externalJsonFileFolders: [path.join(__dirname, 'external-api-json')]
                },
                apiReviewFile: {
                    enabled: true,
                    apiReviewFolder: this.taskConfig.apiReviewFolder,
                    tempFolder: this.buildConfig.tempFolder
                },
                apiJsonFile: {
                    enabled: true,
                    outputFolder: this.taskConfig.apiJsonFolder
                }
            };
            if (this.taskConfig.generateDtsRollup) {
                extractorConfig.dtsRollup = {
                    enabled: true,
                    trimming: !!this.taskConfig.dtsRollupTrimming,
                    publishFolderForInternal: this.taskConfig.publishFolderForInternal,
                    publishFolderForBeta: this.taskConfig.publishFolderForBeta,
                    publishFolderForPublic: this.taskConfig.publishFolderForPublic
                };
            }
            const extractorOptions = {
                localBuild: !this.buildConfig.production,
                customLogger: {
                    logVerbose: (message) => this.logVerbose(message),
                    logInfo: (message) => this.log(message),
                    logWarning: (message) => this.logWarning(message),
                    logError: (message) => this.logError(message)
                }
            };
            this.updateExtractorOptions(extractorOptions, entryPointFile);
            this.updateExtractorConfig(extractorConfig);
            const extractor = new api_extractor_1.Extractor(extractorConfig, extractorOptions);
            // NOTE: processProject() returns false if errors or warnings occurred, however we
            // already handle this above via our customLogger
            extractor.processProject();
        }
        catch (e) {
            completeCallback(e.message);
            return;
        }
        completeCallback();
    }
    _validateConfiguration() {
        if (!this.taskConfig.entry) {
            this.logError('Missing or empty "entry" field in api-extractor.json');
            return false;
        }
        if (!this.taskConfig.apiReviewFolder) {
            this.logError('Missing or empty "apiReviewFolder" field in api-extractor.json');
            return false;
        }
        if (!node_core_library_1.FileSystem.exists(this.taskConfig.entry)) {
            this.logError(`Entry file ${this.taskConfig.entry} does not exist.`);
            return false;
        }
        return true;
    }
}
exports.ApiExtractorBaseTask = ApiExtractorBaseTask;

//# sourceMappingURL=ApiExtractorBaseTask.js.map
