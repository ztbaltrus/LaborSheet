"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
const BaseCmdTask_1 = require("./BaseCmdTask");
/**
 * @alpha
 */
class TslintCmdTask extends BaseCmdTask_1.BaseCmdTask {
    constructor() {
        super('tslint', {
            initialTaskConfig: {
                displayAsError: false
            },
            packageName: 'tslint',
            packageBinPath: path.join('bin', 'tslint')
        });
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.resolve(__dirname, '..', 'schemas', 'tslint-cmd.schema.json'));
    }
    executeTask(gulp, completeCallback) {
        if (this._customFormatterSpecified) {
            this.logVerbose('A custom formatter has been specified in customArgs, so the default TSLint error logging ' +
                'has been disabled.');
        }
        return super.executeTask(gulp, completeCallback);
    }
    _getArgs() {
        const args = super._getArgs();
        if (!this._customFormatterSpecified) {
            // IFF no custom formatter options are specified by the rig/consumer, use the JSON formatter and
            // log errors using the GCB API
            args.push(...[
                '--format', 'json'
            ]);
        }
        args.push(...[
            '--project', this._buildDirectory
        ]);
        return args;
    }
    _onClose(code, hasErrors, resolve, reject) {
        if (this.taskConfig.displayAsError) {
            super._onClose(code, hasErrors, resolve, reject);
        }
        else {
            resolve();
        }
    }
    _onData(data) {
        if (!this._customFormatterSpecified) {
            const dataStr = data.toString().trim();
            const tslintErrorLogFn = this.taskConfig.displayAsError ? this.fileError.bind(this) : this.fileWarning.bind(this);
            // TSLint errors are logged to stdout
            try {
                const errors = JSON.parse(dataStr);
                for (const error of errors) {
                    const pathFromRoot = path.relative(this.buildConfig.rootPath, error.name);
                    tslintErrorLogFn(pathFromRoot, error.startPosition.line + 1, error.startPosition.character + 1, error.ruleName, error.failure);
                }
            }
            catch (e) {
                // If we fail to parse the JSON, it's likely TSLint encountered an error parsing the config file,
                // or it experienced an inner error. In this case, log the output as an error regardless of the
                // displayAsError value
                this.logError(dataStr);
            }
        }
    }
    get _customFormatterSpecified() {
        const customArgs = super._getArgs();
        return (customArgs.indexOf('--formatters-dir') !== -1 ||
            customArgs.indexOf('-s') !== -1 ||
            customArgs.indexOf('--format') !== -1 ||
            customArgs.indexOf('-t') !== -1 // Shorthand for "--format"
        );
    }
}
exports.TslintCmdTask = TslintCmdTask;

//# sourceMappingURL=TslintCmdTask.js.map
