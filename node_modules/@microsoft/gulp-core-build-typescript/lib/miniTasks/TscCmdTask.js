"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
const glob = require("glob");
const globEscape = require("glob-escape");
const typescript = require("typescript");
const decomment = require("decomment");
const BaseCmdTask_1 = require("./BaseCmdTask");
const TsParseConfigHost_1 = require("./TsParseConfigHost");
/**
 * @alpha
 */
class TscCmdTask extends BaseCmdTask_1.BaseCmdTask {
    constructor() {
        super('tsc', {
            initialTaskConfig: {
                staticMatch: [
                    'src/**/*.js',
                    'src/**/*.json',
                    'src/**/*.jsx'
                ],
                removeCommentsFromJavaScript: false
            },
            packageName: 'typescript',
            packageBinPath: path.join('bin', 'tsc')
        });
    }
    loadSchema() {
        return node_core_library_1.JsonFile.load(path.resolve(__dirname, '..', 'schemas', 'tsc-cmd.schema.json'));
    }
    executeTask(gulp, completeCallback) {
        // Static passthrough files.
        const srcPath = path.join(this.buildConfig.rootPath, this.buildConfig.srcFolder);
        const libFolders = [this.buildConfig.libFolder];
        if (this.buildConfig.libAMDFolder) {
            libFolders.push(this.buildConfig.libAMDFolder);
        }
        if (this.buildConfig.libES6Folder) {
            libFolders.push(this.buildConfig.libES6Folder);
        }
        if (this.buildConfig.libESNextFolder) {
            libFolders.push(this.buildConfig.libESNextFolder);
        }
        const resolvedLibFolders = libFolders.map((libFolder) => path.join(this.buildConfig.rootPath, libFolder));
        const promises = (this.taskConfig.staticMatch || []).map((pattern) => {
            return new Promise((resolve, reject) => {
                glob(path.join(globEscape(this.buildConfig.rootPath), pattern), (error, matchPaths) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        for (const matchPath of matchPaths) {
                            const fileContents = node_core_library_1.FileSystem.readFile(matchPath);
                            const relativePath = path.relative(srcPath, matchPath);
                            for (const resolvedLibFolder of resolvedLibFolders) {
                                const destPath = path.join(resolvedLibFolder, relativePath);
                                node_core_library_1.FileSystem.writeFile(destPath, fileContents, { ensureFolderExists: true });
                            }
                        }
                        resolve();
                    }
                });
            });
        });
        let completeCallbackCalled = false;
        let completeCallbackError;
        const basePromise = super.executeTask(gulp, (error) => {
            completeCallbackCalled = true;
            completeCallbackError = error;
        });
        if (basePromise) {
            promises.push(basePromise);
        }
        let buildPromise = Promise.all(promises).then(() => { });
        if (this.taskConfig.removeCommentsFromJavaScript === true) {
            buildPromise = buildPromise.then(() => this._removeComments(this._getArgs()));
        }
        return buildPromise.then(() => {
            if (completeCallbackCalled) {
                completeCallback(completeCallbackError);
            }
        });
    }
    _onData(data) {
        // Log lines separately
        const dataLines = data.toString().split('\n');
        for (const dataLine of dataLines) {
            const trimmedLine = (dataLine || '').trim();
            if (!!trimmedLine) {
                if (trimmedLine.match(/\serror\s/i)) {
                    // If the line looks like an error, log it as an error
                    this.logError(trimmedLine);
                }
                else {
                    this.log(trimmedLine);
                }
            }
        }
    }
    _removeComments(commandLineArgs) {
        const configFilePath = typescript.findConfigFile(this.buildConfig.rootPath, node_core_library_1.FileSystem.exists);
        if (!configFilePath) {
            return Promise.reject(new Error('Unable to resolve tsconfig file to determine outDir.'));
        }
        const commandLine = typescript.parseCommandLine(commandLineArgs);
        const tsConfig = typescript.parseJsonConfigFileContent(node_core_library_1.JsonFile.load(configFilePath), new TsParseConfigHost_1.TsParseConfigHost(), path.dirname(configFilePath), commandLine.options);
        if (!tsConfig || !tsConfig.options.outDir) {
            return Promise.reject('Unable to determine outDir from TypesScript configuration.');
        }
        return new Promise((resolve, reject) => {
            glob(path.join(globEscape(tsConfig.options.outDir), '**', '*.js'), (error, matches) => {
                if (error) {
                    reject(error);
                }
                else {
                    for (const match of matches) {
                        const sourceText = node_core_library_1.FileSystem.readFile(match);
                        const decommentedText = decomment(sourceText, {
                            // This option preserves comments that start with /*!, /**! or //! - typically copyright comments
                            safe: true
                        });
                        node_core_library_1.FileSystem.writeFile(match, decommentedText);
                    }
                    resolve();
                }
            });
        });
    }
}
exports.TscCmdTask = TscCmdTask;

//# sourceMappingURL=TscCmdTask.js.map
