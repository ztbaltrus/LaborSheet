"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("gulp-typescript");
const path = require("path");
const lodash = require("lodash");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const TypeScriptConfiguration_1 = require("./TypeScriptConfiguration");
/**
 * @public
 */
class TypeScriptTask extends gulp_core_build_1.GulpTask {
    constructor() {
        super('typescript', {
            failBuildOnErrors: true,
            reporter: {
                error: (error) => {
                    const filename = error.relativeFilename || error.fullFilename || 'unknown filename';
                    const line = error.startPosition ? error.startPosition.line + 1 : 0;
                    const character = error.startPosition ? error.startPosition.character + 1 : 0;
                    const code = error.diagnostic.code;
                    const errorMessage = (typeof error.diagnostic.messageText === 'object') ?
                        error.diagnostic.messageText.messageText :
                        error.diagnostic.messageText;
                    this.fileError(filename, line, character, 'TS' + code, errorMessage);
                }
            },
            sourceMatch: [
                'src/**/*.ts',
                'src/**/*.tsx',
                'typings/main/**/*.ts',
                'typings/main.d.ts',
                'typings/tsd.d.ts',
                'typings/index.d.ts'
            ],
            staticMatch: [
                'src/**/*.js',
                'src/**/*.json',
                'src/**/*.jsx'
            ],
            removeCommentsFromJavaScript: false,
            emitSourceMaps: true,
            libDir: undefined,
            libAMDDir: undefined,
            libES6Dir: undefined,
            libESNextDir: undefined
        });
    }
    loadSchema() {
        return require('./schemas/typescript.schema.json');
    }
    executeTask(gulp, completeCallback) {
        /* tslint:disable:typedef */
        const assign = require('object-assign');
        const merge = require('merge2');
        /* tslint:enable:typedef */
        const allStreams = [];
        const result = {
            errorCount: 0
        };
        this._normalizeConfig();
        // Log the compiler version for custom versions.
        const typescript = TypeScriptConfiguration_1.TypeScriptConfiguration.getTypescriptCompiler(); // tslint:disable-line:no-any
        if (typescript && typescript.version) {
            this.log(`TypeScript version: ${typescript.version}`);
        }
        // tslint:disable-next-line:no-any
        let compilerOptions = TypeScriptConfiguration_1.TypeScriptConfiguration.getGulpTypescriptOptions(this.buildConfig).compilerOptions;
        if (this.taskConfig.configurationAddons) {
            compilerOptions = lodash.merge({}, compilerOptions, this.taskConfig.configurationAddons);
        }
        TypeScriptConfiguration_1.TypeScriptConfiguration.fixupSettings(compilerOptions, this.logWarning.bind(this));
        this._tsProject = this._tsProject || ts.createProject(compilerOptions);
        this._compileProject(gulp, this._tsProject, this.taskConfig.libDir || this.buildConfig.libFolder, allStreams, result);
        // Static passthrough files.
        const staticSrc = gulp.src(this.taskConfig.staticMatch || []);
        allStreams.push(staticSrc.pipe(gulp.dest(this.taskConfig.libDir || this.buildConfig.libFolder)));
        // If AMD modules are required, also build that.
        if (this.taskConfig.libAMDDir) {
            allStreams.push(staticSrc.pipe(gulp.dest(this.taskConfig.libAMDDir)));
            this._tsAMDProject = this._tsAMDProject || ts.createProject(assign({}, compilerOptions, { module: 'amd' }));
            this._compileProject(gulp, this._tsAMDProject, this.taskConfig.libAMDDir, allStreams, result);
        }
        // If es6 modules are required, also build that.
        if (this.taskConfig.libES6Dir) {
            allStreams.push(staticSrc.pipe(gulp.dest(this.taskConfig.libES6Dir)));
            this._tsES6Project = this._tsES6Project || ts.createProject(assign({}, compilerOptions, { module: 'es6' }));
            this._compileProject(gulp, this._tsES6Project, this.taskConfig.libES6Dir, allStreams, result);
        }
        // If esnext modules are required, also build that.
        if (this.taskConfig.libESNextDir) {
            allStreams.push(staticSrc.pipe(gulp.dest(this.taskConfig.libESNextDir)));
            this._tsESNextProject = (this._tsESNextProject ||
                ts.createProject(assign({}, compilerOptions, { module: 'esnext' })));
            this._compileProject(gulp, this._tsESNextProject, this.taskConfig.libESNextDir, allStreams, result);
        }
        // Listen for pass/fail, and ensure that the task passes/fails appropriately.
        merge(allStreams)
            .on('queueDrain', () => {
            if (this.taskConfig.failBuildOnErrors && result.errorCount) {
                completeCallback('TypeScript error(s) occurred.');
            }
            else {
                completeCallback();
            }
        })
            .on('error', completeCallback);
    }
    getCleanMatch(buildConfig, taskConfig = this.taskConfig) {
        this._normalizeConfig(buildConfig);
        const cleanMatch = [];
        if (this.taskConfig.libDir) {
            cleanMatch.push(this.taskConfig.libDir);
        }
        if (this.taskConfig.libAMDDir) {
            cleanMatch.push(this.taskConfig.libAMDDir);
        }
        if (this.taskConfig.libES6Dir) {
            cleanMatch.push(this.taskConfig.libES6Dir);
        }
        if (this.taskConfig.libESNextDir) {
            cleanMatch.push(this.taskConfig.libESNextDir);
        }
        return cleanMatch;
    }
    /** Override the new mergeConfig API */
    mergeConfig(config) {
        throw 'Do not use mergeConfig with gulp-core-build-typescript';
    }
    _normalizeConfig(buildConfig = this.buildConfig) {
        if (!this.taskConfig.libDir) {
            this.taskConfig.libDir = buildConfig.libFolder;
        }
        if (!this.taskConfig.libAMDDir) {
            this.taskConfig.libAMDDir = buildConfig.libAMDFolder;
        }
        if (!this.taskConfig.libES6Dir) {
            this.taskConfig.libES6Dir = buildConfig.libES6Folder;
        }
        if (!this.taskConfig.libESNextDir) {
            this.taskConfig.libESNextDir = buildConfig.libESNextFolder;
        }
    }
    _compileProject(gulp, tsProject, destDir, allStreams, result) {
        /* tslint:disable:typedef */
        const plumber = require('gulp-plumber');
        const sourcemaps = require('gulp-sourcemaps');
        /* tslint:enable:typedef */
        // tslint:disable-next-line:no-any
        let tsResult = gulp.src(this.taskConfig.sourceMatch || [])
            .pipe(plumber({
            errorHandler: () => {
                result.errorCount++;
            }
        }));
        if (this.taskConfig.emitSourceMaps) {
            tsResult = tsResult.pipe(sourcemaps.init());
        }
        tsResult = tsResult
            .pipe(tsProject(this.taskConfig.reporter));
        // tslint:disable-next-line:typedef
        let jsResult = (this.taskConfig.removeCommentsFromJavaScript
            ? tsResult.js.pipe(require('gulp-decomment')({
                space: !!this.taskConfig.emitSourceMaps /* turn comments into spaces to preserve sourcemaps */
            }))
            : tsResult.js);
        if (this.taskConfig.emitSourceMaps) {
            jsResult = jsResult.pipe(sourcemaps.write('.', { sourceRoot: this._resolveSourceMapRoot }));
        }
        allStreams.push(jsResult
            .pipe(gulp.dest(destDir)));
        allStreams.push(tsResult.dts.pipe(gulp.dest(destDir)));
    }
    _resolveSourceMapRoot(file) {
        return path.relative(file.relative, path.join(file.cwd, 'src'));
    }
}
exports.TypeScriptTask = TypeScriptTask;

//# sourceMappingURL=TypeScriptTask.js.map
