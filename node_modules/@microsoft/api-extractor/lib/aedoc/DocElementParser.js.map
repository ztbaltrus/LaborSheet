{"version":3,"sources":["aedoc/DocElementParser.ts"],"names":[],"mappings":"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","file":"DocElementParser.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { IParsedPackageName } from '@microsoft/node-core-library';\r\nimport {\r\n  MarkupLinkTextElement,\r\n  MarkupBasicElement,\r\n  MarkupElement\r\n} from '../markup/MarkupElement';\r\nimport { Markup } from '../markup/Markup';\r\nimport { ApiDefinitionReference } from '../ApiDefinitionReference';\r\nimport { ApiDocumentation } from '../aedoc/ApiDocumentation';\r\nimport { AstItemKind } from '../ast/AstItem';\r\nimport { Token, TokenType } from '../aedoc/Token';\r\nimport { Tokenizer } from '../aedoc/Tokenizer';\r\nimport { ResolvedApiItem } from '../ResolvedApiItem';\r\nimport { IApiItemReference} from '../api/ApiItem';\r\n\r\nexport class DocElementParser {\r\n  /**\r\n   * Matches one of:\r\n   * - an escape sequence, i.e. backslash followed by a non-alphabetical character\r\n   * - an HTML opening tag such as `<td>` or `<img src=\"example.gif\" />`\r\n   * - an HTML opening tag such as `<td>` or `<img src='example.gif' />`\r\n   * - an HTML closing tag such `</td>`\r\n   *\r\n   * Note that the greedy nature of the RegExp ensures that `\\<td>` will get interpreted\r\n   * as an escaped \"<\", whereas `\\\\<td>` will get interpreted as an escaped backslash\r\n   * followed by an HTML element.\r\n   */\r\n  private static _htmlTagRegExp: RegExp\r\n    = /\\\\[^a-zA-Z\\s]|<[\\w\\-]+(?:\\s+[\\w\\-]+\\s*=\\s*(?:\"[^\"]*\"|'[^']*'))*\\s*\\/?>|<\\/[\\w\\-]+>/g;\r\n\r\n  /**\r\n   * Used to validate the display text for an \\@link tag.  The display text can contain any\r\n   * characters except for certain AEDoc delimiters: \"@\", \"|\", \"{\", \"}\".\r\n   * This RegExp matches the first bad character.\r\n   * Example: \"Microsoft's {spec}\" --> \"{\"\r\n   */\r\n  private static _displayTextBadCharacterRegEx: RegExp = /[@|{}]/;\r\n\r\n  /**\r\n   * Matches a href reference. This is used to get an idea whether a given reference is for an href\r\n   * or an API definition reference.\r\n   *\r\n   * For example, the following would be matched:\r\n   * 'http://'\r\n   * 'https://'\r\n   *\r\n   * The following would not be matched:\r\n   * '@microsoft/sp-core-library:Guid.newGuid'\r\n   * 'Guid.newGuid'\r\n   * 'Guid'\r\n   */\r\n  private static _hrefRegEx: RegExp = /^[a-z]+:\\/\\//;\r\n\r\n  public static parse(documentation: ApiDocumentation, tokenizer: Tokenizer): MarkupBasicElement[] {\r\n\r\n    const markupElements: MarkupBasicElement[] = [];\r\n    let parsing: boolean = true;\r\n    let token: Token | undefined;\r\n\r\n    while (parsing) {\r\n      token = tokenizer.peekToken();\r\n      if (!token) {\r\n        parsing = false; // end of stream\r\n        break;\r\n      }\r\n\r\n      if (token.type === TokenType.BlockTag) {\r\n        parsing = false; // end of summary tokens\r\n      } else if (token.type === TokenType.InlineTag) {\r\n        switch (token.tag) {\r\n          case '@inheritdoc':\r\n            tokenizer.getToken();\r\n            if (markupElements.length > 0 ||  documentation.summary.length > 0) {\r\n              documentation.reportError('A summary block is not allowed here,'\r\n                + ' because the @inheritdoc target provides the summary');\r\n            }\r\n            documentation.incompleteInheritdocs.push(token);\r\n            documentation.isDocInherited = true;\r\n            break;\r\n          case '@link' :\r\n            const linkMarkupElement: MarkupElement | undefined = this.parseLinkTag(documentation, token);\r\n            if (linkMarkupElement) {\r\n              // Push to linkMarkupElement to retain position in the documentation\r\n              markupElements.push(linkMarkupElement);\r\n              if (linkMarkupElement.kind === 'api-link') {\r\n                documentation.incompleteLinks.push(linkMarkupElement);\r\n              }\r\n            }\r\n            tokenizer.getToken(); // get the link token\r\n            break;\r\n          default:\r\n            parsing = false;\r\n            break;\r\n        }\r\n      } else if (token.type === TokenType.Text) {\r\n        tokenizer.getToken();\r\n\r\n        markupElements.push(...DocElementParser.parseMarkdownishText(token.text));\r\n      } else {\r\n        documentation.reportError(`Unidentifiable Token ${token.type} ${token.tag} \"${token.text}\"`);\r\n      }\r\n    }\r\n\r\n    return markupElements;\r\n  }\r\n\r\n  public static parseAndNormalize(documentation: ApiDocumentation, tokenizer: Tokenizer): MarkupBasicElement[] {\r\n    const markupElements: MarkupBasicElement[] = DocElementParser.parse(documentation, tokenizer);\r\n    Markup.normalize(markupElements);\r\n    return markupElements;\r\n  }\r\n\r\n  /**\r\n   * This method parses the semantic information in an \\@link JSDoc tag, creates and returns a\r\n   * MarkupElement with the corresponding information. If the corresponding inline tag \\@link is\r\n   * not formatted correctly an error will be reported and undefined is returned.\r\n   *\r\n   * The format for the \\@link tag is {\\@link URL or API defintion reference | display text}, where\r\n   * the '|' is only needed if the optional display text is given.\r\n   *\r\n   * Examples:\r\n   * \\{@link http://microsoft.com | microsoft home \\}\r\n   * \\{@link http://microsoft.com \\}\r\n   * \\{@link @microsoft/sp-core-library:Guid.newGuid | new Guid Object \\}\r\n   * \\{@link @microsoft/sp-core-library:Guid.newGuid \\}\r\n   */\r\n  public static parseLinkTag(documentation: ApiDocumentation, tokenItem: Token): MarkupBasicElement | undefined {\r\n    if (!tokenItem.text) {\r\n      documentation.reportError('The {@link} tag must include a URL or API item reference');\r\n      return undefined;\r\n    }\r\n\r\n    // Make sure there are no extra pipes\r\n    const pipeSplitContent: string[] = tokenItem.text.split('|').map(value => {\r\n      return value ? value.trim() : value;\r\n    });\r\n\r\n    if (pipeSplitContent.length > 2) {\r\n      documentation.reportError('The {@link} tag contains more than one pipe character (\"|\")');\r\n      return undefined;\r\n    }\r\n\r\n    const addressPart: string = pipeSplitContent[0];\r\n    const displayTextPart: string = pipeSplitContent.length > 1 ? pipeSplitContent[1] : '';\r\n\r\n    let displayTextElements: MarkupLinkTextElement[];\r\n\r\n    // If a display name is given, ensure it only contains characters for words.\r\n    if (displayTextPart) {\r\n      const match: RegExpExecArray | null = this._displayTextBadCharacterRegEx.exec(displayTextPart);\r\n      if (match) {\r\n        documentation.reportError(`The {@link} tag\\'s display text contains an unsupported`\r\n          + ` character: \"${match[0]}\"`);\r\n        return undefined;\r\n      }\r\n      // Full match is valid text\r\n      displayTextElements = Markup.createTextElements(displayTextPart);\r\n    } else {\r\n      // If the display text is not explicitly provided, then use the address as the display text\r\n      displayTextElements = Markup.createTextElements(addressPart);\r\n    }\r\n\r\n    // Try to guess if the tokenContent is a link or API definition reference\r\n    let linkMarkupElement: MarkupBasicElement;\r\n    if (this._hrefRegEx.test(addressPart)) {\r\n      // Make sure only a single URL is given\r\n      if (addressPart.indexOf(' ') >= 0) {\r\n        documentation.reportError('The {@link} tag contains additional spaces after the URL;'\r\n          + ' if the URL contains spaces, encode them using %20; for display text, use a pipe delimiter (\"|\")');\r\n        return undefined;\r\n      }\r\n\r\n      linkMarkupElement = Markup.createWebLink(displayTextElements, addressPart);\r\n    } else {\r\n      // we are processing an API definition reference\r\n      const apiDefitionRef: ApiDefinitionReference | undefined = ApiDefinitionReference.createFromString(\r\n        addressPart,\r\n        documentation.reportError\r\n      );\r\n\r\n      // Once we can locate local API definitions, an error should be reported here if not found.\r\n      if (!apiDefitionRef) {\r\n        return undefined;\r\n      }\r\n\r\n      const normalizedApiLink: IApiItemReference = apiDefitionRef.toApiItemReference();\r\n      if (!normalizedApiLink.packageName) {\r\n        if (!documentation.context.packageName) {\r\n          throw new Error('Unable to resolve API reference without a package name');\r\n        }\r\n\r\n        // If the package name is unspecified, assume it is the current package\r\n        const parsedPackageName: IParsedPackageName = documentation.context.parsedPackageName;\r\n\r\n        normalizedApiLink.scopeName = parsedPackageName.scope;\r\n        normalizedApiLink.packageName = parsedPackageName.unscopedName;\r\n      }\r\n\r\n      linkMarkupElement = Markup.createApiLink(displayTextElements, normalizedApiLink);\r\n    }\r\n\r\n    return linkMarkupElement;\r\n  }\r\n\r\n  /**\r\n   * This method parses the semantic information in an \\@inheritdoc JSDoc tag and sets\r\n   * all the relevant documenation properties from the inherited doc onto the documenation\r\n   * of the current api item.\r\n   *\r\n   * The format for the \\@inheritdoc tag is {\\@inheritdoc scopeName/packageName:exportName.memberName}.\r\n   * For more information on the format see IInheritdocRef.\r\n   */\r\n  public static parseInheritDoc(documentation: ApiDocumentation, token: Token, warnings: string[]): void {\r\n\r\n    // Check to make sure the API definition reference is at most one string\r\n    const tokenChunks: string[] = token.text.split(' ');\r\n    if (tokenChunks.length > 1) {\r\n      documentation.reportError('The {@inheritdoc} tag does not match the expected pattern' +\r\n        ' \"{@inheritdoc @scopeName/packageName:exportName}\"');\r\n      return;\r\n    }\r\n\r\n    // Create the IApiDefinitionReference object\r\n    // Deconstruct the API reference expression 'scopeName/packageName:exportName.memberName'\r\n    const apiDefinitionRef: ApiDefinitionReference | undefined = ApiDefinitionReference.createFromString(\r\n      token.text,\r\n      documentation.reportError\r\n    );\r\n    // if API reference expression is formatted incorrectly then apiDefinitionRef will be undefined\r\n    if (!apiDefinitionRef) {\r\n      documentation.reportError(`Incorrectly formatted API item reference: \"${token.text}\"`);\r\n      return;\r\n    }\r\n\r\n    // Atempt to locate the apiDefinitionRef\r\n    const resolvedAstItem: ResolvedApiItem | undefined = documentation.referenceResolver.resolve(\r\n      apiDefinitionRef,\r\n      documentation.context.package,\r\n      warnings\r\n    );\r\n\r\n    // If no resolvedAstItem found then nothing to inherit\r\n    // But for the time being set the summary to a text object\r\n    if (!resolvedAstItem) {\r\n      documentation.summary = Markup.createTextElements(`See documentation for ${tokenChunks[0]}`);\r\n      return;\r\n    }\r\n\r\n    // We are going to copy the resolvedAstItem's documentation\r\n    // We must make sure it's documentation can be completed,\r\n    // if we cannot, an error will be reported viathe documentation error handler.\r\n    // This will only be the case our resolvedAstItem was created from a local\r\n    // AstItem. Resolutions from JSON will have an undefined 'astItem' property.\r\n    // Example: a circular reference will report an error.\r\n    if (resolvedAstItem.astItem) {\r\n      resolvedAstItem.astItem.completeInitialization();\r\n    }\r\n\r\n    // inheritdoc found, copy over IApiBaseDefinition properties\r\n    documentation.summary =  resolvedAstItem.summary;\r\n    documentation.remarks = resolvedAstItem.remarks;\r\n\r\n    // Copy over detailed properties if neccessary\r\n    // Add additional cases if needed\r\n    switch (resolvedAstItem.kind) {\r\n      case AstItemKind.Function:\r\n        documentation.parameters = resolvedAstItem.params || { };\r\n        documentation.returnsMessage = resolvedAstItem.returnsMessage || [];\r\n        break;\r\n      case AstItemKind.Method:\r\n      case AstItemKind.Constructor:\r\n        documentation.parameters = resolvedAstItem.params || { };\r\n        documentation.returnsMessage = resolvedAstItem.returnsMessage || [];\r\n        break;\r\n    }\r\n\r\n    // Check if inheritdoc is depreacted\r\n    // We need to check if this documentation has a deprecated message\r\n    // but it may not appear until after this token.\r\n    if (resolvedAstItem.deprecatedMessage && resolvedAstItem.deprecatedMessage.length > 0) {\r\n      documentation.isDocInheritedDeprecated = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is a temporary workaround until the TSDoc parser is integrated.  \"Markdownish\"\r\n   * text can have:\r\n   * - paragraphs delimited using double-newlines --> IMarkupParagraph\r\n   * - HTML tags (as in the CommonMark spec) --> IMarkupHtmlTag\r\n   * - Backslash as an escape character\r\n   */\r\n  public static parseMarkdownishText(text: string): MarkupBasicElement[] {\r\n    const result: MarkupBasicElement[] = [];\r\n\r\n    if (text) {\r\n      // Split up the paragraphs\r\n      for (const paragraph of text.split(/\\n\\s*\\n/g)) {\r\n        if (result.length > 0) {\r\n          result.push(Markup.PARAGRAPH);\r\n        }\r\n\r\n        // Clone the original RegExp so we get our own state machine\r\n        const htmlTagRegExp: RegExp = new RegExp(DocElementParser._htmlTagRegExp);\r\n\r\n        let lastMatchEndIndex: number = 0;\r\n        let accumulatedText: string = '';\r\n\r\n        // Find the HTML tags and backslash sequences in the paragraph string\r\n        let match: RegExpExecArray | null;\r\n        while (match = htmlTagRegExp.exec(paragraph)) {\r\n          // Was there any plain text between this match and the previous one?\r\n          // If so accumulate it\r\n          const textBeforeMatch: string = paragraph.substring(lastMatchEndIndex, match.index);\r\n          accumulatedText += textBeforeMatch;\r\n\r\n          // What did we match?\r\n          const matchedText: string = match[0];\r\n          if (matchedText[0] === '\\\\') {\r\n            // It's a backslash escape, so accumulate the subsequent character (but not the backslash itself)\r\n            accumulatedText += matchedText[1];\r\n          } else {\r\n            // It's an opening or closing HTML tag\r\n\r\n            // First push any text we accumulated\r\n            result.push(...Markup.createTextElements(accumulatedText));\r\n            accumulatedText = '';\r\n\r\n            // Then push the HTML tag\r\n            result.push(Markup.createHtmlTag(matchedText));\r\n          }\r\n\r\n          lastMatchEndIndex = match.index + matchedText.length;\r\n        }\r\n        // Push any remaining text\r\n        accumulatedText += paragraph.substring(lastMatchEndIndex);\r\n\r\n        result.push(...Markup.createTextElements(accumulatedText));\r\n        accumulatedText = '';\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n}\r\n"],"sourceRoot":"../../../src"}