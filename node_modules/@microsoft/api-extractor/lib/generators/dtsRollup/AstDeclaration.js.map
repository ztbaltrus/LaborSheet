{"version":3,"sources":["generators/dtsRollup/AstDeclaration.ts"],"names":[],"mappings":"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","file":"AstDeclaration.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { AstSymbol } from './AstSymbol';\r\nimport { Span } from '../../utils/Span';\r\n\r\n/**\r\n * Constructor parameters for AstDeclaration\r\n */\r\nexport interface IAstDeclarationParameters {\r\n  readonly declaration: ts.Declaration;\r\n  readonly astSymbol: AstSymbol;\r\n  readonly parent: AstDeclaration | undefined;\r\n}\r\n\r\n/**\r\n * The AstDeclaration and AstSymbol classes are API Extractor's equivalent of the compiler's\r\n * ts.Declaration and ts.Symbol objects.  They are created by the SymbolTable class.\r\n *\r\n * @remarks\r\n * The AstDeclaration represents one or more syntax components of a symbol.  Usually there is\r\n * only one AstDeclaration per AstSymbol, but certain TypeScript constructs can have multiple\r\n * declarations (e.g. overloaded functions, declaration merging, etc).\r\n *\r\n * Because of this the AstDeclaration manages the parent/child nesting hierarchy (e.g. with\r\n * declaration merging, each declaration has its own children) and becomes the main focus\r\n * of analyzing AEDoc and emitting *.d.ts files.\r\n *\r\n * The AstDeclarations correspond to items from the compiler's ts.Node hierarchy, but\r\n * omitting/skipping any nodes that don't match the SymbolAnalyzer.isAstDeclaration()\r\n * criteria.  This simplification makes the other API Extractor stages easier to implement.\r\n */\r\nexport class AstDeclaration {\r\n  public readonly declaration: ts.Declaration;\r\n\r\n  public readonly astSymbol: AstSymbol;\r\n\r\n  /**\r\n   * The parent, if this object is nested inside another AstDeclaration.\r\n   */\r\n  public readonly parent: AstDeclaration | undefined;\r\n\r\n  private readonly _analyzedChildren: AstDeclaration[] = [];\r\n\r\n  private readonly _analyzedReferencedAstSymbolsSet: Set<AstSymbol> = new Set<AstSymbol>();\r\n\r\n  public constructor(parameters: IAstDeclarationParameters) {\r\n    this.declaration = parameters.declaration;\r\n    this.astSymbol = parameters.astSymbol;\r\n    this.parent = parameters.parent;\r\n\r\n    this.astSymbol._notifyDeclarationAttach(this);\r\n\r\n    if (this.parent) {\r\n      this.parent._notifyChildAttach(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the children for this AstDeclaration.\r\n   * @remarks\r\n   * The collection will be empty until AstSymbol.analyzed is true.\r\n   */\r\n  public get children(): ReadonlyArray<AstDeclaration> {\r\n    return this.astSymbol.analyzed ? this._analyzedChildren : [];\r\n  }\r\n\r\n  /**\r\n   * Returns the AstSymbols referenced by this node.\r\n   * @remarks\r\n   * NOTE: The collection will be empty until AstSymbol.analyzed is true.\r\n   *\r\n   * Since we assume references are always collected by a traversal starting at the\r\n   * root of the nesting declarations, this array omits the following items because they\r\n   * would be redundant:\r\n   * - symbols corresponding to parents of this declaration (e.g. a method that returns its own class)\r\n   * - symbols already listed in the referencedAstSymbols property for parents of this declaration\r\n   *   (e.g. a method that returns its own class's base class)\r\n   * - symbols that are referenced only by nested children of this declaration\r\n   *   (e.g. if a method returns an enum, this doesn't imply that the method's class references that enum)\r\n   */\r\n  public get referencedAstSymbols(): ReadonlyArray<AstSymbol> {\r\n    return this.astSymbol.analyzed ? [...this._analyzedReferencedAstSymbolsSet] : [];\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the SymbolTable attaches a new\r\n   * child AstDeclaration to this object.\r\n   * @internal\r\n   */\r\n  public _notifyChildAttach(child: AstDeclaration): void {\r\n    if (child.parent !== this) {\r\n      throw new Error('Program Bug: Invalid call to notifyChildAttach()');\r\n    }\r\n\r\n    if (this.astSymbol.analyzed) {\r\n      throw new Error('Program Bug: _notifyChildAttach() called after analysis is already complete');\r\n    }\r\n\r\n    this._analyzedChildren.push(child);\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump of the tree, which reports the hierarchy of\r\n   * AstDefinition objects.\r\n   */\r\n  public getDump(indent: string = ''): string {\r\n    const declarationKind: string = ts.SyntaxKind[this.declaration.kind];\r\n    let result: string = indent + `+ ${this.astSymbol.localName} (${declarationKind})`;\r\n    if (this.astSymbol.nominal) {\r\n      result += ' (nominal)';\r\n    }\r\n    result += '\\n';\r\n\r\n    for (const referencedAstSymbol of this._analyzedReferencedAstSymbolsSet.values()) {\r\n      result += indent + `  ref: ${referencedAstSymbol.localName}\\n`;\r\n    }\r\n\r\n    for (const child of this.children) {\r\n      result += child.getDump(indent + '  ');\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump using Span.getDump(), which reports the detailed\r\n   * compiler structure.\r\n   */\r\n  public getSpanDump(indent: string = ''): string {\r\n    const span: Span = new Span(this.declaration);\r\n    return span.getDump(indent);\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when SymbolTable.analyze() discovers a new\r\n   * type reference associated with this declaration.\r\n   * @internal\r\n   */\r\n  public _notifyReferencedAstSymbol(referencedAstSymbol: AstSymbol): void {\r\n    if (this.astSymbol.analyzed) {\r\n      throw new Error('Program Bug: notifyReferencedAstSymbol() called after analysis is already complete');\r\n    }\r\n\r\n    for (let current: AstDeclaration | undefined = this; current; current = current.parent) {\r\n      // Don't add references to symbols that are already referenced by a parent\r\n      if (current._analyzedReferencedAstSymbolsSet.has(referencedAstSymbol)) {\r\n        return;\r\n      }\r\n      // Don't add the symbols of parents either\r\n      if (referencedAstSymbol === current.astSymbol) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    this._analyzedReferencedAstSymbolsSet.add(referencedAstSymbol);\r\n  }\r\n\r\n  /**\r\n   * Visits all the current declaration and all children recursively in a depth-first traversal,\r\n   * and performs the specified action for each one.\r\n   */\r\n  public forEachDeclarationRecursive(action: (astDeclaration: AstDeclaration) => void): void {\r\n    action(this);\r\n    for (const child of this.children) {\r\n      child.forEachDeclarationRecursive(action);\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":"../../../../../src"}