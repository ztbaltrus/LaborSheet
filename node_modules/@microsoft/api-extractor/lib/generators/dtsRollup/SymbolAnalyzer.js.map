{"version":3,"sources":["generators/dtsRollup/SymbolAnalyzer.ts"],"names":[],"mappings":"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","file":"SymbolAnalyzer.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* tslint:disable:no-bitwise */\r\n\r\nimport * as ts from 'typescript';\r\n\r\nimport { TypeScriptHelpers } from '../../utils/TypeScriptHelpers';\r\nimport { AstImport } from './AstImport';\r\n\r\n/**\r\n * Return value for DtsRollupGenerator._followAliases()\r\n */\r\nexport interface IFollowAliasesResult {\r\n  /**\r\n   * The original symbol that defined this entry, after following any aliases.\r\n   */\r\n  readonly followedSymbol: ts.Symbol;\r\n\r\n  /**\r\n   * The original name used where it was defined.\r\n   */\r\n  readonly localName: string;\r\n\r\n  /**\r\n   * True if this is an ambient definition, e.g. from a \"typings\" folder.\r\n   */\r\n  readonly isAmbient: boolean;\r\n\r\n  /**\r\n   * If this followedSymbol was reached by traversing\r\n   */\r\n  readonly astImport: AstImport | undefined;\r\n}\r\n\r\n/**\r\n * This is a helper class for DtsRollupGenerator and AstSymbolTable.\r\n * Its main role is to provide an expanded version of TypeScriptHelpers.followAliases()\r\n * that supports tracking of imports from eternal packages.\r\n */\r\nexport class SymbolAnalyzer {\r\n\r\n  /**\r\n   * This function determines which ts.Node kinds will generate an AstDeclaration.\r\n   * These correspond to the definitions that we can add AEDoc to.\r\n   */\r\n  public static isAstDeclaration(kind: ts.SyntaxKind): boolean {\r\n    // (alphabetical order)\r\n    switch (kind) {\r\n      case ts.SyntaxKind.ClassDeclaration:\r\n      case ts.SyntaxKind.Constructor: // Example: new(x: number);\r\n      case ts.SyntaxKind.ConstructSignature: // Example: new(x: number);\r\n      case ts.SyntaxKind.EnumDeclaration:\r\n      case ts.SyntaxKind.EnumMember:\r\n      case ts.SyntaxKind.FunctionDeclaration:\r\n      case ts.SyntaxKind.IndexSignature:  // Example: [key: string]: string\r\n      case ts.SyntaxKind.InterfaceDeclaration:\r\n      case ts.SyntaxKind.MethodDeclaration:\r\n      case ts.SyntaxKind.MethodSignature:\r\n\r\n      // ModuleDeclaration is used for both \"module\" and \"namespace\" declarations\r\n      case ts.SyntaxKind.ModuleDeclaration:\r\n      case ts.SyntaxKind.PropertyDeclaration:\r\n      case ts.SyntaxKind.PropertySignature:\r\n\r\n      case ts.SyntaxKind.TypeAliasDeclaration:\r\n      case ts.SyntaxKind.VariableDeclaration:\r\n        return true;\r\n\r\n      // NOTE: In contexts where a source file is treated as a module, we do create \"nominal\"\r\n      // AstSymbol objects corresponding to a ts.SyntaxKind.SourceFile node.  However, a source file\r\n      // is NOT considered a nesting structure, and it does NOT act as a root for the declarations\r\n      // appearing in the file.  This is because the *.d.ts generator is in the business of rolling up\r\n      // source files, and thus wants to ignore them in general.\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * For the given symbol, follow imports and type alias to find the symbol that represents\r\n   * the original definition.\r\n   */\r\n  public static followAliases(symbol: ts.Symbol, typeChecker: ts.TypeChecker): IFollowAliasesResult {\r\n    let current: ts.Symbol = symbol;\r\n\r\n    // We will try to obtain the name from a declaration; otherwise we'll fall back to the symbol name\r\n    let declarationName: string | undefined = undefined;\r\n\r\n    while (true) { // tslint:disable-line:no-constant-condition\r\n      for (const declaration of current.declarations || []) {\r\n        const declarationNameIdentifier: ts.DeclarationName | undefined = ts.getNameOfDeclaration(declaration);\r\n        if (declarationNameIdentifier && ts.isIdentifier(declarationNameIdentifier)) {\r\n          declarationName = declarationNameIdentifier.getText().trim();\r\n        }\r\n\r\n        // 2. Check for any signs that this was imported from an external package\r\n        let result: IFollowAliasesResult | undefined;\r\n\r\n        result = SymbolAnalyzer._followAliasesForExportDeclaration(declaration, current, typeChecker);\r\n        if (result) {\r\n          return result;\r\n        }\r\n\r\n        result = SymbolAnalyzer._followAliasesForImportDeclaration(declaration, current, typeChecker);\r\n        if (result) {\r\n          return result;\r\n        }\r\n      }\r\n\r\n      if (!(current.flags & ts.SymbolFlags.Alias)) {\r\n        break;\r\n      }\r\n\r\n      const currentAlias: ts.Symbol = TypeScriptHelpers.getImmediateAliasedSymbol(current, typeChecker);\r\n      // Stop if we reach the end of the chain\r\n      if (!currentAlias || currentAlias === current) {\r\n        break;\r\n      }\r\n\r\n      current = currentAlias;\r\n    }\r\n\r\n    // Is this an ambient declaration?\r\n    let isAmbient: boolean = true;\r\n    if (current.declarations) {\r\n\r\n      // Test 1: Are we inside the sinister \"declare global {\" construct?\r\n      let insideDeclareGlobal: boolean = false;\r\n      const highestModuleDeclaration: ts.ModuleDeclaration | undefined\r\n        = TypeScriptHelpers.findHighestParent(current.declarations[0], ts.SyntaxKind.ModuleDeclaration);\r\n      if (highestModuleDeclaration) {\r\n        if (highestModuleDeclaration.name.getText().trim() === 'global') {\r\n          insideDeclareGlobal = true;\r\n        }\r\n      }\r\n\r\n      // Test 2: Otherwise, the main heuristic for ambient declarations is by looking at the\r\n      // ts.SyntaxKind.SourceFile node to see whether it has a symbol or not (i.e. whether it\r\n      // is acting as a module or not).\r\n      if (!insideDeclareGlobal) {\r\n        const sourceFileNode: ts.Node | undefined = TypeScriptHelpers.findFirstParent(\r\n          current.declarations[0], ts.SyntaxKind.SourceFile);\r\n        if (sourceFileNode && !!typeChecker.getSymbolAtLocation(sourceFileNode)) {\r\n          isAmbient = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      followedSymbol: current,\r\n      localName: declarationName || current.name,\r\n      astImport: undefined,\r\n      isAmbient: isAmbient\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Helper function for _followAliases(), for handling ts.ExportDeclaration patterns\r\n   */\r\n  private static _followAliasesForExportDeclaration(declaration: ts.Declaration,\r\n    symbol: ts.Symbol, typeChecker: ts.TypeChecker): IFollowAliasesResult | undefined {\r\n\r\n    const exportDeclaration: ts.ExportDeclaration | undefined\r\n      = TypeScriptHelpers.findFirstParent<ts.ExportDeclaration>(declaration, ts.SyntaxKind.ExportDeclaration);\r\n\r\n    if (exportDeclaration) {\r\n      let exportName: string;\r\n\r\n      if (declaration.kind === ts.SyntaxKind.ExportSpecifier) {\r\n        // EXAMPLE:\r\n        // \"export { A } from './file-a';\"\r\n        //\r\n        // ExportDeclaration:\r\n        //   ExportKeyword:  pre=[export] sep=[ ]\r\n        //   NamedExports:\r\n        //     FirstPunctuation:  pre=[{] sep=[ ]\r\n        //     SyntaxList:\r\n        //       ExportSpecifier:  <------------- declaration\r\n        //         Identifier:  pre=[A] sep=[ ]\r\n        //     CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['./file-a']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        // Example: \" ExportName as RenamedName\"\r\n        const exportSpecifier: ts.ExportSpecifier = declaration as ts.ExportSpecifier;\r\n        exportName = (exportSpecifier.propertyName || exportSpecifier.name).getText().trim();\r\n      } else {\r\n        throw new Error('Unimplemented export declaration kind: ' + declaration.getText());\r\n      }\r\n\r\n      if (exportDeclaration.moduleSpecifier) {\r\n        // Examples:\r\n        //    \" '@microsoft/sp-lodash-subset'\"\r\n        //    \" \"lodash/has\"\"\r\n        const modulePath: string | undefined = SymbolAnalyzer._getPackagePathFromModuleSpecifier(\r\n          exportDeclaration.moduleSpecifier);\r\n\r\n        if (modulePath) {\r\n          return {\r\n            followedSymbol: TypeScriptHelpers.followAliases(symbol, typeChecker),\r\n            localName: exportName,\r\n            astImport: new AstImport({ modulePath, exportName }),\r\n            isAmbient: false\r\n          };\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Helper function for _followAliases(), for handling ts.ImportDeclaration patterns\r\n   */\r\n  private static _followAliasesForImportDeclaration(declaration: ts.Declaration,\r\n    symbol: ts.Symbol, typeChecker: ts.TypeChecker): IFollowAliasesResult | undefined {\r\n\r\n    const importDeclaration: ts.ImportDeclaration | undefined\r\n      = TypeScriptHelpers.findFirstParent<ts.ImportDeclaration>(declaration, ts.SyntaxKind.ImportDeclaration);\r\n\r\n    if (importDeclaration) {\r\n      let exportName: string;\r\n\r\n      if (declaration.kind === ts.SyntaxKind.ImportSpecifier) {\r\n        // EXAMPLE:\r\n        // \"import { A, B } from 'the-lib';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:\r\n        //     NamedImports:\r\n        //       FirstPunctuation:  pre=[{] sep=[ ]\r\n        //       SyntaxList:\r\n        //         ImportSpecifier:  <------------- declaration\r\n        //           Identifier:  pre=[A]\r\n        //         CommaToken:  pre=[,] sep=[ ]\r\n        //         ImportSpecifier:\r\n        //           Identifier:  pre=[B] sep=[ ]\r\n        //       CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['the-lib']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        // Example: \" ExportName as RenamedName\"\r\n        const importSpecifier: ts.ImportSpecifier = declaration as ts.ImportSpecifier;\r\n        exportName = (importSpecifier.propertyName || importSpecifier.name).getText().trim();\r\n      } else if (declaration.kind === ts.SyntaxKind.NamespaceImport) {\r\n        // EXAMPLE:\r\n        // \"import * as theLib from 'the-lib';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:\r\n        //     NamespaceImport:  <------------- declaration\r\n        //       AsteriskToken:  pre=[*] sep=[ ]\r\n        //       AsKeyword:  pre=[as] sep=[ ]\r\n        //       Identifier:  pre=[theLib] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['the-lib']\r\n        //   SemicolonToken:  pre=[;]\r\n        exportName = '*';\r\n      } else if (declaration.kind === ts.SyntaxKind.ImportClause) {\r\n        // EXAMPLE:\r\n        // \"import A, { B } from './A';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:  <------------- declaration (referring to A)\r\n        //     Identifier:  pre=[A]\r\n        //     CommaToken:  pre=[,] sep=[ ]\r\n        //     NamedImports:\r\n        //       FirstPunctuation:  pre=[{] sep=[ ]\r\n        //       SyntaxList:\r\n        //         ImportSpecifier:\r\n        //           Identifier:  pre=[B] sep=[ ]\r\n        //       CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['./A']\r\n        //   SemicolonToken:  pre=[;]\r\n        exportName = 'default';\r\n      } else {\r\n        throw new Error('Unimplemented import declaration kind: ' + declaration.getText());\r\n      }\r\n\r\n      if (importDeclaration.moduleSpecifier) {\r\n        // Examples:\r\n        //    \" '@microsoft/sp-lodash-subset'\"\r\n        //    \" \"lodash/has\"\"\r\n        const modulePath: string | undefined = SymbolAnalyzer._getPackagePathFromModuleSpecifier(\r\n          importDeclaration.moduleSpecifier);\r\n\r\n        if (modulePath) {\r\n          return {\r\n            followedSymbol: TypeScriptHelpers.followAliases(symbol, typeChecker),\r\n            localName: symbol.name,\r\n            astImport: new AstImport({ modulePath, exportName }),\r\n            isAmbient: false\r\n          };\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private static _getPackagePathFromModuleSpecifier(moduleSpecifier: ts.Expression): string | undefined {\r\n    // Examples:\r\n    //    \" '@microsoft/sp-lodash-subset'\"\r\n    //    \" \"lodash/has\"\"\r\n    //    \" './MyClass'\"\r\n    const moduleSpecifierText: string = moduleSpecifier.getFullText();\r\n\r\n    // Remove quotes/whitespace\r\n    const path: string = moduleSpecifierText\r\n      .replace(/^\\s*['\"]/, '')\r\n      .replace(/['\"]\\s*$/, '');\r\n\r\n    // Does it start with something like \"./\" or \"../\"?\r\n    // If not, then assume it's an import from an external package\r\n    if (!/^\\.\\.?\\//.test(path)) {\r\n      return path;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n}\r\n"],"sourceRoot":"../../../../../src"}