{"version":3,"sources":["generators/dtsRollup/AstSymbolTable.ts"],"names":[],"mappings":"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","file":"AstSymbolTable.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* tslint:disable:no-bitwise */\r\n\r\nimport * as ts from 'typescript';\r\nimport { PackageJsonLookup } from '@microsoft/node-core-library';\r\n\r\nimport { AstDeclaration } from './AstDeclaration';\r\nimport { SymbolAnalyzer, IFollowAliasesResult } from './SymbolAnalyzer';\r\nimport { TypeScriptHelpers } from '../../utils/TypeScriptHelpers';\r\nimport { AstSymbol } from './AstSymbol';\r\nimport { AstImport } from './AstImport';\r\nimport { AstEntryPoint, IExportedMember } from './AstEntryPoint';\r\nimport { PackageMetadataManager } from './PackageMetadataManager';\r\n\r\n/**\r\n * AstSymbolTable is the workhorse that builds AstSymbol and AstDeclaration objects.\r\n * It maintains a cache of already constructed objects.  AstSymbolTable constructs\r\n * AstEntryPoint objects, but otherwise the state that it maintains  is agnostic of\r\n * any particular entry point.  (For example, it does not track whether a given AstSymbol\r\n * is \"exported\" or not.)\r\n */\r\nexport class AstSymbolTable {\r\n  private readonly _typeChecker: ts.TypeChecker;\r\n  private readonly _packageJsonLookup: PackageJsonLookup;\r\n  private readonly _packageMetadataManager: PackageMetadataManager;\r\n\r\n  /**\r\n   * A mapping from ts.Symbol --> AstSymbol\r\n   * NOTE: The AstSymbol.followedSymbol will always be a lookup key, but additional keys\r\n   * are possible.\r\n   *\r\n   * After following type aliases, we use this map to look up the corresponding AstSymbol.\r\n   */\r\n  private readonly _astSymbolsBySymbol: Map<ts.Symbol, AstSymbol> = new Map<ts.Symbol, AstSymbol>();\r\n\r\n  /**\r\n   * A mapping from ts.Declaration --> AstDeclaration\r\n   */\r\n  private readonly _astDeclarationsByDeclaration: Map<ts.Node, AstDeclaration>\r\n    = new Map<ts.Node, AstDeclaration>();\r\n\r\n  /**\r\n   * A mapping from AstImport.key --> AstSymbol.\r\n   *\r\n   * If AstSymbol.astImport is undefined, then it is not included in the map.\r\n   */\r\n  private readonly _astSymbolsByImportKey: Map<string, AstSymbol> = new Map<string, AstSymbol>();\r\n\r\n  /**\r\n   * Cache of fetchEntryPoint() results.\r\n   */\r\n  private readonly _astEntryPointsBySourceFile: Map<ts.SourceFile, AstEntryPoint>\r\n    = new Map<ts.SourceFile, AstEntryPoint>();\r\n\r\n  public constructor(typeChecker: ts.TypeChecker, packageJsonLookup: PackageJsonLookup) {\r\n    this._typeChecker = typeChecker;\r\n    this._packageJsonLookup = packageJsonLookup;\r\n    this._packageMetadataManager = new PackageMetadataManager(packageJsonLookup);\r\n  }\r\n\r\n  /**\r\n   * For a given source file, this analyzes all of its exports and produces an AstEntryPoint\r\n   * object.\r\n   */\r\n  public fetchEntryPoint(sourceFile: ts.SourceFile): AstEntryPoint {\r\n    let astEntryPoint: AstEntryPoint | undefined = this._astEntryPointsBySourceFile.get(sourceFile);\r\n    if (!astEntryPoint) {\r\n      const rootFileSymbol: ts.Symbol = TypeScriptHelpers.getSymbolForDeclaration(sourceFile);\r\n\r\n      if (!rootFileSymbol.declarations || !rootFileSymbol.declarations.length) {\r\n        throw new Error('Unable to find a root declaration for ' + sourceFile.fileName);\r\n      }\r\n\r\n      if (!this._packageMetadataManager.isAedocSupportedFor(sourceFile.fileName)) {\r\n        const packageJsonPath: string | undefined = this._packageJsonLookup\r\n          .tryGetPackageJsonFilePathFor(sourceFile.fileName);\r\n\r\n        if (packageJsonPath) {\r\n          throw new Error(`Please add a field such as \"tsdoc\": { \"tsdocFlavor\": \"AEDoc\" } to this file:\\n`\r\n            + packageJsonPath);\r\n        } else {\r\n          throw new Error(`The specified entry point does not appear to have an associated package.json file:\\n`\r\n            + sourceFile.fileName);\r\n        }\r\n      }\r\n\r\n      const exportSymbols: ts.Symbol[] = this._typeChecker.getExportsOfModule(rootFileSymbol) || [];\r\n\r\n      const exportedMembers: IExportedMember[] = [];\r\n\r\n      for (const exportSymbol of exportSymbols) {\r\n        const astSymbol: AstSymbol | undefined = this._fetchAstSymbol(exportSymbol, true);\r\n\r\n        if (!astSymbol) {\r\n          throw new Error('Unsupported export: ' + exportSymbol.name);\r\n        }\r\n\r\n        this.analyze(astSymbol);\r\n\r\n        exportedMembers.push({ name: exportSymbol.name, astSymbol: astSymbol });\r\n      }\r\n\r\n      astEntryPoint = new AstEntryPoint({ exportedMembers });\r\n      this._astEntryPointsBySourceFile.set(sourceFile, astEntryPoint);\r\n    }\r\n    return astEntryPoint;\r\n  }\r\n\r\n  /**\r\n   * Ensures that AstSymbol.analyzed is true for the provided symbol.  The operation\r\n   * starts from the root symbol and then fills out all children of all declarations, and\r\n   * also calculates AstDeclaration.referencedAstSymbols for all declarations.\r\n   * If the symbol is not imported, any non-imported references are also analyzed.\r\n   * @remarks\r\n   * This is an expensive operation, so we only perform it for top-level exports of an\r\n   * the AstEntryPoint.  For example, if some code references a nested class inside\r\n   * a namespace from another library, we do not analyze any of that class's siblings\r\n   * or members.  (We do always construct its parents however, since AstDefinition.parent\r\n   * is immutable, and needed e.g. to calculate release tag inheritance.)\r\n   */\r\n  public analyze(astSymbol: AstSymbol): void {\r\n    if (astSymbol.analyzed) {\r\n      return;\r\n    }\r\n\r\n    if (astSymbol.nominal) {\r\n      // We don't analyze nominal symbols\r\n      astSymbol._notifyAnalyzed();\r\n      return;\r\n    }\r\n\r\n    // Start at the root of the tree\r\n    const rootAstSymbol: AstSymbol = astSymbol.rootAstSymbol;\r\n\r\n    // Calculate the full child tree for each definition\r\n    for (const astDeclaration of rootAstSymbol.astDeclarations) {\r\n      this._analyzeChildTree(astDeclaration.declaration, astDeclaration);\r\n    }\r\n\r\n    rootAstSymbol._notifyAnalyzed();\r\n\r\n    if (!astSymbol.astImport) {\r\n      // If this symbol is not imported, then we also analyze any referencedAstSymbols\r\n      // that are not imported.  For example, this ensures that forgotten exports get\r\n      // analyzed.\r\n      rootAstSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n        for (const referencedAstSymbol of astDeclaration.referencedAstSymbols) {\r\n          // Walk up to the root of the tree, looking for any imports along the way\r\n          if (!referencedAstSymbol.imported) {\r\n            this.analyze(referencedAstSymbol);\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Looks up the AstSymbol corresponding to the given ts.Symbol.\r\n   * This will not analyze or construct any new AstSymbol objects.\r\n   */\r\n  public tryGetAstSymbol(symbol: ts.Symbol): AstSymbol | undefined {\r\n    return this._fetchAstSymbol(symbol, false);\r\n  }\r\n\r\n  /**\r\n   * For a given astDeclaration, this efficiently finds the child corresponding to the\r\n   * specified ts.Node.  It is assumed that isAstDeclaration() would return true for\r\n   * that node type, and that the node is an immediate child of the provided AstDeclaration.\r\n   */\r\n  // NOTE: This could be a method of AstSymbol if it had a backpointer to its AstSymbolTable.\r\n  public getChildAstDeclarationByNode(node: ts.Node, parentAstDeclaration: AstDeclaration): AstDeclaration {\r\n    if (!parentAstDeclaration.astSymbol.analyzed) {\r\n      throw new Error('getChildDeclarationByNode() cannot be used for an AstSymbol that was not analyzed');\r\n    }\r\n\r\n    const childAstDeclaration: AstDeclaration | undefined = this._astDeclarationsByDeclaration.get(node);\r\n    if (!childAstDeclaration) {\r\n      throw new Error('Child declaration not found for the specified node');\r\n    }\r\n    if (childAstDeclaration.parent !== parentAstDeclaration) {\r\n      throw new Error('Program Bug: The found child is not attached to the parent AstDeclaration');\r\n    }\r\n\r\n    return childAstDeclaration;\r\n  }\r\n\r\n  /**\r\n   * Used by analyze to recursively analyze the entire child tree.\r\n   */\r\n  private _analyzeChildTree(node: ts.Node, governingAstDeclaration: AstDeclaration): void {\r\n    // is this a reference to another AstSymbol?\r\n    switch (node.kind) {\r\n      case ts.SyntaxKind.TypeReference: // general type references\r\n      case ts.SyntaxKind.ExpressionWithTypeArguments: // special case for e.g. the \"extends\" keyword\r\n        {\r\n          // Sometimes the type reference will involve multiple identifiers, e.g. \"a.b.C\".\r\n          // In this case, we only need to worry about importing the first identifier,\r\n          // so do a depth-first search for it:\r\n          const symbolNode: ts.Node | undefined = TypeScriptHelpers.findFirstChildNode(\r\n            node, ts.SyntaxKind.Identifier);\r\n\r\n          if (!symbolNode) {\r\n            break;\r\n          }\r\n\r\n          const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(symbolNode);\r\n          if (!symbol) {\r\n            throw new Error('Symbol not found for identifier: ' + symbolNode.getText());\r\n          }\r\n\r\n          const referencedAstSymbol: AstSymbol | undefined = this._fetchAstSymbol(symbol, true);\r\n          if (referencedAstSymbol) {\r\n            governingAstDeclaration._notifyReferencedAstSymbol(referencedAstSymbol);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Is this node declaring a new AstSymbol?\r\n    const newGoverningAstDeclaration: AstDeclaration | undefined = this._fetchAstDeclaration(node);\r\n\r\n    for (const childNode of node.getChildren()) {\r\n      this._analyzeChildTree(childNode, newGoverningAstDeclaration || governingAstDeclaration);\r\n    }\r\n  }\r\n\r\n  // tslint:disable-next-line:no-unused-variable\r\n  private _fetchAstDeclaration(node: ts.Node): AstDeclaration | undefined {\r\n    const astSymbol: AstSymbol | undefined = this._fetchAstSymbolForNode(node);\r\n    if (!astSymbol) {\r\n      return undefined;\r\n    }\r\n\r\n    const astDeclaration: AstDeclaration | undefined\r\n      = this._astDeclarationsByDeclaration.get(node);\r\n    if (!astDeclaration) {\r\n      throw new Error('Program Bug: Unable to find constructed AstDeclaration');\r\n    }\r\n\r\n    return astDeclaration;\r\n  }\r\n\r\n  private _fetchAstSymbolForNode(node: ts.Node): AstSymbol | undefined {\r\n    if (!SymbolAnalyzer.isAstDeclaration(node.kind)) {\r\n      return undefined;\r\n    }\r\n\r\n    const symbol: ts.Symbol | undefined = TypeScriptHelpers.getSymbolForDeclaration(node as ts.Declaration);\r\n    if (!symbol) {\r\n      throw new Error('Program Bug: Unable to find symbol for node');\r\n    }\r\n\r\n    return this._fetchAstSymbol(symbol, true);\r\n  }\r\n\r\n  private _fetchAstSymbol(symbol: ts.Symbol, addIfMissing: boolean): AstSymbol | undefined {\r\n    const followAliasesResult: IFollowAliasesResult = SymbolAnalyzer.followAliases(symbol, this._typeChecker);\r\n\r\n    const followedSymbol: ts.Symbol = followAliasesResult.followedSymbol;\r\n\r\n    // Filter out symbols representing constructs that we don't care about\r\n    if (followedSymbol.flags & (ts.SymbolFlags.TypeParameter | ts.SymbolFlags.TypeLiteral | ts.SymbolFlags.Transient)) {\r\n      return undefined;\r\n    }\r\n\r\n    if (followAliasesResult.isAmbient) {\r\n      return undefined;\r\n    }\r\n\r\n    let astSymbol: AstSymbol | undefined = this._astSymbolsBySymbol.get(followedSymbol);\r\n\r\n    if (!astSymbol) {\r\n      if (!followedSymbol.declarations || followedSymbol.declarations.length < 1) {\r\n        throw new Error('Program Bug: Followed a symbol with no declarations');\r\n      }\r\n\r\n      const astImport: AstImport | undefined = followAliasesResult.astImport;\r\n\r\n      if (astImport) {\r\n        if (!astSymbol) {\r\n          astSymbol = this._astSymbolsByImportKey.get(astImport.key);\r\n          if (astSymbol) {\r\n            // We didn't find the entry using followedSymbol, but we did using importPackageKey,\r\n            // so add a mapping for followedSymbol; we'll need it later when renaming identifiers\r\n            this._astSymbolsBySymbol.set(followedSymbol, astSymbol);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!astSymbol) {\r\n        // None of the above lookups worked, so create a new entry...\r\n        let nominal: boolean = false;\r\n\r\n        // NOTE: In certain circumstances we need an AstSymbol for a source file that is acting\r\n        // as a TypeScript module.  For example, one of the unit tests has this line:\r\n        //\r\n        //   import * as semver1 from 'semver';\r\n        //\r\n        // To handle the expression \"semver1.SemVer\", we need \"semver1\" to map to an AstSymbol\r\n        // that causes us to emit the above import.  However we do NOT want it to act as the root\r\n        // of a declaration tree, because in general the *.d.ts generator is trying to roll up\r\n        // definitions and eliminate source files.  So, even though isAstDeclaration() would return\r\n        // false, we do create an AstDeclaration for a ts.SyntaxKind.SourceFile in this special edge case.\r\n        if (followedSymbol.declarations.length === 1\r\n          && followedSymbol.declarations[0].kind === ts.SyntaxKind.SourceFile) {\r\n          nominal = true;\r\n        }\r\n\r\n        // If the file is from a package that does not support AEDoc, then we process the\r\n        // symbol itself, but we don't attempt to process any parent/children of it.\r\n        if (!this._packageMetadataManager.isAedocSupportedFor(\r\n          followedSymbol.declarations[0].getSourceFile().fileName)) {\r\n          nominal = true;\r\n        }\r\n\r\n        let parentAstSymbol: AstSymbol | undefined = undefined;\r\n\r\n        if (!nominal) {\r\n          for (const declaration of followedSymbol.declarations || []) {\r\n            if (!SymbolAnalyzer.isAstDeclaration(declaration.kind)) {\r\n              throw new Error(`Program Bug: The \"${followedSymbol.name}\" symbol uses the construct`\r\n                + ` \"${ts.SyntaxKind[declaration.kind]}\" which may be an unimplemented language feature`);\r\n            }\r\n          }\r\n\r\n          // We always fetch the entire chain of parents for each declaration.\r\n          // (Children/siblings are only analyzed on demand.)\r\n\r\n          // Key assumptions behind this squirrely logic:\r\n          //\r\n          // IF a given symbol has two declarations D1 and D2; AND\r\n          // If D1 has a parent P1, then\r\n          // - D2 will also have a parent P2; AND\r\n          // - P1 and P2's symbol will be the same\r\n          // - but P1 and P2 may be different (e.g. merged namespaces containing merged interfaces)\r\n\r\n          // Is there a parent AstSymbol?  First we check to see if there is a parent declaration:\r\n          const arbitaryParentDeclaration: ts.Node | undefined\r\n            = this._tryFindFirstAstDeclarationParent(followedSymbol.declarations[0]);\r\n\r\n          if (arbitaryParentDeclaration) {\r\n            const parentSymbol: ts.Symbol = TypeScriptHelpers.getSymbolForDeclaration(\r\n              arbitaryParentDeclaration as ts.Declaration);\r\n\r\n            parentAstSymbol = this._fetchAstSymbol(parentSymbol, addIfMissing);\r\n            if (!parentAstSymbol) {\r\n              throw new Error('Program bug: Unable to construct a parent AstSymbol for '\r\n                + followedSymbol.name);\r\n            }\r\n          }\r\n        }\r\n\r\n        astSymbol = new AstSymbol({\r\n          localName: followAliasesResult.localName,\r\n          followedSymbol: followAliasesResult.followedSymbol,\r\n          astImport: astImport,\r\n          parentAstSymbol: parentAstSymbol,\r\n          rootAstSymbol: parentAstSymbol ? parentAstSymbol.rootAstSymbol : undefined,\r\n          nominal: nominal\r\n        });\r\n\r\n        this._astSymbolsBySymbol.set(followedSymbol, astSymbol);\r\n\r\n        if (astImport) {\r\n          // If it's an import, add it to the lookup\r\n          this._astSymbolsByImportKey.set(astImport.key, astSymbol);\r\n        }\r\n\r\n        // Okay, now while creating the declarations we will wire them up to the\r\n        // their corresponding parent declarations\r\n        for (const declaration of followedSymbol.declarations || []) {\r\n\r\n          let parentAstDeclaration: AstDeclaration | undefined = undefined;\r\n          if (parentAstSymbol) {\r\n            const parentDeclaration: ts.Node | undefined = this._tryFindFirstAstDeclarationParent(declaration);\r\n\r\n            if (!parentDeclaration) {\r\n              throw new Error('Program bug: Missing parent declaration');\r\n            }\r\n\r\n            parentAstDeclaration = this._astDeclarationsByDeclaration.get(parentDeclaration);\r\n            if (!parentAstDeclaration) {\r\n              throw new Error('Program bug: Missing parent AstDeclaration');\r\n            }\r\n          }\r\n\r\n          const astDeclaration: AstDeclaration = new AstDeclaration({\r\n            declaration, astSymbol, parent: parentAstDeclaration});\r\n\r\n          this._astDeclarationsByDeclaration.set(declaration, astDeclaration);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (followAliasesResult.astImport && !astSymbol.imported) {\r\n      // Our strategy for recognizing external declarations is to look for an import statement\r\n      // during SymbolAnalyzer.followAliases().  Although it is sometimes possible to reach a symbol\r\n      // without traversing an import statement, we assume that that the first reference will always\r\n      // involve an import statement.\r\n      //\r\n      // This assumption might be violated if the caller did something unusual like feeding random\r\n      // symbols to AstSymbolTable.analyze() in the middle of the analysis.\r\n      throw new Error('Program Bug: The symbol ' + astSymbol.localName + ' is being imported'\r\n        + ' after it was already registered as non-imported');\r\n    }\r\n\r\n    return astSymbol;\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent satisfying isAstDeclaration(), or undefined if none is found.\r\n   */\r\n  private _tryFindFirstAstDeclarationParent(node: ts.Node): ts.Node | undefined {\r\n    let currentNode: ts.Node | undefined = node.parent;\r\n    while (currentNode) {\r\n      if (SymbolAnalyzer.isAstDeclaration(currentNode.kind)) {\r\n        return currentNode;\r\n      }\r\n      currentNode = currentNode.parent;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n"],"sourceRoot":"../../../../../src"}