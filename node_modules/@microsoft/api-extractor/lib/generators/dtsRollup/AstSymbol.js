"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The AstDeclaration and AstSymbol classes are API Extractor's equivalent of the compiler's
 * ts.Declaration and ts.Symbol objects.  They are created by the SymbolTable class.
 *
 * @remarks
 * The AstSymbol represents the ts.Symbol information for an AstDeclaration.  For example,
 * if a method has 3 overloads, each overloaded signature will have its own AstDeclaration,
 * but they will all share a common AstSymbol.
 *
 * For nested definitions, the AstSymbol has a unique parent (i.e. AstSymbol.rootAstSymbol),
 * but the parent/children for each AstDeclaration may be different.
 */
class AstSymbol {
    constructor(parameters) {
        // This flag is unused if this is not the root symbol.
        // Being "analyzed" is a property of the root symbol.
        this._analyzed = false;
        this.followedSymbol = parameters.followedSymbol;
        this.localName = parameters.localName;
        this.astImport = parameters.astImport;
        this.nominal = parameters.nominal;
        this.parentAstSymbol = parameters.parentAstSymbol;
        this.rootAstSymbol = parameters.rootAstSymbol || this;
        this._astDeclarations = [];
    }
    /**
     * The one or more declarations for this symbol.
     * For example, if this symbol is a method, then the declarations could be
     * various method overloads.  If this symbol is a namespace, then the declarations
     * might be separate namespace blocks (with the same name).
     */
    get astDeclarations() {
        return this._astDeclarations;
    }
    /**
     * Returns true if the AstSymbolTable.analyze() was called for this object.
     * See that function for details.
     * @remarks
     * AstSymbolTable.analyze() is always performed on the root AstSymbol.  This function
     * returns true if-and-only-if the root symbol was analyzed.
     */
    get analyzed() {
        return this.rootAstSymbol._analyzed;
    }
    /**
     * Returns true if this symbol was imported from another package.
     */
    get imported() {
        return !!this.rootAstSymbol.astImport;
    }
    /**
     * This is an internal callback used when the SymbolTable attaches a new
     * AstDeclaration to this object.
     * @internal
     */
    _notifyDeclarationAttach(astDeclaration) {
        if (this.analyzed) {
            throw new Error('Program Bug: _notifyDeclarationAttach() called after analysis is already complete');
        }
        this._astDeclarations.push(astDeclaration);
    }
    /**
     * This is an internal callback used when the SymbolTable.analyze()
     * has processed this object.
     * @internal
     */
    _notifyAnalyzed() {
        if (this.parentAstSymbol) {
            throw new Error('Program Bug: _notifyAnalyzed() called for an AstSymbol which is not the root');
        }
        this._analyzed = true;
    }
    /**
     * Helper that calls AstDeclaration.forEachDeclarationRecursive() for each AstDeclaration.
     */
    forEachDeclarationRecursive(action) {
        for (const astDeclaration of this.astDeclarations) {
            astDeclaration.forEachDeclarationRecursive(action);
        }
    }
}
exports.AstSymbol = AstSymbol;

//# sourceMappingURL=AstSymbol.js.map
