{"version":3,"sources":["generators/dtsRollup/AstSymbol.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAkB3D;;;;;;;;;;;GAWG;AACH;IAmDE,YAAmB,UAAgC;QAJnD,sDAAsD;QACtD,qDAAqD;QAC7C,cAAS,GAAY,KAAK,CAAC;QAGjC,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC,cAAc,CAAC;QAChD,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;QACtC,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;QACtC,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC;QAClC,IAAI,CAAC,eAAe,GAAG,UAAU,CAAC,eAAe,CAAC;QAClD,IAAI,CAAC,aAAa,GAAG,UAAU,CAAC,aAAa,IAAI,IAAI,CAAC;QACtD,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED;;;;;OAKG;IACH,IAAW,eAAe;QACxB,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IACH,IAAW,QAAQ;QACjB,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC;IACtC,CAAC;IAED;;OAEG;IACH,IAAW,QAAQ;QACjB,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC;IACxC,CAAC;IAED;;;;OAIG;IACI,wBAAwB,CAAC,cAA8B;QAC5D,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClB,MAAM,IAAI,KAAK,CAAC,mFAAmF,CAAC,CAAC;QACvG,CAAC;QACD,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IAC7C,CAAC;IAED;;;;OAIG;IACI,eAAe;QACpB,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;YACzB,MAAM,IAAI,KAAK,CAAC,8EAA8E,CAAC,CAAC;QAClG,CAAC;QACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;IAED;;OAEG;IACI,2BAA2B,CAAC,MAAgD;QACjF,GAAG,CAAC,CAAC,MAAM,cAAc,IAAI,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;YAClD,cAAc,CAAC,2BAA2B,CAAC,MAAM,CAAC,CAAC;QACrD,CAAC;IACH,CAAC;CACF;AAzHD,8BAyHC","file":"AstSymbol.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { AstImport } from './AstImport';\r\nimport { AstDeclaration } from './AstDeclaration';\r\n\r\n/**\r\n * Constructor parameters for AstSymbol\r\n */\r\nexport interface IAstSymbolParameters {\r\n  readonly followedSymbol: ts.Symbol;\r\n  readonly localName: string;\r\n  readonly astImport: AstImport | undefined;\r\n  readonly nominal: boolean;\r\n  readonly parentAstSymbol: AstSymbol | undefined;\r\n  readonly rootAstSymbol: AstSymbol | undefined;\r\n}\r\n\r\n/**\r\n * The AstDeclaration and AstSymbol classes are API Extractor's equivalent of the compiler's\r\n * ts.Declaration and ts.Symbol objects.  They are created by the SymbolTable class.\r\n *\r\n * @remarks\r\n * The AstSymbol represents the ts.Symbol information for an AstDeclaration.  For example,\r\n * if a method has 3 overloads, each overloaded signature will have its own AstDeclaration,\r\n * but they will all share a common AstSymbol.\r\n *\r\n * For nested definitions, the AstSymbol has a unique parent (i.e. AstSymbol.rootAstSymbol),\r\n * but the parent/children for each AstDeclaration may be different.\r\n */\r\nexport class AstSymbol {\r\n  /**\r\n   * The original name of the symbol, as exported from the module (i.e. source file)\r\n   * containing the original TypeScript definition.\r\n   */\r\n  public readonly localName: string;\r\n\r\n  /**\r\n   * The compiler symbol where this type was defined, after following any aliases.\r\n   */\r\n  public readonly followedSymbol: ts.Symbol;\r\n\r\n  /**\r\n   * If this symbol was imported from another package, that information is tracked here.\r\n   * Otherwies, the value is undefined.\r\n   */\r\n  public readonly astImport: AstImport | undefined;\r\n\r\n  /**\r\n   * If true, then this AstSymbol represents a foreign object whose structure will be\r\n   * ignored.  The AstDeclaration will not have any parent or children, and its references\r\n   * will not be analyzed.\r\n   *\r\n   * Nominal symbols are tracked because we still need to emit exports for them.\r\n   */\r\n  public readonly nominal: boolean;\r\n\r\n  /**\r\n   * Returns the symbol of the parent of this AstSymbol, or undefined if there is no parent.\r\n   * @remarks\r\n   * If a symbol has multiple declarations, we assume (as an axiom) that their parent\r\n   * declarations will belong to the same symbol.  This means that the \"parent\" of a\r\n   * symbol is a well-defined concept.  However, the \"children\" of a symbol are not very\r\n   * meaningful, because different declarations may have different nested members,\r\n   * so we usually need to traverse declarations to find children.\r\n   */\r\n  public readonly parentAstSymbol: AstSymbol | undefined;\r\n\r\n  /**\r\n   * Returns the symbol of the root of the AstDeclaration hierarchy.\r\n   * @remarks\r\n   * NOTE: If this AstSymbol is the root, then rootAstSymbol will point to itself.\r\n   */\r\n  public readonly rootAstSymbol: AstSymbol;\r\n\r\n  private readonly _astDeclarations: AstDeclaration[];\r\n\r\n  // This flag is unused if this is not the root symbol.\r\n  // Being \"analyzed\" is a property of the root symbol.\r\n  private _analyzed: boolean = false;\r\n\r\n  public constructor(parameters: IAstSymbolParameters) {\r\n    this.followedSymbol = parameters.followedSymbol;\r\n    this.localName = parameters.localName;\r\n    this.astImport = parameters.astImport;\r\n    this.nominal = parameters.nominal;\r\n    this.parentAstSymbol = parameters.parentAstSymbol;\r\n    this.rootAstSymbol = parameters.rootAstSymbol || this;\r\n    this._astDeclarations = [];\r\n  }\r\n\r\n  /**\r\n   * The one or more declarations for this symbol.\r\n   * For example, if this symbol is a method, then the declarations could be\r\n   * various method overloads.  If this symbol is a namespace, then the declarations\r\n   * might be separate namespace blocks (with the same name).\r\n   */\r\n  public get astDeclarations(): ReadonlyArray<AstDeclaration> {\r\n    return this._astDeclarations;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the AstSymbolTable.analyze() was called for this object.\r\n   * See that function for details.\r\n   * @remarks\r\n   * AstSymbolTable.analyze() is always performed on the root AstSymbol.  This function\r\n   * returns true if-and-only-if the root symbol was analyzed.\r\n   */\r\n  public get analyzed(): boolean {\r\n    return this.rootAstSymbol._analyzed;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this symbol was imported from another package.\r\n   */\r\n  public get imported(): boolean {\r\n    return !!this.rootAstSymbol.astImport;\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the SymbolTable attaches a new\r\n   * AstDeclaration to this object.\r\n   * @internal\r\n   */\r\n  public _notifyDeclarationAttach(astDeclaration: AstDeclaration): void {\r\n    if (this.analyzed) {\r\n      throw new Error('Program Bug: _notifyDeclarationAttach() called after analysis is already complete');\r\n    }\r\n    this._astDeclarations.push(astDeclaration);\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the SymbolTable.analyze()\r\n   * has processed this object.\r\n   * @internal\r\n   */\r\n  public _notifyAnalyzed(): void {\r\n    if (this.parentAstSymbol) {\r\n      throw new Error('Program Bug: _notifyAnalyzed() called for an AstSymbol which is not the root');\r\n    }\r\n    this._analyzed = true;\r\n  }\r\n\r\n  /**\r\n   * Helper that calls AstDeclaration.forEachDeclarationRecursive() for each AstDeclaration.\r\n   */\r\n  public forEachDeclarationRecursive(action: (astDeclaration: AstDeclaration) => void): void {\r\n    for (const astDeclaration of this.astDeclarations) {\r\n      astDeclaration.forEachDeclarationRecursive(action);\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":"../../../../../src"}