import * as ts from 'typescript';
import { PackageJsonLookup } from '@microsoft/node-core-library';
import { AstDeclaration } from './AstDeclaration';
import { AstSymbol } from './AstSymbol';
import { AstEntryPoint } from './AstEntryPoint';
/**
 * AstSymbolTable is the workhorse that builds AstSymbol and AstDeclaration objects.
 * It maintains a cache of already constructed objects.  AstSymbolTable constructs
 * AstEntryPoint objects, but otherwise the state that it maintains  is agnostic of
 * any particular entry point.  (For example, it does not track whether a given AstSymbol
 * is "exported" or not.)
 */
export declare class AstSymbolTable {
    private readonly _typeChecker;
    private readonly _packageJsonLookup;
    private readonly _packageMetadataManager;
    /**
     * A mapping from ts.Symbol --> AstSymbol
     * NOTE: The AstSymbol.followedSymbol will always be a lookup key, but additional keys
     * are possible.
     *
     * After following type aliases, we use this map to look up the corresponding AstSymbol.
     */
    private readonly _astSymbolsBySymbol;
    /**
     * A mapping from ts.Declaration --> AstDeclaration
     */
    private readonly _astDeclarationsByDeclaration;
    /**
     * A mapping from AstImport.key --> AstSymbol.
     *
     * If AstSymbol.astImport is undefined, then it is not included in the map.
     */
    private readonly _astSymbolsByImportKey;
    /**
     * Cache of fetchEntryPoint() results.
     */
    private readonly _astEntryPointsBySourceFile;
    constructor(typeChecker: ts.TypeChecker, packageJsonLookup: PackageJsonLookup);
    /**
     * For a given source file, this analyzes all of its exports and produces an AstEntryPoint
     * object.
     */
    fetchEntryPoint(sourceFile: ts.SourceFile): AstEntryPoint;
    /**
     * Ensures that AstSymbol.analyzed is true for the provided symbol.  The operation
     * starts from the root symbol and then fills out all children of all declarations, and
     * also calculates AstDeclaration.referencedAstSymbols for all declarations.
     * If the symbol is not imported, any non-imported references are also analyzed.
     * @remarks
     * This is an expensive operation, so we only perform it for top-level exports of an
     * the AstEntryPoint.  For example, if some code references a nested class inside
     * a namespace from another library, we do not analyze any of that class's siblings
     * or members.  (We do always construct its parents however, since AstDefinition.parent
     * is immutable, and needed e.g. to calculate release tag inheritance.)
     */
    analyze(astSymbol: AstSymbol): void;
    /**
     * Looks up the AstSymbol corresponding to the given ts.Symbol.
     * This will not analyze or construct any new AstSymbol objects.
     */
    tryGetAstSymbol(symbol: ts.Symbol): AstSymbol | undefined;
    /**
     * For a given astDeclaration, this efficiently finds the child corresponding to the
     * specified ts.Node.  It is assumed that isAstDeclaration() would return true for
     * that node type, and that the node is an immediate child of the provided AstDeclaration.
     */
    getChildAstDeclarationByNode(node: ts.Node, parentAstDeclaration: AstDeclaration): AstDeclaration;
    /**
     * Used by analyze to recursively analyze the entire child tree.
     */
    private _analyzeChildTree(node, governingAstDeclaration);
    private _fetchAstDeclaration(node);
    private _fetchAstSymbolForNode(node);
    private _fetchAstSymbol(symbol, addIfMissing);
    /**
     * Returns the first parent satisfying isAstDeclaration(), or undefined if none is found.
     */
    private _tryFindFirstAstDeclarationParent(node);
}
