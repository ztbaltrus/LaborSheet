{"version":3,"sources":["utils/TypeScriptHelpers.ts"],"names":[],"mappings":"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","file":"TypeScriptHelpers.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/* tslint:disable:no-bitwise */\r\n\r\nimport * as ts from 'typescript';\r\nimport { PrettyPrinter } from './PrettyPrinter';\r\n\r\nexport class TypeScriptHelpers {\r\n  /**\r\n   * Splits on CRLF and other newline sequences\r\n   */\r\n  private static _newLineRegEx: RegExp = /\\r\\n|\\n\\r|\\r|\\n/g;\r\n\r\n  /**\r\n   * Start sequence is '/**'.\r\n   */\r\n  private static _jsdocStartRegEx: RegExp = /^\\s*\\/\\*\\*+\\s*/;\r\n\r\n  /**\r\n   * End sequence is '*\\/'.\r\n   */\r\n  private static _jsdocEndRegEx: RegExp = /\\s*\\*+\\/\\s*$/;\r\n\r\n  /**\r\n   * Intermediate lines of JSDoc comment character.\r\n   */\r\n  private static _jsdocIntermediateRegEx: RegExp = /^\\s*\\*\\s?/;\r\n\r\n  /**\r\n   * Trailing white space\r\n   */\r\n  private static _jsdocTrimRightRegEx: RegExp = /\\s*$/;\r\n\r\n  /**\r\n   * Invalid comment sequence\r\n   */\r\n  private static _jsdocCommentTerminator: RegExp = /[*][/]/g;\r\n\r\n  /**\r\n   * This traverses any type aliases to find the original place where an item was defined.\r\n   * For example, suppose a class is defined as \"export default class MyClass { }\"\r\n   * but exported from the package's index.ts like this:\r\n   *\r\n   *    export { default as _MyClass } from './MyClass';\r\n   *\r\n   * In this example, calling followAliases() on the _MyClass symbol will return the\r\n   * original definition of MyClass, traversing any intermediary places where the\r\n   * symbol was imported and re-exported.\r\n   */\r\n  public static followAliases(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\r\n    let current: ts.Symbol = symbol;\r\n    while (true) { // tslint:disable-line:no-constant-condition\r\n      if (!(current.flags & ts.SymbolFlags.Alias)) {\r\n        break;\r\n      }\r\n      const currentAlias: ts.Symbol = typeChecker.getAliasedSymbol(current);\r\n      if (!currentAlias || currentAlias === current) {\r\n        break;\r\n      }\r\n      current = currentAlias;\r\n    }\r\n\r\n    return current;\r\n  }\r\n\r\n  public static getImmediateAliasedSymbol(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\r\n    return (typeChecker as any).getImmediateAliasedSymbol(symbol); // tslint:disable-line:no-any\r\n  }\r\n\r\n  /**\r\n   * Returns the Symbol for the provided Declaration.  This is a workaround for a missing\r\n   * feature of the TypeScript Compiler API.   It is the only apparent way to reach\r\n   * certain data structures, and seems to always work, but is not officially documented.\r\n   *\r\n   * @returns The associated Symbol.  If there is no semantic information (e.g. if the\r\n   * declaration is an extra semicolon somewhere), then \"undefined\" is returned.\r\n   */\r\n  public static tryGetSymbolForDeclaration(declaration: ts.Declaration): ts.Symbol | undefined {\r\n    /* tslint:disable:no-any */\r\n    const symbol: ts.Symbol = (declaration as any).symbol;\r\n    /* tslint:enable:no-any */\r\n    return symbol;\r\n  }\r\n\r\n  /**\r\n   * Same semantics as tryGetSymbolForDeclaration(), but throws an exception if the symbol\r\n   * cannot be found.\r\n   */\r\n  public static getSymbolForDeclaration(declaration: ts.Declaration): ts.Symbol {\r\n    const symbol: ts.Symbol | undefined = TypeScriptHelpers.tryGetSymbolForDeclaration(declaration);\r\n    if (!symbol) {\r\n      throw new Error(PrettyPrinter.formatFileAndLineNumber(declaration) + ': '\r\n        + 'Unable to determine semantic information for this declaration');\r\n    }\r\n    return symbol;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the comment ranges associated with the specified node.\r\n   */\r\n  public static getJSDocCommentRanges(node: ts.Node, text: string): ts.CommentRange[] | undefined {\r\n    // Compiler internal:\r\n    // https://github.com/Microsoft/TypeScript/blob/v2.4.2/src/compiler/utilities.ts#L616\r\n\r\n    // tslint:disable-next-line:no-any\r\n    return (ts as any).getJSDocCommentRanges.apply(this, arguments);\r\n  }\r\n\r\n  /**\r\n   * Similar to calling string.split() with a RegExp, except that the delimiters\r\n   * are included in the result.\r\n   *\r\n   * Example: _splitStringWithRegEx(\"ABCDaFG\", /A/gi) -> [ \"A\", \"BCD\", \"a\", \"FG\" ]\r\n   * Example: _splitStringWithRegEx(\"\", /A/gi) -> [ ]\r\n   * Example: _splitStringWithRegEx(\"\", /A?/gi) -> [ \"\" ]\r\n   */\r\n  public static splitStringWithRegEx(text: string, regExp: RegExp): string[] {\r\n    if (!regExp.global) {\r\n      throw new Error('RegExp must have the /g flag');\r\n    }\r\n    if (text === undefined) {\r\n      return [];\r\n    }\r\n\r\n    const result: string[] = [];\r\n    let index: number = 0;\r\n    let match: RegExpExecArray | null;\r\n\r\n    do {\r\n      match = regExp.exec(text);\r\n      if (match) {\r\n        if (match.index > index) {\r\n          result.push(text.substring(index, match.index));\r\n        }\r\n        const matchText: string = match[0];\r\n        if (!matchText) {\r\n          // It might be interesting to support matching e.g. '\\b', but regExp.exec()\r\n          // doesn't seem to iterate properly in this situation.\r\n          throw new Error('The regular expression must match a nonzero number of characters');\r\n        }\r\n        result.push(matchText);\r\n        index = regExp.lastIndex;\r\n      }\r\n    } while (match && regExp.global);\r\n\r\n    if (index < text.length) {\r\n      result.push(text.substr(index));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Extracts the body of a JSDoc comment and returns it.\r\n   */\r\n  // Examples:\r\n  // \"/**\\n * this is\\n * a test\\n */\\n\" --> \"this is\\na test\\n\"\r\n  // \"/** single line comment */\" --> \"single line comment\"\r\n  public static extractJSDocContent(text: string, errorLogger: (message: string) => void): string {\r\n    // Remove any leading/trailing whitespace around the comment characters, then split on newlines\r\n    const lines: string[] = text.trim().split(TypeScriptHelpers._newLineRegEx);\r\n    if (lines.length === 0) {\r\n      return '';\r\n    }\r\n\r\n    let matched: boolean;\r\n\r\n    // Remove \"/**\" from the first line\r\n    matched = false;\r\n    lines[0] = lines[0].replace(TypeScriptHelpers._jsdocStartRegEx, () => {\r\n      matched = true;\r\n      return '';\r\n    });\r\n    if (!matched) {\r\n      errorLogger('The comment does not begin with a \\\"/**\\\" delimiter.');\r\n      return '';\r\n    }\r\n\r\n    // Remove \"*/\" from the last line\r\n    matched = false;\r\n    lines[lines.length - 1] = lines[lines.length - 1].replace(TypeScriptHelpers._jsdocEndRegEx, () => {\r\n      matched = true;\r\n      return '';\r\n    });\r\n    if (!matched) {\r\n      errorLogger('The comment does not end with a \\\"*/\\\" delimiter.');\r\n      return '';\r\n    }\r\n\r\n    // Remove a leading \"*\" from all lines except the first one\r\n    for (let i: number = 1; i < lines.length; ++i) {\r\n      lines[i] = lines[i].replace(TypeScriptHelpers._jsdocIntermediateRegEx, '');\r\n    }\r\n\r\n    // Remove trailing spaces from all lines\r\n    for (let i: number = 0; i < lines.length; ++i) {\r\n      lines[i] = lines[i].replace(TypeScriptHelpers._jsdocTrimRightRegEx, '');\r\n    }\r\n\r\n    // If the first line is blank, then remove it\r\n    if (lines[0] === '') {\r\n      lines.shift();\r\n    }\r\n\r\n    return lines.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Returns a JSDoc comment containing the provided content.\r\n   *\r\n   * @remarks\r\n   * This is the inverse of the extractJSDocContent() operation.\r\n   */\r\n  // Examples:\r\n  // \"this is\\na test\\n\" --> \"/**\\n * this is\\n * a test\\n */\\n\"\r\n  // \"single line comment\" --> \"/** single line comment */\"\r\n  public static formatJSDocContent(content: string): string {\r\n    if (!content) {\r\n      return '';\r\n    }\r\n\r\n    // If the string contains \"*/\", then replace it with \"*\\/\"\r\n    const escapedContent: string = content.replace(TypeScriptHelpers._jsdocCommentTerminator, '*\\\\/');\r\n\r\n    const lines: string[] = escapedContent.split(TypeScriptHelpers._newLineRegEx);\r\n    if (lines.length === 0) {\r\n      return '';\r\n    }\r\n\r\n    if (lines.length < 2) {\r\n      return `/** ${escapedContent} */`;\r\n    } else {\r\n      // If there was a trailing newline, remove it\r\n      if (lines[lines.length - 1] === '') {\r\n        lines.pop();\r\n      }\r\n\r\n      return '/**\\n * '\r\n        + lines.join('\\n * ')\r\n        + '\\n */';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an ancestor of \"node\", such that the ancestor, any intermediary nodes,\r\n   * and the starting node match a list of expected kinds.  Undefined is returned\r\n   * if there aren't enough ancestors, or if the kinds are incorrect.\r\n   *\r\n   * For example, suppose child \"C\" has parents A --> B --> C.\r\n   *\r\n   * Calling _matchAncestor(C, [ExportSpecifier, NamedExports, ExportDeclaration])\r\n   * would return A only if A is of kind ExportSpecifier, B is of kind NamedExports,\r\n   * and C is of kind ExportDeclaration.\r\n   *\r\n   * Calling _matchAncestor(C, [ExportDeclaration]) would return C.\r\n   */\r\n  public static matchAncestor<T extends ts.Node>(node: ts.Node, kindsToMatch: ts.SyntaxKind[]): T | undefined {\r\n    // (slice(0) clones an array)\r\n    const reversedParentKinds: ts.SyntaxKind[] = kindsToMatch.slice(0).reverse();\r\n\r\n    let current: ts.Node | undefined = undefined;\r\n\r\n    for (const parentKind of reversedParentKinds) {\r\n      if (!current) {\r\n        // The first time through, start with node\r\n        current = node;\r\n      } else {\r\n        // Then walk the parents\r\n        current = current.parent;\r\n      }\r\n\r\n      // If we ran out of items, or if the kind doesn't match, then fail\r\n      if (!current || current.kind !== parentKind) {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    // If we matched everything, then return the node that matched the last parentKinds item\r\n    return current as T;\r\n  }\r\n\r\n  /**\r\n   * Does a depth-first search of the children of the specified node.  Returns the first child\r\n   * with the specified kind, or undefined if there is no match.\r\n   */\r\n  public static findFirstChildNode<T extends ts.Node>(node: ts.Node, kindToMatch: ts.SyntaxKind): T | undefined {\r\n    for (const child of node.getChildren()) {\r\n      if (child.kind === kindToMatch) {\r\n        return child as T;\r\n      }\r\n\r\n      const recursiveMatch: T | undefined = TypeScriptHelpers.findFirstChildNode(child, kindToMatch);\r\n      if (recursiveMatch) {\r\n        return recursiveMatch;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.\r\n   * @remarks\r\n   * This search will NOT match the starting node.\r\n   */\r\n  public static findFirstParent<T extends ts.Node>(node: ts.Node, kindToMatch: ts.SyntaxKind): T | undefined {\r\n    let current: ts.Node | undefined = node.parent;\r\n\r\n    while (current) {\r\n      if (current.kind === kindToMatch) {\r\n        return current as T;\r\n      }\r\n      current = current.parent;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the highest parent node with the specified SyntaxKind, or undefined if there is no match.\r\n   * @remarks\r\n   * Whereas findFirstParent() returns the first match, findHighestParent() returns the last match.\r\n   */\r\n  public static findHighestParent<T extends ts.Node>(node: ts.Node, kindToMatch: ts.SyntaxKind): T | undefined {\r\n    let current: ts.Node | undefined = node;\r\n    let highest: T | undefined = undefined;\r\n\r\n    while (true) { // tslint:disable-line:no-constant-condition\r\n      current = TypeScriptHelpers.findFirstParent<T>(current, kindToMatch);\r\n      if (!current) {\r\n        break;\r\n      }\r\n      highest = current as T;\r\n    }\r\n\r\n    return highest;\r\n  }\r\n}\r\n"],"sourceRoot":"../../../src"}