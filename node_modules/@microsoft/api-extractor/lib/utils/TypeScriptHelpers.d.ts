import * as ts from 'typescript';
export declare class TypeScriptHelpers {
    /**
     * Splits on CRLF and other newline sequences
     */
    private static _newLineRegEx;
    /**
     * Start sequence is '/**'.
     */
    private static _jsdocStartRegEx;
    /**
     * End sequence is '*\/'.
     */
    private static _jsdocEndRegEx;
    /**
     * Intermediate lines of JSDoc comment character.
     */
    private static _jsdocIntermediateRegEx;
    /**
     * Trailing white space
     */
    private static _jsdocTrimRightRegEx;
    /**
     * Invalid comment sequence
     */
    private static _jsdocCommentTerminator;
    /**
     * This traverses any type aliases to find the original place where an item was defined.
     * For example, suppose a class is defined as "export default class MyClass { }"
     * but exported from the package's index.ts like this:
     *
     *    export { default as _MyClass } from './MyClass';
     *
     * In this example, calling followAliases() on the _MyClass symbol will return the
     * original definition of MyClass, traversing any intermediary places where the
     * symbol was imported and re-exported.
     */
    static followAliases(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol;
    static getImmediateAliasedSymbol(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol;
    /**
     * Returns the Symbol for the provided Declaration.  This is a workaround for a missing
     * feature of the TypeScript Compiler API.   It is the only apparent way to reach
     * certain data structures, and seems to always work, but is not officially documented.
     *
     * @returns The associated Symbol.  If there is no semantic information (e.g. if the
     * declaration is an extra semicolon somewhere), then "undefined" is returned.
     */
    static tryGetSymbolForDeclaration(declaration: ts.Declaration): ts.Symbol | undefined;
    /**
     * Same semantics as tryGetSymbolForDeclaration(), but throws an exception if the symbol
     * cannot be found.
     */
    static getSymbolForDeclaration(declaration: ts.Declaration): ts.Symbol;
    /**
     * Retrieves the comment ranges associated with the specified node.
     */
    static getJSDocCommentRanges(node: ts.Node, text: string): ts.CommentRange[] | undefined;
    /**
     * Similar to calling string.split() with a RegExp, except that the delimiters
     * are included in the result.
     *
     * Example: _splitStringWithRegEx("ABCDaFG", /A/gi) -> [ "A", "BCD", "a", "FG" ]
     * Example: _splitStringWithRegEx("", /A/gi) -> [ ]
     * Example: _splitStringWithRegEx("", /A?/gi) -> [ "" ]
     */
    static splitStringWithRegEx(text: string, regExp: RegExp): string[];
    /**
     * Extracts the body of a JSDoc comment and returns it.
     */
    static extractJSDocContent(text: string, errorLogger: (message: string) => void): string;
    /**
     * Returns a JSDoc comment containing the provided content.
     *
     * @remarks
     * This is the inverse of the extractJSDocContent() operation.
     */
    static formatJSDocContent(content: string): string;
    /**
     * Returns an ancestor of "node", such that the ancestor, any intermediary nodes,
     * and the starting node match a list of expected kinds.  Undefined is returned
     * if there aren't enough ancestors, or if the kinds are incorrect.
     *
     * For example, suppose child "C" has parents A --> B --> C.
     *
     * Calling _matchAncestor(C, [ExportSpecifier, NamedExports, ExportDeclaration])
     * would return A only if A is of kind ExportSpecifier, B is of kind NamedExports,
     * and C is of kind ExportDeclaration.
     *
     * Calling _matchAncestor(C, [ExportDeclaration]) would return C.
     */
    static matchAncestor<T extends ts.Node>(node: ts.Node, kindsToMatch: ts.SyntaxKind[]): T | undefined;
    /**
     * Does a depth-first search of the children of the specified node.  Returns the first child
     * with the specified kind, or undefined if there is no match.
     */
    static findFirstChildNode<T extends ts.Node>(node: ts.Node, kindToMatch: ts.SyntaxKind): T | undefined;
    /**
     * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.
     * @remarks
     * This search will NOT match the starting node.
     */
    static findFirstParent<T extends ts.Node>(node: ts.Node, kindToMatch: ts.SyntaxKind): T | undefined;
    /**
     * Returns the highest parent node with the specified SyntaxKind, or undefined if there is no match.
     * @remarks
     * Whereas findFirstParent() returns the first match, findHighestParent() returns the last match.
     */
    static findHighestParent<T extends ts.Node>(node: ts.Node, kindToMatch: ts.SyntaxKind): T | undefined;
}
