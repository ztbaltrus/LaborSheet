"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-bitwise */
const ts = require("typescript");
const AstItemContainer_1 = require("./AstItemContainer");
const TypeScriptHelpers_1 = require("../utils/TypeScriptHelpers");
const AstStructuredType_1 = require("./AstStructuredType");
const AstEnum_1 = require("./AstEnum");
const AstFunction_1 = require("./AstFunction");
/**
  * This is an abstract base class for AstPackage and AstNamespace.
  */
class AstModule extends AstItemContainer_1.AstItemContainer {
    processModuleExport(exportSymbol) {
        const followedSymbol = TypeScriptHelpers_1.TypeScriptHelpers.followAliases(exportSymbol, this.typeChecker);
        if (!followedSymbol.declarations) {
            // This is an API Extractor bug, but it could happen e.g. if we upgrade to a new
            // version of the TypeScript compiler that introduces new AST variations that we
            // haven't tested before.
            this.reportWarning(`Definition with no declarations: ${exportSymbol.name}`);
            return;
        }
        for (const declaration of followedSymbol.declarations) {
            const options = {
                context: this.context,
                declaration,
                declarationSymbol: followedSymbol,
                exportSymbol
            };
            if (followedSymbol.flags & (ts.SymbolFlags.Class | ts.SymbolFlags.Interface)) {
                this.addMemberItem(new AstStructuredType_1.AstStructuredType(options));
            }
            else if (followedSymbol.flags & (ts.SymbolFlags.ValueModule | ts.SymbolFlags.NamespaceModule)) {
                this.addMemberItem(new AstNamespace_1.AstNamespace(options)); // tslint:disable-line:no-use-before-declare
            }
            else if (followedSymbol.flags & ts.SymbolFlags.Function) {
                this.addMemberItem(new AstFunction_1.AstFunction(options));
            }
            else if (followedSymbol.flags & ts.SymbolFlags.Enum) {
                this.addMemberItem(new AstEnum_1.AstEnum(options));
            }
            else {
                this.reportWarning(`Unsupported export: ${exportSymbol.name}`);
            }
        }
    }
}
exports.AstModule = AstModule;
// This is defer imported to break the circular dependency
const AstNamespace_1 = require("./AstNamespace");

//# sourceMappingURL=AstModule.js.map
