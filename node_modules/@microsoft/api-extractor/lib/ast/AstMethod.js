"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const node_core_library_1 = require("@microsoft/node-core-library");
const AstItem_1 = require("./AstItem");
const AstMember_1 = require("./AstMember");
const AstParameter_1 = require("./AstParameter");
const TypeScriptHelpers_1 = require("../utils/TypeScriptHelpers");
const Markup_1 = require("../markup/Markup");
/**
 * This class is part of the AstItem abstract syntax tree. It represents functions that are members of
 * classes, interfaces, or nested type literal expressions. Unlike AstFunctions, AstMethods can have
 * access modifiers (public, private, etc.) or be optional, because they are members of a structured type
 *
 * @see AstFunction for functions that are defined inside of a package
 */
class AstMethod extends AstMember_1.AstMember {
    constructor(options) {
        super(options);
        // tslint:disable-next-line:no-bitwise
        if ((options.declarationSymbol.flags & ts.SymbolFlags.Constructor) !== 0) {
            this.kind = AstItem_1.AstItemKind.Constructor;
        }
        else {
            this.kind = AstItem_1.AstItemKind.Method;
        }
        const methodDeclaration = options.declaration;
        // Parameters
        if (methodDeclaration.parameters) {
            this.params = [];
            for (const param of methodDeclaration.parameters) {
                const declarationSymbol = TypeScriptHelpers_1.TypeScriptHelpers.getSymbolForDeclaration(param);
                const astParameter = new AstParameter_1.AstParameter({
                    context: this.context,
                    declaration: param,
                    declarationSymbol: declarationSymbol
                });
                this.innerItems.push(astParameter);
                this.params.push(astParameter);
            }
        }
        // Return type
        if (this.kind !== AstItem_1.AstItemKind.Constructor) {
            if (methodDeclaration.type) {
                this.returnType = node_core_library_1.Text.convertToLf(methodDeclaration.type.getText());
            }
            else {
                this.returnType = 'any';
                this.hasIncompleteTypes = true;
            }
        }
    }
    onCompleteInitialization() {
        super.onCompleteInitialization();
        // If this is a class constructor, and if the documentation summary was omitted, then
        // we fill in a default summary versus flagging it as "undocumented".
        // Generally class constructors have uninteresting documentation.
        if (this.kind === AstItem_1.AstItemKind.Constructor && this.parentContainer) {
            if (this.documentation.summary.length === 0) {
                this.documentation.summary.push(...Markup_1.Markup.createTextElements('Constructs a new instance of the '));
                const parsedPackageName = this.context.parsedPackageName;
                const parentParentContainer = this.parentContainer.parentContainer;
                if (parentParentContainer && parentParentContainer.kind === AstItem_1.AstItemKind.Namespace) {
                    // This is a temporary workaround to support policies.namespaceSupport === permissive
                    // until the new AstSymbolTable engine is wired up
                    this.documentation.summary.push(Markup_1.Markup.createApiLinkFromText(this.parentContainer.name, {
                        scopeName: parsedPackageName.scope,
                        packageName: parsedPackageName.unscopedName,
                        exportName: parentParentContainer.name,
                        memberName: this.parentContainer.name
                    }));
                }
                else {
                    this.documentation.summary.push(Markup_1.Markup.createApiLinkFromText(this.parentContainer.name, {
                        scopeName: parsedPackageName.scope,
                        packageName: parsedPackageName.unscopedName,
                        exportName: this.parentContainer.name,
                        memberName: ''
                    }));
                }
                this.documentation.summary.push(...Markup_1.Markup.createTextElements(' class'));
            }
            this.needsDocumentation = false;
        }
    }
}
exports.AstMethod = AstMethod;

//# sourceMappingURL=AstMethod.js.map
