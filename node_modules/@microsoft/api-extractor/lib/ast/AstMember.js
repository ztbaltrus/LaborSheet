"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const node_core_library_1 = require("@microsoft/node-core-library");
const AstItem_1 = require("./AstItem");
const AstStructuredType_1 = require("./AstStructuredType");
const PrettyPrinter_1 = require("../utils/PrettyPrinter");
const TypeScriptHelpers_1 = require("../utils/TypeScriptHelpers");
var ApiAccessModifier;
(function (ApiAccessModifier) {
    ApiAccessModifier[ApiAccessModifier["Private"] = 0] = "Private";
    ApiAccessModifier[ApiAccessModifier["Protected"] = 1] = "Protected";
    ApiAccessModifier[ApiAccessModifier["Public"] = 2] = "Public";
})(ApiAccessModifier = exports.ApiAccessModifier || (exports.ApiAccessModifier = {}));
/**
 * This class is part of the AstItem abstract syntax tree.  It represents syntax following
 * these types of patterns:
 *
 * - "someName: SomeTypeName;"
 * - "someName?: SomeTypeName;"
 * - "someName: { someOtherName: SomeOtherTypeName }", i.e. involving a type literal expression
 * - "someFunction(): void;"
 *
 * AstMember is used to represent members of classes, interfaces, and nested type literal expressions.
 */
class AstMember extends AstItem_1.AstItem {
    constructor(options) {
        super(options);
        this.typeLiteral = undefined;
        const memberSignature = this.declaration;
        this.isOptional = !!memberSignature.questionToken;
        // Modifiers
        if (memberSignature.modifiers) {
            for (const modifier of memberSignature.modifiers) {
                if (modifier.kind === ts.SyntaxKind.PublicKeyword) {
                    this.accessModifier = ApiAccessModifier.Public;
                }
                else if (modifier.kind === ts.SyntaxKind.ProtectedKeyword) {
                    this.accessModifier = ApiAccessModifier.Protected;
                }
                else if (modifier.kind === ts.SyntaxKind.PrivateKeyword) {
                    this.accessModifier = ApiAccessModifier.Private;
                }
                else if (modifier.kind === ts.SyntaxKind.StaticKeyword) {
                    this.isStatic = true;
                }
            }
        }
        if (memberSignature.type && memberSignature.type.kind === ts.SyntaxKind.TypeLiteral) {
            const propertyTypeDeclaration = memberSignature.type;
            const propertyTypeSymbol = TypeScriptHelpers_1.TypeScriptHelpers.getSymbolForDeclaration(propertyTypeDeclaration);
            const typeLiteralOptions = {
                context: this.context,
                declaration: propertyTypeDeclaration,
                declarationSymbol: propertyTypeSymbol
            };
            this.typeLiteral = new AstStructuredType_1.AstStructuredType(typeLiteralOptions);
            this.innerItems.push(this.typeLiteral);
        }
    }
    /**
     * @virtual
     */
    visitTypeReferencesForAstItem() {
        super.visitTypeReferencesForAstItem();
        if (this.declaration.kind !== ts.SyntaxKind.PropertySignature) {
            this.visitTypeReferencesForNode(this.declaration);
        }
    }
    /**
     * Returns a text string such as "someName?: SomeTypeName;", or in the case of a type
     * literal expression, returns a text string such as "someName?:".
     */
    getDeclarationLine(property) {
        if (this.typeLiteral || !!property) {
            const accessModifier = this.accessModifier ? ApiAccessModifier[this.accessModifier].toLowerCase() : undefined;
            let result = accessModifier ? `${accessModifier} ` : '';
            result += this.isStatic ? 'static ' : '';
            result += property && property.readonly ? 'readonly ' : '';
            result += `${this.name}`;
            result += this.isOptional ? '?' : '';
            result += ':';
            result += !this.typeLiteral && property && property.type ? ` ${property.type};` : '';
            return node_core_library_1.Text.convertToLf(result);
        }
        else {
            return PrettyPrinter_1.PrettyPrinter.getDeclarationSummary(this.declaration);
        }
    }
}
exports.AstMember = AstMember;

//# sourceMappingURL=AstMember.js.map
